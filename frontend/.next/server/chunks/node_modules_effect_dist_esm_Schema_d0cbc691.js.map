{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"Schema.js","sources":["file://D%3A/Desktop/project/Business-Directory/Business-Directory/frontend/node_modules/effect/src/Schema.ts"],"sourcesContent":["/**\n * @since 3.10.0\n */\n\nimport type { ArbitraryAnnotation, ArbitraryGenerationContext, LazyArbitrary } from \"./Arbitrary.js\"\nimport * as array_ from \"./Array.js\"\nimport * as bigDecimal_ from \"./BigDecimal.js\"\nimport * as bigInt_ from \"./BigInt.js\"\nimport * as boolean_ from \"./Boolean.js\"\nimport type { Brand } from \"./Brand.js\"\nimport * as cause_ from \"./Cause.js\"\nimport * as chunk_ from \"./Chunk.js\"\nimport * as config_ from \"./Config.js\"\nimport * as configError_ from \"./ConfigError.js\"\nimport * as data_ from \"./Data.js\"\nimport * as dateTime from \"./DateTime.js\"\nimport * as duration_ from \"./Duration.js\"\nimport * as Effect from \"./Effect.js\"\nimport * as either_ from \"./Either.js\"\nimport * as Encoding from \"./Encoding.js\"\nimport * as Equal from \"./Equal.js\"\nimport * as Equivalence from \"./Equivalence.js\"\nimport * as exit_ from \"./Exit.js\"\nimport * as fastCheck_ from \"./FastCheck.js\"\nimport * as fiberId_ from \"./FiberId.js\"\nimport type { LazyArg } from \"./Function.js\"\nimport { dual, identity } from \"./Function.js\"\nimport { globalValue } from \"./GlobalValue.js\"\nimport * as hashMap_ from \"./HashMap.js\"\nimport * as hashSet_ from \"./HashSet.js\"\nimport * as errors_ from \"./internal/schema/errors.js\"\nimport * as schemaId_ from \"./internal/schema/schemaId.js\"\nimport * as util_ from \"./internal/schema/util.js\"\nimport * as list_ from \"./List.js\"\nimport * as number_ from \"./Number.js\"\nimport * as option_ from \"./Option.js\"\nimport type * as Order from \"./Order.js\"\nimport * as ParseResult from \"./ParseResult.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport { pipeArguments } from \"./Pipeable.js\"\nimport * as Predicate from \"./Predicate.js\"\nimport type * as pretty_ from \"./Pretty.js\"\nimport * as record_ from \"./Record.js\"\nimport * as redacted_ from \"./Redacted.js\"\nimport * as Request from \"./Request.js\"\nimport type { ParseOptions } from \"./SchemaAST.js\"\nimport * as AST from \"./SchemaAST.js\"\nimport * as sortedSet_ from \"./SortedSet.js\"\nimport * as string_ from \"./String.js\"\nimport * as struct_ from \"./Struct.js\"\nimport type * as Types from \"./Types.js\"\n\n/**\n * @since 3.10.0\n */\nexport type Simplify<A> = { [K in keyof A]: A[K] } & {}\n\n/**\n * @since 3.10.0\n */\nexport type SimplifyMutable<A> = {\n  -readonly [K in keyof A]: A[K]\n} extends infer B ? B : never\n\n/**\n * @since 3.10.0\n * @category symbol\n */\nexport const TypeId: unique symbol = Symbol.for(\"effect/Schema\")\n\n/**\n * @since 3.10.0\n * @category symbol\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @category model\n * @since 3.10.0\n */\nexport interface Schema<in out A, in out I = A, out R = never> extends Schema.Variance<A, I, R>, Pipeable {\n  readonly Type: A\n  readonly Encoded: I\n  readonly Context: R\n  readonly ast: AST.AST\n  /**\n   * Merges a set of new annotations with existing ones, potentially overwriting\n   * any duplicates.\n   */\n  annotations(annotations: Annotations.GenericSchema<A>): Schema<A, I, R>\n}\n\n/**\n * @category model\n * @since 3.10.0\n */\nexport interface SchemaClass<A, I = A, R = never> extends AnnotableClass<SchemaClass<A, I, R>, A, I, R> {}\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport const make = <A, I = A, R = never>(ast: AST.AST): SchemaClass<A, I, R> => (class SchemaClass {\n  [TypeId] = variance\n  static Type: A\n  static Encoded: I\n  static Context: R\n  static [TypeId] = variance\n  static ast = ast\n  static annotations(annotations: Annotations.GenericSchema<A>) {\n    return make<A, I, R>(mergeSchemaAnnotations(this.ast, annotations))\n  }\n  static pipe() {\n    return pipeArguments(this, arguments)\n  }\n  static toString() {\n    return String(ast)\n  }\n})\n\nconst variance = {\n  /* c8 ignore next */\n  _A: (_: any) => _,\n  /* c8 ignore next */\n  _I: (_: any) => _,\n  /* c8 ignore next */\n  _R: (_: never) => _\n}\n\ninterface AllAnnotations<A, TypeParameters extends ReadonlyArray<any>>\n  extends Annotations.Schema<A, TypeParameters>, PropertySignature.Annotations<A>\n{}\n\nconst builtInAnnotations = {\n  schemaId: AST.SchemaIdAnnotationId,\n  message: AST.MessageAnnotationId,\n  missingMessage: AST.MissingMessageAnnotationId,\n  identifier: AST.IdentifierAnnotationId,\n  title: AST.TitleAnnotationId,\n  description: AST.DescriptionAnnotationId,\n  examples: AST.ExamplesAnnotationId,\n  default: AST.DefaultAnnotationId,\n  documentation: AST.DocumentationAnnotationId,\n  jsonSchema: AST.JSONSchemaAnnotationId,\n  arbitrary: AST.ArbitraryAnnotationId,\n  pretty: AST.PrettyAnnotationId,\n  equivalence: AST.EquivalenceAnnotationId,\n  concurrency: AST.ConcurrencyAnnotationId,\n  batching: AST.BatchingAnnotationId,\n  parseIssueTitle: AST.ParseIssueTitleAnnotationId,\n  parseOptions: AST.ParseOptionsAnnotationId,\n  decodingFallback: AST.DecodingFallbackAnnotationId\n}\n\nconst toASTAnnotations = <A, TypeParameters extends ReadonlyArray<any>>(\n  annotations?: AllAnnotations<A, TypeParameters>\n): AST.Annotations => {\n  if (!annotations) {\n    return {}\n  }\n  const out: Types.Mutable<AST.Annotations> = { ...annotations }\n\n  for (const key in builtInAnnotations) {\n    if (key in annotations) {\n      const id = builtInAnnotations[key as keyof typeof builtInAnnotations]\n      out[id] = annotations[key as keyof typeof annotations]\n      delete out[key]\n    }\n  }\n\n  return out\n}\n\nconst mergeSchemaAnnotations = <A>(ast: AST.AST, annotations: Annotations.Schema<A>): AST.AST =>\n  AST.annotations(ast, toASTAnnotations(annotations))\n\n/**\n * @category annotations\n * @since 3.10.0\n */\nexport declare namespace Annotable {\n  /**\n   * @since 3.10.0\n   */\n  export type Self<S extends All> = ReturnType<S[\"annotations\"]>\n\n  /**\n   * @since 3.10.0\n   */\n  export type Any = Annotable<any, any, any, unknown>\n\n  /**\n   * @since 3.10.0\n   */\n  export type All =\n    | Any\n    | Annotable<any, any, never, unknown>\n    | Annotable<any, never, any, unknown>\n    | Annotable<any, never, never, unknown>\n}\n\n/**\n * @category annotations\n * @since 3.10.0\n */\nexport interface Annotable<Self extends Schema<A, I, R>, A, I = A, R = never> extends Schema<A, I, R> {\n  annotations(annotations: Annotations.GenericSchema<A>): Self\n}\n\n/**\n * @category annotations\n * @since 3.10.0\n */\nexport interface AnnotableClass<Self extends Schema<A, I, R>, A, I = A, R = never> extends Annotable<Self, A, I, R> {\n  new(_: never): Schema.Variance<A, I, R>\n}\n\n/**\n * @since 3.10.0\n */\nexport const asSchema = <S extends Schema.All>(\n  schema: S\n): Schema<Schema.Type<S>, Schema.Encoded<S>, Schema.Context<S>> => schema as any\n\n/**\n * @category formatting\n * @since 3.10.0\n */\nexport const format = <S extends Schema.All>(schema: S): string => String(schema.ast)\n\n/**\n * @since 3.10.0\n */\nexport declare namespace Schema {\n  /**\n   * @since 3.10.0\n   */\n  export interface Variance<A, I, R> {\n    readonly [TypeId]: {\n      readonly _A: Types.Invariant<A>\n      readonly _I: Types.Invariant<I>\n      readonly _R: Types.Covariant<R>\n    }\n  }\n\n  /**\n   * @since 3.10.0\n   */\n  export type Type<S> = S extends Schema.Variance<infer A, infer _I, infer _R> ? A : never\n\n  /**\n   * @since 3.10.0\n   */\n  export type Encoded<S> = S extends Schema.Variance<infer _A, infer I, infer _R> ? I : never\n\n  /**\n   * @since 3.10.0\n   */\n  export type Context<S> = S extends Schema.Variance<infer _A, infer _I, infer R> ? R : never\n\n  /**\n   * @since 3.10.0\n   */\n  export type ToAsserts<S extends AnyNoContext> = (\n    input: unknown,\n    options?: AST.ParseOptions\n  ) => asserts input is Schema.Type<S>\n\n  /**\n   * Any schema, except for `never`.\n   *\n   * @since 3.10.0\n   */\n  export type Any = Schema<any, any, unknown>\n\n  /**\n   * Any schema with `Context = never`, except for `never`.\n   *\n   * @since 3.10.0\n   */\n  export type AnyNoContext = Schema<any, any, never>\n\n  /**\n   * Any schema, including `never`.\n   *\n   * @since 3.10.0\n   */\n  export type All =\n    | Any\n    | Schema<any, never, unknown>\n    | Schema<never, any, unknown>\n    | Schema<never, never, unknown>\n\n  /**\n   * Type-level counterpart of `Schema.asSchema` function.\n   *\n   * @since 3.10.0\n   */\n  export type AsSchema<S extends All> = Schema<Type<S>, Encoded<S>, Context<S>>\n}\n\n/**\n * The `encodedSchema` function allows you to extract the `Encoded` portion of a\n * schema, creating a new schema that conforms to the properties defined in the\n * original schema without retaining any refinements or transformations that\n * were applied previously.\n *\n * @since 3.10.0\n */\nexport const encodedSchema = <A, I, R>(schema: Schema<A, I, R>): SchemaClass<I> => make(AST.encodedAST(schema.ast))\n\n/**\n * The `encodedBoundSchema` function is similar to `encodedSchema` but preserves\n * the refinements up to the first transformation point in the original schema.\n *\n * @since 3.10.0\n */\nexport const encodedBoundSchema = <A, I, R>(schema: Schema<A, I, R>): SchemaClass<I> =>\n  make(AST.encodedBoundAST(schema.ast))\n\n/**\n * The `typeSchema` function allows you to extract the `Type` portion of a\n * schema, creating a new schema that conforms to the properties defined in the\n * original schema without considering the initial encoding or transformation\n * processes.\n *\n * @since 3.10.0\n */\nexport const typeSchema = <A, I, R>(schema: Schema<A, I, R>): SchemaClass<A> => make(AST.typeAST(schema.ast))\n\n/* c8 ignore start */\nexport {\n  /**\n   * By default the option `exact` is set to `true`.\n   *\n   * @throws `ParseError`\n   * @category validation\n   * @since 3.10.0\n   */\n  asserts,\n  /**\n   * @category decoding\n   * @since 3.10.0\n   */\n  decodeOption,\n  /**\n   * @throws `ParseError`\n   * @category decoding\n   * @since 3.10.0\n   */\n  decodeSync,\n  /**\n   * @category decoding\n   * @since 3.10.0\n   */\n  decodeUnknownOption,\n  /**\n   * @throws `ParseError`\n   * @category decoding\n   * @since 3.10.0\n   */\n  decodeUnknownSync,\n  /**\n   * @category encoding\n   * @since 3.10.0\n   */\n  encodeOption,\n  /**\n   * @throws `ParseError`\n   * @category encoding\n   * @since 3.10.0\n   */\n  encodeSync,\n  /**\n   * @category encoding\n   * @since 3.10.0\n   */\n  encodeUnknownOption,\n  /**\n   * @throws `ParseError`\n   * @category encoding\n   * @since 3.10.0\n   */\n  encodeUnknownSync,\n  /**\n   * By default the option `exact` is set to `true`.\n   *\n   * @category validation\n   * @since 3.10.0\n   */\n  is,\n  /**\n   * @category validation\n   * @since 3.10.0\n   */\n  validateOption,\n  /**\n   * @throws `ParseError`\n   * @category validation\n   * @since 3.10.0\n   */\n  validateSync\n} from \"./ParseResult.js\"\n/* c8 ignore end */\n\n/**\n * @category encoding\n * @since 3.10.0\n */\nexport const encodeUnknown = <A, I, R>(\n  schema: Schema<A, I, R>,\n  options?: ParseOptions\n) => {\n  const encodeUnknown = ParseResult.encodeUnknown(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): Effect.Effect<I, ParseResult.ParseError, R> =>\n    ParseResult.mapError(encodeUnknown(u, overrideOptions), ParseResult.parseError)\n}\n\n/**\n * @category encoding\n * @since 3.10.0\n */\nexport const encodeUnknownEither = <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => {\n  const encodeUnknownEither = ParseResult.encodeUnknownEither(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): either_.Either<I, ParseResult.ParseError> =>\n    either_.mapLeft(encodeUnknownEither(u, overrideOptions), ParseResult.parseError)\n}\n\n/**\n * @category encoding\n * @since 3.10.0\n */\nexport const encodeUnknownPromise = <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => {\n  const parser = encodeUnknown(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): Promise<I> => Effect.runPromise(parser(u, overrideOptions))\n}\n\n/**\n * @category encoding\n * @since 3.10.0\n */\nexport const encode: <A, I, R>(\n  schema: Schema<A, I, R>,\n  options?: ParseOptions\n) => (a: A, overrideOptions?: ParseOptions) => Effect.Effect<I, ParseResult.ParseError, R> = encodeUnknown\n\n/**\n * @category encoding\n * @since 3.10.0\n */\nexport const encodeEither: <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => (a: A, overrideOptions?: ParseOptions) => either_.Either<I, ParseResult.ParseError> = encodeUnknownEither\n\n/**\n * @category encoding\n * @since 3.10.0\n */\nexport const encodePromise: <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => (a: A, overrideOptions?: ParseOptions) => Promise<I> = encodeUnknownPromise\n\n/**\n * @category decoding\n * @since 3.10.0\n */\nexport const decodeUnknown = <A, I, R>(\n  schema: Schema<A, I, R>,\n  options?: ParseOptions\n) => {\n  const decodeUnknown = ParseResult.decodeUnknown(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): Effect.Effect<A, ParseResult.ParseError, R> =>\n    ParseResult.mapError(decodeUnknown(u, overrideOptions), ParseResult.parseError)\n}\n\n/**\n * @category decoding\n * @since 3.10.0\n */\nexport const decodeUnknownEither = <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => {\n  const decodeUnknownEither = ParseResult.decodeUnknownEither(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): either_.Either<A, ParseResult.ParseError> =>\n    either_.mapLeft(decodeUnknownEither(u, overrideOptions), ParseResult.parseError)\n}\n\n/**\n * @category decoding\n * @since 3.10.0\n */\nexport const decodeUnknownPromise = <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => {\n  const parser = decodeUnknown(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): Promise<A> => Effect.runPromise(parser(u, overrideOptions))\n}\n\n/**\n * @category decoding\n * @since 3.10.0\n */\nexport const decode: <A, I, R>(\n  schema: Schema<A, I, R>,\n  options?: ParseOptions\n) => (i: I, overrideOptions?: ParseOptions) => Effect.Effect<A, ParseResult.ParseError, R> = decodeUnknown\n\n/**\n * @category decoding\n * @since 3.10.0\n */\nexport const decodeEither: <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => (i: I, overrideOptions?: ParseOptions) => either_.Either<A, ParseResult.ParseError> = decodeUnknownEither\n\n/**\n * @category decoding\n * @since 3.10.0\n */\nexport const decodePromise: <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => (i: I, overrideOptions?: ParseOptions) => Promise<A> = decodeUnknownPromise\n\n/**\n * @category validation\n * @since 3.10.0\n */\nexport const validate = <A, I, R>(\n  schema: Schema<A, I, R>,\n  options?: ParseOptions\n) => {\n  const validate = ParseResult.validate(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): Effect.Effect<A, ParseResult.ParseError, R> =>\n    ParseResult.mapError(validate(u, overrideOptions), ParseResult.parseError)\n}\n\n/**\n * @category validation\n * @since 3.10.0\n */\nexport const validateEither = <A, I, R>(\n  schema: Schema<A, I, R>,\n  options?: ParseOptions\n) => {\n  const validateEither = ParseResult.validateEither(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): either_.Either<A, ParseResult.ParseError> =>\n    either_.mapLeft(validateEither(u, overrideOptions), ParseResult.parseError)\n}\n\n/**\n * @category validation\n * @since 3.10.0\n */\nexport const validatePromise = <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => {\n  const parser = validate(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): Promise<A> => Effect.runPromise(parser(u, overrideOptions))\n}\n\n/**\n * Tests if a value is a `Schema`.\n *\n * @category guards\n * @since 3.10.0\n */\nexport const isSchema = (u: unknown): u is Schema.Any =>\n  Predicate.hasProperty(u, TypeId) && Predicate.isObject(u[TypeId])\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Literal<Literals extends array_.NonEmptyReadonlyArray<AST.LiteralValue>>\n  extends AnnotableClass<Literal<Literals>, Literals[number]>\n{\n  readonly literals: Readonly<Literals>\n}\n\nconst getDefaultLiteralAST = <Literals extends array_.NonEmptyReadonlyArray<AST.LiteralValue>>(\n  literals: Literals\n) =>\n  AST.isMembers(literals)\n    ? AST.Union.make(AST.mapMembers(literals, (literal) => new AST.Literal(literal)))\n    : new AST.Literal(literals[0])\n\nconst makeLiteralClass = <Literals extends array_.NonEmptyReadonlyArray<AST.LiteralValue>>(\n  literals: Literals,\n  ast: AST.AST = getDefaultLiteralAST(literals)\n): Literal<Literals> => (class LiteralClass extends make<Literals[number]>(ast) {\n  static override annotations(annotations: Annotations.Schema<Literals[number]>): Literal<Literals> {\n    return makeLiteralClass(this.literals, mergeSchemaAnnotations(this.ast, annotations))\n  }\n  static literals = [...literals] as Literals\n})\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport function Literal<Literals extends array_.NonEmptyReadonlyArray<AST.LiteralValue>>(\n  ...literals: Literals\n): Literal<Literals>\nexport function Literal(): Never\nexport function Literal<Literals extends ReadonlyArray<AST.LiteralValue>>(\n  ...literals: Literals\n): Schema<Literals[number]>\nexport function Literal<Literals extends ReadonlyArray<AST.LiteralValue>>(\n  ...literals: Literals\n): Schema<Literals[number]> | Never {\n  return array_.isNonEmptyReadonlyArray(literals) ? makeLiteralClass(literals) : Never\n}\n\n/**\n * Creates a new `Schema` from a literal schema.\n *\n * @example\n * ```ts\n * import * as Schema from \"effect/Schema\"\n * import { Either } from \"effect\"\n *\n * const schema = Schema.Literal(\"a\", \"b\", \"c\").pipe(Schema.pickLiteral(\"a\", \"b\"))\n *\n * assert.deepStrictEqual(Schema.decodeSync(schema)(\"a\"), \"a\")\n * assert.deepStrictEqual(Schema.decodeSync(schema)(\"b\"), \"b\")\n * assert.strictEqual(Either.isLeft(Schema.decodeUnknownEither(schema)(\"c\")), true)\n * ```\n *\n * @category constructors\n * @since 3.10.0\n */\nexport const pickLiteral =\n  <A extends AST.LiteralValue, L extends array_.NonEmptyReadonlyArray<A>>(...literals: L) =>\n  <I, R>(_schema: Schema<A, I, R>): Literal<[...L]> => Literal(...literals)\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport const UniqueSymbolFromSelf = <S extends symbol>(symbol: S): SchemaClass<S> => make(new AST.UniqueSymbol(symbol))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Enums<A extends EnumsDefinition> extends AnnotableClass<Enums<A>, A[keyof A]> {\n  readonly enums: A\n}\n\n/**\n * @since 3.10.0\n */\nexport type EnumsDefinition = { [x: string]: string | number }\n\nconst getDefaultEnumsAST = <A extends EnumsDefinition>(enums: A) =>\n  new AST.Enums(\n    Object.keys(enums).filter(\n      (key) => typeof enums[enums[key]] !== \"number\"\n    ).map((key) => [key, enums[key]])\n  )\n\nconst makeEnumsClass = <A extends EnumsDefinition>(\n  enums: A,\n  ast: AST.AST = getDefaultEnumsAST(enums)\n): Enums<A> => (class EnumsClass extends make<A[keyof A]>(ast) {\n  static override annotations(annotations: Annotations.Schema<A[keyof A]>) {\n    return makeEnumsClass(this.enums, mergeSchemaAnnotations(this.ast, annotations))\n  }\n\n  static enums = { ...enums }\n})\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport const Enums = <A extends EnumsDefinition>(enums: A): Enums<A> => makeEnumsClass(enums)\n\ntype AppendType<\n  Template extends string,\n  Next\n> = Next extends AST.LiteralValue ? `${Template}${Next}`\n  : Next extends Schema<infer A extends AST.LiteralValue, infer _I, infer _R> ? `${Template}${A}`\n  : never\n\ntype GetTemplateLiteralType<Params> = Params extends [...infer Init, infer Last] ?\n  AppendType<GetTemplateLiteralType<Init>, Last>\n  : ``\n\n/**\n * @category API interface\n * @since 3.10.0\n */\nexport interface TemplateLiteral<A> extends SchemaClass<A> {}\n\ntype TemplateLiteralParameter = Schema.AnyNoContext | AST.LiteralValue\n\n/**\n * @category template literal\n * @since 3.10.0\n */\nexport const TemplateLiteral = <Params extends array_.NonEmptyReadonlyArray<TemplateLiteralParameter>>(\n  ...[head, ...tail]: Params\n): TemplateLiteral<GetTemplateLiteralType<Params>> => {\n  const spans: Array<AST.TemplateLiteralSpan> = []\n  let h = \"\"\n  let ts = tail\n\n  if (isSchema(head)) {\n    if (AST.isLiteral(head.ast)) {\n      h = String(head.ast.literal)\n    } else {\n      ts = [head, ...ts]\n    }\n  } else {\n    h = String(head)\n  }\n\n  for (let i = 0; i < ts.length; i++) {\n    const item = ts[i]\n    if (isSchema(item)) {\n      if (i < ts.length - 1) {\n        const next = ts[i + 1]\n        if (isSchema(next)) {\n          if (AST.isLiteral(next.ast)) {\n            spans.push(new AST.TemplateLiteralSpan(item.ast, String(next.ast.literal)))\n            i++\n            continue\n          }\n        } else {\n          spans.push(new AST.TemplateLiteralSpan(item.ast, String(next)))\n          i++\n          continue\n        }\n      }\n      spans.push(new AST.TemplateLiteralSpan(item.ast, \"\"))\n    } else {\n      spans.push(new AST.TemplateLiteralSpan(new AST.Literal(item), \"\"))\n    }\n  }\n\n  if (array_.isNonEmptyArray(spans)) {\n    return make(new AST.TemplateLiteral(h, spans))\n  } else {\n    return make(new AST.TemplateLiteral(\"\", [new AST.TemplateLiteralSpan(new AST.Literal(h), \"\")]))\n  }\n}\n\ntype TemplateLiteralParserParameters = Schema.Any | AST.LiteralValue\n\ntype GetTemplateLiteralParserType<Params> = Params extends [infer Head, ...infer Tail] ? readonly [\n    Head extends Schema<infer A, infer _I, infer _R> ? A : Head,\n    ...GetTemplateLiteralParserType<Tail>\n  ]\n  : []\n\ntype AppendEncoded<\n  Template extends string,\n  Next\n> = Next extends AST.LiteralValue ? `${Template}${Next}`\n  : Next extends Schema<infer _A, infer I extends AST.LiteralValue, infer _R> ? `${Template}${I}`\n  : never\n\ntype GetTemplateLiteralParserEncoded<Params> = Params extends [...infer Init, infer Last] ?\n  AppendEncoded<GetTemplateLiteralParserEncoded<Init>, Last>\n  : ``\n\n/**\n * @category API interface\n * @since 3.10.0\n */\nexport interface TemplateLiteralParser<Params extends array_.NonEmptyReadonlyArray<TemplateLiteralParserParameters>>\n  extends\n    Schema<\n      GetTemplateLiteralParserType<Params>,\n      GetTemplateLiteralParserEncoded<Params>,\n      Schema.Context<Params[number]>\n    >\n{\n  readonly params: Params\n}\n\nfunction getTemplateLiteralParserCoercedElement(encoded: Schema.Any, schema: Schema.Any): Schema.Any | undefined {\n  const ast = encoded.ast\n  switch (ast._tag) {\n    case \"Literal\": {\n      const literal = ast.literal\n      if (!Predicate.isString(literal)) {\n        const s = String(literal)\n        return transform(Literal(s), schema, {\n          strict: true,\n          decode: () => literal,\n          encode: () => s\n        })\n      }\n      break\n    }\n    case \"NumberKeyword\":\n      return compose(NumberFromString, schema)\n    case \"Union\": {\n      const members: Array<Schema.Any> = []\n      let hasCoercions = false\n      for (const member of ast.types) {\n        const schema = make(member)\n        const encoded = encodedSchema(schema)\n        const coerced = getTemplateLiteralParserCoercedElement(encoded, schema)\n        if (coerced) {\n          hasCoercions = true\n        }\n        members.push(coerced ?? schema)\n      }\n      return hasCoercions ? compose(Union(...members), schema) : schema\n    }\n  }\n}\n\n/**\n * @category template literal\n * @since 3.10.0\n */\nexport const TemplateLiteralParser = <Params extends array_.NonEmptyReadonlyArray<TemplateLiteralParserParameters>>(\n  ...params: Params\n): TemplateLiteralParser<Params> => {\n  const encodedSchemas: Array<Schema.Any> = []\n  const elements: Array<Schema.Any> = []\n  const schemas: Array<Schema.Any> = []\n  let coerced = false\n  for (let i = 0; i < params.length; i++) {\n    const param = params[i]\n    const schema = isSchema(param) ? param : Literal(param)\n    schemas.push(schema)\n    const encoded = encodedSchema(schema)\n    encodedSchemas.push(encoded)\n    const element = getTemplateLiteralParserCoercedElement(encoded, schema)\n    if (element) {\n      elements.push(element)\n      coerced = true\n    } else {\n      elements.push(schema)\n    }\n  }\n  const from = TemplateLiteral(...encodedSchemas as any)\n  const re = AST.getTemplateLiteralCapturingRegExp(from.ast as AST.TemplateLiteral)\n  let to = Tuple(...elements)\n  if (coerced) {\n    to = to.annotations({ [AST.AutoTitleAnnotationId]: format(Tuple(...schemas)) })\n  }\n  return class TemplateLiteralParserClass extends transformOrFail(from, to, {\n    strict: false,\n    decode: (s, _, ast) => {\n      const match = re.exec(s)\n      return match\n        ? ParseResult.succeed(match.slice(1, params.length + 1))\n        : ParseResult.fail(new ParseResult.Type(ast, s, `${re.source}: no match for ${JSON.stringify(s)}`))\n    },\n    encode: (tuple) => ParseResult.succeed(tuple.join(\"\"))\n  }) {\n    static params = params.slice()\n  } as any\n}\n\nconst declareConstructor = <\n  const TypeParameters extends ReadonlyArray<Schema.Any>,\n  I,\n  A\n>(\n  typeParameters: TypeParameters,\n  options: {\n    readonly decode: (\n      ...typeParameters: {\n        readonly [K in keyof TypeParameters]: Schema<\n          Schema.Type<TypeParameters[K]>,\n          Schema.Encoded<TypeParameters[K]>,\n          never\n        >\n      }\n    ) => (\n      input: unknown,\n      options: ParseOptions,\n      ast: AST.Declaration\n    ) => Effect.Effect<A, ParseResult.ParseIssue, never>\n    readonly encode: (\n      ...typeParameters: {\n        readonly [K in keyof TypeParameters]: Schema<\n          Schema.Type<TypeParameters[K]>,\n          Schema.Encoded<TypeParameters[K]>,\n          never\n        >\n      }\n    ) => (\n      input: unknown,\n      options: ParseOptions,\n      ast: AST.Declaration\n    ) => Effect.Effect<I, ParseResult.ParseIssue, never>\n  },\n  annotations?: Annotations.Schema<A, TypeParameters>\n): SchemaClass<A, I, Schema.Context<TypeParameters[number]>> =>\n  make(\n    new AST.Declaration(\n      typeParameters.map((tp) => tp.ast),\n      (...typeParameters) => options.decode(...typeParameters.map(make) as any),\n      (...typeParameters) => options.encode(...typeParameters.map(make) as any),\n      toASTAnnotations(annotations)\n    )\n  )\n\nconst declarePrimitive = <A>(\n  is: (input: unknown) => input is A,\n  annotations?: Annotations.Schema<A>\n): SchemaClass<A> => {\n  const decodeUnknown = () => (input: unknown, _: ParseOptions, ast: AST.Declaration) =>\n    is(input) ? ParseResult.succeed(input) : ParseResult.fail(new ParseResult.Type(ast, input))\n  const encodeUnknown = decodeUnknown\n  return make(new AST.Declaration([], decodeUnknown, encodeUnknown, toASTAnnotations(annotations)))\n}\n\n/**\n * The constraint `R extends Schema.Context<P[number]>` enforces dependencies solely from `typeParameters`.\n * This ensures that when you call `Schema.to` or `Schema.from`, you receive a schema with a `never` context.\n *\n * @category constructors\n * @since 3.10.0\n */\nexport const declare: {\n  /**\n   * The constraint `R extends Schema.Context<P[number]>` enforces dependencies solely from `typeParameters`.\n   * This ensures that when you call `Schema.to` or `Schema.from`, you receive a schema with a `never` context.\n   *\n   * @category constructors\n   * @since 3.10.0\n   */\n  <A>(is: (input: unknown) => input is A, annotations?: Annotations.Schema<A>): SchemaClass<A>\n  /**\n   * The constraint `R extends Schema.Context<P[number]>` enforces dependencies solely from `typeParameters`.\n   * This ensures that when you call `Schema.to` or `Schema.from`, you receive a schema with a `never` context.\n   *\n   * @category constructors\n   * @since 3.10.0\n   */\n  <const P extends ReadonlyArray<Schema.All>, I, A>(\n    typeParameters: P,\n    options: {\n      readonly decode: (\n        ...typeParameters: { readonly [K in keyof P]: Schema<Schema.Type<P[K]>, Schema.Encoded<P[K]>, never> }\n      ) => (\n        input: unknown,\n        options: ParseOptions,\n        ast: AST.Declaration\n      ) => Effect.Effect<A, ParseResult.ParseIssue, never>\n      readonly encode: (\n        ...typeParameters: { readonly [K in keyof P]: Schema<Schema.Type<P[K]>, Schema.Encoded<P[K]>, never> }\n      ) => (\n        input: unknown,\n        options: ParseOptions,\n        ast: AST.Declaration\n      ) => Effect.Effect<I, ParseResult.ParseIssue, never>\n    },\n    annotations?: Annotations.Schema<A, { readonly [K in keyof P]: Schema.Type<P[K]> }>\n  ): SchemaClass<A, I, Schema.Context<P[number]>>\n} = function() {\n  if (Array.isArray(arguments[0])) {\n    const typeParameters = arguments[0]\n    const options = arguments[1]\n    const annotations = arguments[2]\n    return declareConstructor(typeParameters, options, annotations)\n  }\n  const is = arguments[0]\n  const annotations = arguments[1]\n  return declarePrimitive(is, annotations)\n} as any\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const BrandSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/Brand\")\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport const fromBrand = <C extends Brand<string | symbol>, A extends Brand.Unbranded<C>>(\n  constructor: Brand.Constructor<C>,\n  annotations?: Annotations.Filter<C, A>\n) =>\n<I, R>(self: Schema<A, I, R>): BrandSchema<A & C, I, R> =>\n  makeBrandClass<Schema<A & C, I, R>, string | symbol>(\n    new AST.Refinement(\n      self.ast,\n      function predicate(a: A, _: ParseOptions, ast: AST.AST): option_.Option<ParseResult.ParseIssue> {\n        const either = constructor.either(a)\n        return either_.isLeft(either) ?\n          option_.some(new ParseResult.Type(ast, a, either.left.map((v) => v.message).join(\", \"))) :\n          option_.none()\n      },\n      toASTAnnotations({\n        schemaId: BrandSchemaId,\n        [BrandSchemaId]: { constructor },\n        ...annotations\n      })\n    )\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const InstanceOfSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/InstanceOf\")\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface instanceOf<A> extends AnnotableClass<instanceOf<A>, A> {}\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport const instanceOf = <A extends abstract new(...args: any) => any>(\n  constructor: A,\n  annotations?: Annotations.Schema<InstanceType<A>>\n): instanceOf<InstanceType<A>> =>\n  declare(\n    (u): u is InstanceType<A> => u instanceof constructor,\n    {\n      title: constructor.name,\n      description: `an instance of ${constructor.name}`,\n      pretty: (): pretty_.Pretty<InstanceType<A>> => String,\n      schemaId: InstanceOfSchemaId,\n      [InstanceOfSchemaId]: { constructor },\n      ...annotations\n    }\n  )\n\n/**\n * @category primitives\n * @since 3.10.0\n */\nexport class Undefined extends make<undefined>(AST.undefinedKeyword) {}\n\n/**\n * @category primitives\n * @since 3.10.0\n */\nexport class Void extends make<void>(AST.voidKeyword) {}\n\n/**\n * @category primitives\n * @since 3.10.0\n */\nexport class Null extends make<null>(AST.null) {}\n\n/**\n * @category primitives\n * @since 3.10.0\n */\nexport class Never extends make<never>(AST.neverKeyword) {}\n\n/**\n * @category primitives\n * @since 3.10.0\n */\nexport class Unknown extends make<unknown>(AST.unknownKeyword) {}\n\n/**\n * @category primitives\n * @since 3.10.0\n */\nexport class Any extends make<any>(AST.anyKeyword) {}\n\n/**\n * @category primitives\n * @since 3.10.0\n */\nexport class BigIntFromSelf extends make<bigint>(AST.bigIntKeyword) {}\n\n/**\n * @category primitives\n * @since 3.10.0\n */\nexport class SymbolFromSelf extends make<symbol>(AST.symbolKeyword) {}\n\n/** @ignore */\nclass String$ extends make<string>(AST.stringKeyword) {}\n\n/** @ignore */\nclass Number$ extends make<number>(AST.numberKeyword) {}\n\n/** @ignore */\nclass Boolean$ extends make<boolean>(AST.booleanKeyword) {}\n\n/** @ignore */\nclass Object$ extends make<object>(AST.objectKeyword) {}\n\nexport {\n  /**\n   * @category primitives\n   * @since 3.10.0\n   */\n  Boolean$ as Boolean,\n  /**\n   * @category primitives\n   * @since 3.10.0\n   */\n  Number$ as Number,\n  /**\n   * @category primitives\n   * @since 3.10.0\n   */\n  Object$ as Object,\n  /**\n   * @category primitives\n   * @since 3.10.0\n   */\n  String$ as String\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Union<Members extends ReadonlyArray<Schema.All>> extends\n  AnnotableClass<\n    Union<Members>,\n    Schema.Type<Members[number]>,\n    Schema.Encoded<Members[number]>,\n    Schema.Context<Members[number]>\n  >\n{\n  readonly members: Readonly<Members>\n  annotations(annotations: Annotations.Schema<Schema.Type<Members[number]>>): Union<Members>\n}\n\nconst getDefaultUnionAST = <Members extends AST.Members<Schema.All>>(members: Members): AST.AST =>\n  AST.Union.make(members.map((m) => m.ast))\n\nconst makeUnionClass = <Members extends AST.Members<Schema.All>>(\n  members: Members,\n  ast: AST.AST = getDefaultUnionAST(members)\n): Union<\n  Members\n> => (class UnionClass\n  extends make<Schema.Type<Members[number]>, Schema.Encoded<Members[number]>, Schema.Context<Members[number]>>(ast)\n{\n  static override annotations(annotations: Annotations.Schema<Schema.Type<Members[number]>>): Union<Members> {\n    return makeUnionClass(this.members, mergeSchemaAnnotations(this.ast, annotations))\n  }\n\n  static members = [...members]\n})\n\n/**\n * @category combinators\n * @since 3.10.0\n */\nexport function Union<Members extends AST.Members<Schema.All>>(...members: Members): Union<Members>\nexport function Union<Member extends Schema.All>(member: Member): Member\nexport function Union(): typeof Never\nexport function Union<Members extends ReadonlyArray<Schema.All>>(\n  ...members: Members\n): Schema<Schema.Type<Members[number]>, Schema.Encoded<Members[number]>, Schema.Context<Members[number]>>\nexport function Union<Members extends ReadonlyArray<Schema.All>>(\n  ...members: Members\n) {\n  return AST.isMembers(members)\n    ? makeUnionClass(members)\n    : array_.isNonEmptyReadonlyArray(members)\n    ? members[0]\n    : Never\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface NullOr<S extends Schema.All> extends Union<[S, typeof Null]> {\n  annotations(annotations: Annotations.Schema<Schema.Type<S> | null>): NullOr<S>\n}\n\n/**\n * @category combinators\n * @since 3.10.0\n */\nexport const NullOr = <S extends Schema.All>(self: S): NullOr<S> => Union(self, Null)\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface UndefinedOr<S extends Schema.All> extends Union<[S, typeof Undefined]> {\n  annotations(annotations: Annotations.Schema<Schema.Type<S> | undefined>): UndefinedOr<S>\n}\n\n/**\n * @category combinators\n * @since 3.10.0\n */\nexport const UndefinedOr = <S extends Schema.All>(self: S): UndefinedOr<S> => Union(self, Undefined)\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface NullishOr<S extends Schema.All> extends Union<[S, typeof Null, typeof Undefined]> {\n  annotations(annotations: Annotations.Schema<Schema.Type<S> | null | undefined>): NullishOr<S>\n}\n\n/**\n * @category combinators\n * @since 3.10.0\n */\nexport const NullishOr = <S extends Schema.All>(self: S): NullishOr<S> => Union(self, Null, Undefined)\n\n/**\n * @category combinators\n * @since 3.10.0\n */\nexport const keyof = <A, I, R>(self: Schema<A, I, R>): SchemaClass<keyof A> => make<keyof A>(AST.keyof(self.ast))\n\n/**\n * @since 3.10.0\n */\nexport declare namespace Element {\n  /**\n   * @since 3.10.0\n   */\n  export interface Annotations<A> extends Annotations.Doc<A> {\n    readonly missingMessage?: AST.MissingMessageAnnotation\n  }\n\n  /**\n   * @since 3.10.0\n   */\n  export type Token = \"\" | \"?\"\n}\n\n/**\n * @category API interface\n * @since 3.10.0\n */\nexport interface Element<S extends Schema.Any, Token extends Element.Token>\n  extends Schema.Variance<Schema.Type<S>, Schema.Encoded<S>, Schema.Context<S>>\n{\n  readonly _Token: Token\n  readonly ast: AST.OptionalType\n  readonly from: S\n  annotations(annotations: Element.Annotations<Schema.Type<S>>): Element<S, Token>\n}\n\n/**\n * @since 3.10.0\n */\nexport const element = <S extends Schema.Any>(self: S): Element<S, \"\"> =>\n  new ElementImpl(new AST.OptionalType(self.ast, false), self)\n\n/**\n * @since 3.10.0\n */\nexport const optionalElement = <S extends Schema.Any>(self: S): Element<S, \"?\"> =>\n  new ElementImpl(new AST.OptionalType(self.ast, true), self)\n\nclass ElementImpl<S extends Schema.Any, Token extends Element.Token> implements Element<S, Token> {\n  readonly [TypeId]!: Schema.Variance<Schema.Type<S>, Schema.Encoded<S>, Schema.Context<S>>[TypeId]\n  readonly _Token!: Token\n  constructor(\n    readonly ast: AST.OptionalType,\n    readonly from: S\n  ) {}\n  annotations(\n    annotations: Annotations.Schema<Schema.Type<S>>\n  ): ElementImpl<S, Token> {\n    return new ElementImpl(\n      new AST.OptionalType(\n        this.ast.type,\n        this.ast.isOptional,\n        { ...this.ast.annotations, ...toASTAnnotations(annotations) }\n      ),\n      this.from\n    )\n  }\n  toString() {\n    return `${this.ast.type}${this.ast.isOptional ? \"?\" : \"\"}`\n  }\n}\n\n/**\n * @since 3.10.0\n */\nexport declare namespace TupleType {\n  type ElementsType<\n    Elements,\n    Out extends ReadonlyArray<any> = readonly []\n  > = Elements extends readonly [infer Head, ...infer Tail] ?\n    Head extends Element<infer T, \"?\"> ? ElementsType<Tail, readonly [...Out, Schema.Type<T>?]>\n    : ElementsType<Tail, readonly [...Out, Schema.Type<Head>]>\n    : Out\n\n  type ElementsEncoded<\n    Elements,\n    Out extends ReadonlyArray<any> = readonly []\n  > = Elements extends readonly [infer Head, ...infer Tail] ?\n    Head extends Element<infer T, \"?\"> ? ElementsEncoded<Tail, readonly [...Out, Schema.Encoded<T>?]>\n    : ElementsEncoded<Tail, readonly [...Out, Schema.Encoded<Head>]>\n    : Out\n\n  /**\n   * @since 3.10.0\n   */\n  export type Elements = ReadonlyArray<Schema.Any | Element<Schema.Any, Element.Token>>\n\n  /**\n   * @since 3.10.0\n   */\n  export type Rest = ReadonlyArray<Schema.Any | Element<Schema.Any, \"\">>\n\n  /**\n   * @since 3.10.0\n   */\n  export type Type<Elements extends TupleType.Elements, Rest extends TupleType.Rest> = Rest extends\n    [infer Head, ...infer Tail] ? Readonly<[\n      ...ElementsType<Elements>,\n      ...ReadonlyArray<Schema.Type<Head>>,\n      ...{ readonly [K in keyof Tail]: Schema.Type<Tail[K]> }\n    ]> :\n    ElementsType<Elements>\n\n  /**\n   * @since 3.10.0\n   */\n  export type Encoded<Elements extends TupleType.Elements, Rest extends TupleType.Rest> = Rest extends\n    [infer Head, ...infer Tail] ? Readonly<[\n      ...ElementsEncoded<Elements>,\n      ...ReadonlyArray<Schema.Encoded<Head>>,\n      ...{ readonly [K in keyof Tail]: Schema.Encoded<Tail[K]> }\n    ]> :\n    ElementsEncoded<Elements>\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface TupleType<Elements extends TupleType.Elements, Rest extends TupleType.Rest> extends\n  AnnotableClass<\n    TupleType<Elements, Rest>,\n    TupleType.Type<Elements, Rest>,\n    TupleType.Encoded<Elements, Rest>,\n    Schema.Context<Elements[number]> | Schema.Context<Rest[number]>\n  >\n{\n  readonly elements: Readonly<Elements>\n  readonly rest: Readonly<Rest>\n}\n\nconst getDefaultTupleTypeAST = <Elements extends TupleType.Elements, Rest extends TupleType.Rest>(\n  elements: Elements,\n  rest: Rest\n) =>\n  new AST.TupleType(\n    elements.map((el) => isSchema(el) ? new AST.OptionalType(el.ast, false) : el.ast),\n    rest.map((el) => isSchema(el) ? new AST.Type(el.ast) : el.ast),\n    true\n  )\n\nconst makeTupleTypeClass = <Elements extends TupleType.Elements, Rest extends TupleType.Rest>(\n  elements: Elements,\n  rest: Rest,\n  ast: AST.AST = getDefaultTupleTypeAST(elements, rest)\n) => (class TupleTypeClass extends make<\n  TupleType.Type<Elements, Rest>,\n  TupleType.Encoded<Elements, Rest>,\n  Schema.Context<Elements[number]> | Schema.Context<Rest[number]>\n>(ast) {\n  static override annotations(\n    annotations: Annotations.Schema<TupleType.Type<Elements, Rest>>\n  ): TupleType<Elements, Rest> {\n    return makeTupleTypeClass(this.elements, this.rest, mergeSchemaAnnotations(this.ast, annotations))\n  }\n\n  static elements = [...elements] as any as Elements\n\n  static rest = [...rest] as any as Rest\n})\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Tuple<Elements extends TupleType.Elements> extends TupleType<Elements, []> {\n  annotations(annotations: Annotations.Schema<TupleType.Type<Elements, []>>): Tuple<Elements>\n}\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport function Tuple<\n  const Elements extends TupleType.Elements,\n  Rest extends array_.NonEmptyReadonlyArray<TupleType.Rest[number]>\n>(elements: Elements, ...rest: Rest): TupleType<Elements, Rest>\nexport function Tuple<Elements extends TupleType.Elements>(...elements: Elements): Tuple<Elements>\nexport function Tuple(...args: ReadonlyArray<any>): any {\n  return Array.isArray(args[0])\n    ? makeTupleTypeClass(args[0], args.slice(1))\n    : makeTupleTypeClass(args, [])\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Array$<Value extends Schema.Any> extends TupleType<[], [Value]> {\n  readonly value: Value\n  annotations(annotations: Annotations.Schema<TupleType.Type<[], [Value]>>): Array$<Value>\n}\n\nconst makeArrayClass = <Value extends Schema.Any>(\n  value: Value,\n  ast?: AST.AST\n): Array$<Value> => (class ArrayClass extends makeTupleTypeClass<[], [Value]>([], [value], ast) {\n  static override annotations(annotations: Annotations.Schema<TupleType.Type<[], [Value]>>) {\n    return makeArrayClass(this.value, mergeSchemaAnnotations(this.ast, annotations))\n  }\n\n  static value = value\n})\n\nconst Array$ = <Value extends Schema.Any>(value: Value): Array$<Value> => makeArrayClass(value)\n\nexport {\n  /**\n   * @category constructors\n   * @since 3.10.0\n   */\n  Array$ as Array\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface NonEmptyArray<Value extends Schema.Any> extends TupleType<[Value], [Value]> {\n  readonly value: Value\n  annotations(annotations: Annotations.Schema<TupleType.Type<[Value], [Value]>>): NonEmptyArray<Value>\n}\n\nconst makeNonEmptyArrayClass = <Value extends Schema.Any>(\n  value: Value,\n  ast?: AST.AST\n): NonEmptyArray<\n  Value\n> => (class NonEmptyArrayClass extends makeTupleTypeClass<[Value], [Value]>([value], [value], ast) {\n  static override annotations(annotations: Annotations.Schema<TupleType.Type<[Value], [Value]>>) {\n    return makeNonEmptyArrayClass(this.value, mergeSchemaAnnotations(this.ast, annotations))\n  }\n\n  static value = value\n})\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport const NonEmptyArray = <Value extends Schema.Any>(value: Value): NonEmptyArray<Value> =>\n  makeNonEmptyArrayClass(value)\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface ArrayEnsure<Value extends Schema.Any> extends\n  AnnotableClass<\n    ArrayEnsure<Value>,\n    ReadonlyArray<Schema.Type<Value>>,\n    Schema.Encoded<Value> | ReadonlyArray<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport const ArrayEnsure = <Value extends Schema.Any>(value: Value): ArrayEnsure<Value> => {\n  const value_ = asSchema(value)\n  return class ArrayEnsureClass extends transform(Union(value_, Array$(value_)), Array$(typeSchema(value_)), {\n    strict: true,\n    decode: array_.ensure,\n    encode: (arr) => arr.length === 1 ? arr[0] : arr\n  }) {}\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface NonEmptyArrayEnsure<Value extends Schema.Any> extends\n  AnnotableClass<\n    NonEmptyArrayEnsure<Value>,\n    array_.NonEmptyReadonlyArray<Schema.Type<Value>>,\n    Schema.Encoded<Value> | array_.NonEmptyReadonlyArray<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport const NonEmptyArrayEnsure = <Value extends Schema.Any>(value: Value): NonEmptyArrayEnsure<Value> => {\n  const value_ = asSchema(value)\n  return class NonEmptyArrayEnsureClass\n    extends transform(Union(value_, NonEmptyArray(value_)), NonEmptyArray(typeSchema(value_)), {\n      strict: true,\n      decode: array_.ensure as any,\n      encode: (arr) => arr.length === 1 ? arr[0] : arr\n    })\n  {}\n}\n\n/**\n * @since 3.10.0\n */\nexport declare namespace PropertySignature {\n  /**\n   * @since 3.10.0\n   */\n  export type Token = \"?:\" | \":\"\n\n  /**\n   * @since 3.10.0\n   */\n  export type Any<Key extends PropertyKey = PropertyKey> = PropertySignature<\n    Token,\n    any,\n    Key,\n    Token,\n    any,\n    boolean,\n    unknown\n  >\n\n  /**\n   * @since 3.10.0\n   */\n  export type All<Key extends PropertyKey = PropertyKey> =\n    | Any<Key>\n    | PropertySignature<Token, never, Key, Token, any, boolean, unknown>\n    | PropertySignature<Token, any, Key, Token, never, boolean, unknown>\n    | PropertySignature<Token, never, Key, Token, never, boolean, unknown>\n\n  /**\n   * @since 3.10.0\n   */\n  export type AST =\n    | PropertySignatureDeclaration\n    | PropertySignatureTransformation\n\n  /**\n   * @since 3.10.0\n   */\n  export interface Annotations<A> extends Annotations.Doc<A> {\n    readonly missingMessage?: AST.MissingMessageAnnotation\n  }\n}\n\nconst formatPropertySignatureToken = (isOptional: boolean): string => isOptional ? \"\\\"?:\\\"\" : \"\\\":\\\"\"\n\n/**\n * @category PropertySignature\n * @since 3.10.0\n */\nexport class PropertySignatureDeclaration extends AST.OptionalType {\n  /**\n   * @since 3.10.0\n   */\n  readonly _tag = \"PropertySignatureDeclaration\"\n  constructor(\n    type: AST.AST,\n    isOptional: boolean,\n    readonly isReadonly: boolean,\n    annotations: AST.Annotations,\n    readonly defaultValue: (() => unknown) | undefined\n  ) {\n    super(type, isOptional, annotations)\n  }\n  /**\n   * @since 3.10.0\n   */\n  toString() {\n    const token = formatPropertySignatureToken(this.isOptional)\n    const type = String(this.type)\n    return `PropertySignature<${token}, ${type}, never, ${token}, ${type}>`\n  }\n}\n\n/**\n * @category PropertySignature\n * @since 3.10.0\n */\nexport class FromPropertySignature extends AST.OptionalType {\n  constructor(\n    type: AST.AST,\n    isOptional: boolean,\n    readonly isReadonly: boolean,\n    annotations: AST.Annotations,\n    readonly fromKey?: PropertyKey | undefined\n  ) {\n    super(type, isOptional, annotations)\n  }\n}\n\n/**\n * @category PropertySignature\n * @since 3.10.0\n */\nexport class ToPropertySignature extends AST.OptionalType {\n  constructor(\n    type: AST.AST,\n    isOptional: boolean,\n    readonly isReadonly: boolean,\n    annotations: AST.Annotations,\n    readonly defaultValue: (() => unknown) | undefined\n  ) {\n    super(type, isOptional, annotations)\n  }\n}\n\nconst formatPropertyKey = (p: PropertyKey | undefined): string => {\n  if (p === undefined) {\n    return \"never\"\n  }\n  if (Predicate.isString(p)) {\n    return JSON.stringify(p)\n  }\n  return String(p)\n}\n\n/**\n * @category PropertySignature\n * @since 3.10.0\n */\nexport class PropertySignatureTransformation {\n  /**\n   * @since 3.10.0\n   */\n  readonly _tag = \"PropertySignatureTransformation\"\n  constructor(\n    readonly from: FromPropertySignature,\n    readonly to: ToPropertySignature,\n    readonly decode: AST.PropertySignatureTransformation[\"decode\"],\n    readonly encode: AST.PropertySignatureTransformation[\"encode\"]\n  ) {}\n  /**\n   * @since 3.10.0\n   */\n  toString() {\n    return `PropertySignature<${formatPropertySignatureToken(this.to.isOptional)}, ${this.to.type}, ${\n      formatPropertyKey(this.from.fromKey)\n    }, ${formatPropertySignatureToken(this.from.isOptional)}, ${this.from.type}>`\n  }\n}\n\nconst mergeSignatureAnnotations = (\n  ast: PropertySignature.AST,\n  annotations: AST.Annotations\n): PropertySignature.AST => {\n  switch (ast._tag) {\n    case \"PropertySignatureDeclaration\": {\n      return new PropertySignatureDeclaration(\n        ast.type,\n        ast.isOptional,\n        ast.isReadonly,\n        { ...ast.annotations, ...annotations },\n        ast.defaultValue\n      )\n    }\n    case \"PropertySignatureTransformation\": {\n      return new PropertySignatureTransformation(\n        new FromPropertySignature(\n          ast.from.type,\n          ast.from.isOptional,\n          ast.from.isReadonly,\n          ast.from.annotations\n        ),\n        new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, {\n          ...ast.to.annotations,\n          ...annotations\n        }, ast.to.defaultValue),\n        ast.decode,\n        ast.encode\n      )\n    }\n  }\n}\n\n/**\n * @since 3.10.0\n * @category symbol\n */\nexport const PropertySignatureTypeId: unique symbol = Symbol.for(\"effect/PropertySignature\")\n\n/**\n * @since 3.10.0\n * @category symbol\n */\nexport type PropertySignatureTypeId = typeof PropertySignatureTypeId\n\n/**\n * @since 3.10.0\n * @category guards\n */\nexport const isPropertySignature = (u: unknown): u is PropertySignature.All =>\n  Predicate.hasProperty(u, PropertySignatureTypeId)\n\n/**\n * @category PropertySignature\n * @since 3.10.0\n */\nexport interface PropertySignature<\n  TypeToken extends PropertySignature.Token,\n  Type,\n  Key extends PropertyKey,\n  EncodedToken extends PropertySignature.Token,\n  Encoded,\n  HasDefault extends boolean = false,\n  R = never\n> extends Schema.Variance<Type, Encoded, R>, Pipeable {\n  readonly [PropertySignatureTypeId]: null\n  readonly _TypeToken: TypeToken\n  readonly _EncodedToken: EncodedToken\n  readonly _HasDefault: HasDefault\n  readonly _Key: Key\n  readonly ast: PropertySignature.AST\n\n  annotations(\n    annotations: PropertySignature.Annotations<Type>\n  ): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>\n}\n\nclass PropertySignatureImpl<\n  TypeToken extends PropertySignature.Token,\n  Type,\n  Key extends PropertyKey,\n  EncodedToken extends PropertySignature.Token,\n  Encoded,\n  HasDefault extends boolean = false,\n  R = never\n> implements PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R> {\n  readonly [TypeId]!: Schema.Variance<Type, Encoded, R>[TypeId]\n  readonly [PropertySignatureTypeId] = null\n  readonly _TypeToken!: TypeToken\n  readonly _Key!: Key\n  readonly _EncodedToken!: EncodedToken\n  readonly _HasDefault!: HasDefault\n\n  constructor(\n    readonly ast: PropertySignature.AST\n  ) {}\n\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n\n  annotations(\n    annotations: PropertySignature.Annotations<Type>\n  ): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R> {\n    return new PropertySignatureImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations)))\n  }\n\n  toString() {\n    return String(this.ast)\n  }\n}\n\n/**\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const makePropertySignature = <\n  TypeToken extends PropertySignature.Token,\n  Type,\n  Key extends PropertyKey,\n  EncodedToken extends PropertySignature.Token,\n  Encoded,\n  HasDefault extends boolean = false,\n  R = never\n>(ast: PropertySignature.AST) =>\n  new PropertySignatureImpl<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>(ast)\n\nclass PropertySignatureWithFromImpl<\n  From extends Schema.All,\n  TypeToken extends PropertySignature.Token,\n  Type,\n  Key extends PropertyKey,\n  EncodedToken extends PropertySignature.Token,\n  Encoded,\n  HasDefault extends boolean = false,\n  R = never\n> extends PropertySignatureImpl<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R> {\n  constructor(ast: PropertySignature.AST, readonly from: From) {\n    super(ast)\n  }\n  annotations(\n    annotations: PropertySignature.Annotations<Type>\n  ): PropertySignatureWithFromImpl<From, TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R> {\n    return new PropertySignatureWithFromImpl(\n      mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations)),\n      this.from\n    )\n  }\n}\n\n/**\n * @category API interface\n * @since 1.0.0\n */\nexport interface propertySignature<S extends Schema.All>\n  extends PropertySignature<\":\", Schema.Type<S>, never, \":\", Schema.Encoded<S>, false, Schema.Context<S>>\n{\n  readonly from: S\n  annotations(annotations: PropertySignature.Annotations<Schema.Type<S>>): propertySignature<S>\n}\n\n/**\n * Lifts a `Schema` into a `PropertySignature`.\n *\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const propertySignature = <S extends Schema.All>(\n  self: S\n): propertySignature<S> =>\n  new PropertySignatureWithFromImpl(\n    new PropertySignatureDeclaration(self.ast, false, true, {}, undefined),\n    self\n  )\n\n/**\n * Enhances a property signature with a default constructor value.\n *\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const withConstructorDefault: {\n  /**\n   * Enhances a property signature with a default constructor value.\n   *\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <Type>(defaultValue: () => Types.NoInfer<Type>): <\n    TypeToken extends PropertySignature.Token,\n    Key extends PropertyKey,\n    EncodedToken extends PropertySignature.Token,\n    Encoded,\n    R\n  >(\n    self: PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, boolean, R>\n  ) => PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, true, R>\n  /**\n   * Enhances a property signature with a default constructor value.\n   *\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <\n    TypeToken extends PropertySignature.Token,\n    Type,\n    Key extends PropertyKey,\n    EncodedToken extends PropertySignature.Token,\n    Encoded,\n    R\n  >(\n    self: PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, boolean, R>,\n    defaultValue: () => Types.NoInfer<Type>\n  ): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, true, R>\n} = dual(2, <\n  TypeToken extends PropertySignature.Token,\n  Type,\n  Key extends PropertyKey,\n  EncodedToken extends PropertySignature.Token,\n  Encoded,\n  R\n>(\n  self: PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, boolean, R>,\n  defaultValue: () => Types.NoInfer<Type>\n): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, true, R> => {\n  const ast = self.ast\n  switch (ast._tag) {\n    case \"PropertySignatureDeclaration\":\n      return makePropertySignature(\n        new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, ast.annotations, defaultValue)\n      )\n    case \"PropertySignatureTransformation\":\n      return makePropertySignature(\n        new PropertySignatureTransformation(\n          ast.from,\n          new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, ast.to.annotations, defaultValue),\n          ast.decode,\n          ast.encode\n        )\n      )\n  }\n})\n\nconst applyDefaultValue = <A>(o: option_.Option<A>, defaultValue: () => A) =>\n  option_.match(o, {\n    onNone: () => option_.some(defaultValue()),\n    onSome: (value) => option_.some(value === undefined ? defaultValue() : value)\n  })\n\nconst pruneUndefined = (ast: AST.AST): AST.AST | undefined =>\n  AST.pruneUndefined(ast, pruneUndefined, (ast) => {\n    const pruned = pruneUndefined(ast.to)\n    if (pruned) {\n      return new AST.Transformation(ast.from, pruned, ast.transformation)\n    }\n  })\n\n/**\n * Enhances a property signature with a default decoding value.\n *\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const withDecodingDefault: {\n  /**\n   * Enhances a property signature with a default decoding value.\n   *\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <Type>(defaultValue: () => Types.NoInfer<Exclude<Type, undefined>>): <\n    Key extends PropertyKey,\n    Encoded,\n    R\n  >(\n    self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, false, R>\n  ) => PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, false, R>\n  /**\n   * Enhances a property signature with a default decoding value.\n   *\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <\n    Type,\n    Key extends PropertyKey,\n    Encoded,\n    R\n  >(\n    self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, false, R>,\n    defaultValue: () => Types.NoInfer<Exclude<Type, undefined>>\n  ): PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, false, R>\n} = dual(2, <\n  Type,\n  Key extends PropertyKey,\n  Encoded,\n  R\n>(\n  self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, false, R>,\n  defaultValue: () => Types.NoInfer<Exclude<Type, undefined>>\n): PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, false, R> => {\n  const ast = self.ast\n  switch (ast._tag) {\n    case \"PropertySignatureDeclaration\": {\n      const to = AST.typeAST(ast.type)\n      return makePropertySignature(\n        new PropertySignatureTransformation(\n          new FromPropertySignature(ast.type, ast.isOptional, ast.isReadonly, ast.annotations),\n          new ToPropertySignature(pruneUndefined(to) ?? to, false, true, {}, ast.defaultValue),\n          (o) => applyDefaultValue(o, defaultValue),\n          identity\n        )\n      )\n    }\n    case \"PropertySignatureTransformation\": {\n      const to = ast.to.type\n      return makePropertySignature(\n        new PropertySignatureTransformation(\n          ast.from,\n          new ToPropertySignature(\n            pruneUndefined(to) ?? to,\n            false,\n            ast.to.isReadonly,\n            ast.to.annotations,\n            ast.to.defaultValue\n          ),\n          (o) => applyDefaultValue(ast.decode(o), defaultValue),\n          ast.encode\n        )\n      )\n    }\n  }\n})\n\n/**\n * Enhances a property signature with a default decoding value and a default constructor value.\n *\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const withDefaults: {\n  /**\n   * Enhances a property signature with a default decoding value and a default constructor value.\n   *\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <Type>(\n    defaults: {\n      constructor: () => Types.NoInfer<Exclude<Type, undefined>>\n      decoding: () => Types.NoInfer<Exclude<Type, undefined>>\n    }\n  ): <\n    Key extends PropertyKey,\n    Encoded,\n    R\n  >(\n    self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, boolean, R>\n  ) => PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, true, R>\n  /**\n   * Enhances a property signature with a default decoding value and a default constructor value.\n   *\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <\n    Type,\n    Key extends PropertyKey,\n    Encoded,\n    R\n  >(\n    self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, boolean, R>,\n    defaults: {\n      constructor: () => Types.NoInfer<Exclude<Type, undefined>>\n      decoding: () => Types.NoInfer<Exclude<Type, undefined>>\n    }\n  ): PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, true, R>\n} = dual(2, <\n  Type,\n  Key extends PropertyKey,\n  Encoded,\n  R\n>(\n  self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, false, R>,\n  defaults: {\n    constructor: () => Types.NoInfer<Exclude<Type, undefined>>\n    decoding: () => Types.NoInfer<Exclude<Type, undefined>>\n  }\n): PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, true, R> =>\n  self.pipe(withDecodingDefault(defaults.decoding), withConstructorDefault(defaults.constructor)))\n\n/**\n * Enhances a property signature by specifying a different key for it in the Encoded type.\n *\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const fromKey: {\n  /**\n   * Enhances a property signature by specifying a different key for it in the Encoded type.\n   *\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <Key extends PropertyKey>(key: Key): <\n    TypeToken extends PropertySignature.Token,\n    Type,\n    EncodedToken extends PropertySignature.Token,\n    Encoded,\n    HasDefault extends boolean,\n    R\n  >(\n    self: PropertySignature<TypeToken, Type, PropertyKey, EncodedToken, Encoded, HasDefault, R>\n  ) => PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>\n  /**\n   * Enhances a property signature by specifying a different key for it in the Encoded type.\n   *\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <\n    Type,\n    TypeToken extends PropertySignature.Token,\n    Encoded,\n    EncodedToken extends PropertySignature.Token,\n    HasDefault extends boolean,\n    R,\n    Key extends PropertyKey\n  >(\n    self: PropertySignature<TypeToken, Type, PropertyKey, EncodedToken, Encoded, HasDefault, R>,\n    key: Key\n  ): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>\n} = dual(2, <\n  Type,\n  TypeToken extends PropertySignature.Token,\n  Encoded,\n  EncodedToken extends PropertySignature.Token,\n  HasDefault extends boolean,\n  R,\n  Key extends PropertyKey\n>(\n  self: PropertySignature<TypeToken, Type, PropertyKey, EncodedToken, Encoded, HasDefault, R>,\n  key: Key\n): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R> => {\n  const ast = self.ast\n  switch (ast._tag) {\n    case \"PropertySignatureDeclaration\": {\n      return makePropertySignature(\n        new PropertySignatureTransformation(\n          new FromPropertySignature(\n            ast.type,\n            ast.isOptional,\n            ast.isReadonly,\n            ast.annotations,\n            key\n          ),\n          new ToPropertySignature(AST.typeAST(ast.type), ast.isOptional, ast.isReadonly, {}, ast.defaultValue),\n          identity,\n          identity\n        )\n      )\n    }\n    case \"PropertySignatureTransformation\":\n      return makePropertySignature(\n        new PropertySignatureTransformation(\n          new FromPropertySignature(\n            ast.from.type,\n            ast.from.isOptional,\n            ast.from.isReadonly,\n            ast.from.annotations,\n            key\n          ),\n          ast.to,\n          ast.decode,\n          ast.encode\n        )\n      )\n  }\n})\n\n/**\n * Converts an optional property to a required one through a transformation `Option -> Type`.\n *\n * - `decode`: `none` as argument means the value is missing in the input.\n * - `encode`: `none` as return value means the value will be missing in the output.\n *\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const optionalToRequired = <FA, FI, FR, TA, TI, TR>(\n  from: Schema<FA, FI, FR>,\n  to: Schema<TA, TI, TR>,\n  options: {\n    readonly decode: (o: option_.Option<FA>) => TI\n    readonly encode: (ti: TI) => option_.Option<FA>\n  }\n): PropertySignature<\":\", TA, never, \"?:\", FI, false, FR | TR> =>\n  makePropertySignature(\n    new PropertySignatureTransformation(\n      new FromPropertySignature(from.ast, true, true, {}, undefined),\n      new ToPropertySignature(to.ast, false, true, {}, undefined),\n      (o) => option_.some(options.decode(o)),\n      option_.flatMap(options.encode)\n    )\n  )\n\n/**\n * Converts an optional property to a required one through a transformation `Type -> Option`.\n *\n * - `decode`: `none` as return value means the value will be missing in the output.\n * - `encode`: `none` as argument means the value is missing in the input.\n *\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const requiredToOptional = <FA, FI, FR, TA, TI, TR>(\n  from: Schema<FA, FI, FR>,\n  to: Schema<TA, TI, TR>,\n  options: {\n    readonly decode: (fa: FA) => option_.Option<TI>\n    readonly encode: (o: option_.Option<TI>) => FA\n  }\n): PropertySignature<\"?:\", TA, never, \":\", FI, false, FR | TR> =>\n  makePropertySignature(\n    new PropertySignatureTransformation(\n      new FromPropertySignature(from.ast, false, true, {}, undefined),\n      new ToPropertySignature(to.ast, true, true, {}, undefined),\n      option_.flatMap(options.decode),\n      (o) => option_.some(options.encode(o))\n    )\n  )\n\n/**\n * Converts an optional property to another optional property through a transformation `Option -> Option`.\n *\n * - `decode`:\n *   - `none` as argument means the value is missing in the input.\n *   - `none` as return value means the value will be missing in the output.\n * - `encode`:\n *   - `none` as argument means the value is missing in the input.\n *   - `none` as return value means the value will be missing in the output.\n *\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const optionalToOptional = <FA, FI, FR, TA, TI, TR>(\n  from: Schema<FA, FI, FR>,\n  to: Schema<TA, TI, TR>,\n  options: {\n    readonly decode: (o: option_.Option<FA>) => option_.Option<TI>\n    readonly encode: (o: option_.Option<TI>) => option_.Option<FA>\n  }\n): PropertySignature<\"?:\", TA, never, \"?:\", FI, false, FR | TR> =>\n  makePropertySignature(\n    new PropertySignatureTransformation(\n      new FromPropertySignature(from.ast, true, true, {}, undefined),\n      new ToPropertySignature(to.ast, true, true, {}, undefined),\n      options.decode,\n      options.encode\n    )\n  )\n\n/**\n * @since 3.10.0\n */\nexport type OptionalOptions<A> = {\n  readonly default?: never\n  readonly as?: never\n  readonly exact?: true\n  readonly nullable?: true\n} | {\n  readonly default: LazyArg<A>\n  readonly as?: never\n  readonly exact?: true\n  readonly nullable?: true\n} | {\n  readonly as: \"Option\"\n  readonly default?: never\n  readonly exact?: never\n  readonly nullable?: never\n  readonly onNoneEncoding?: LazyArg<option_.Option<undefined>>\n} | {\n  readonly as: \"Option\"\n  readonly default?: never\n  readonly exact?: never\n  readonly nullable: true\n  readonly onNoneEncoding?: LazyArg<option_.Option<null | undefined>>\n} | {\n  readonly as: \"Option\"\n  readonly default?: never\n  readonly exact: true\n  readonly nullable?: never\n  readonly onNoneEncoding?: never\n} | {\n  readonly as: \"Option\"\n  readonly default?: never\n  readonly exact: true\n  readonly nullable: true\n  readonly onNoneEncoding?: LazyArg<option_.Option<null>>\n} | undefined\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface optional<S extends Schema.All> extends\n  PropertySignature<\n    \"?:\",\n    Schema.Type<S> | undefined,\n    never,\n    \"?:\",\n    Schema.Encoded<S> | undefined,\n    false,\n    Schema.Context<S>\n  >\n{\n  readonly from: S\n  annotations(annotations: PropertySignature.Annotations<Schema.Type<S> | undefined>): optional<S>\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface optionalWith<S extends Schema.All, Options> extends\n  PropertySignature<\n    Types.Has<Options, \"as\" | \"default\"> extends true ? \":\" : \"?:\",\n    | (Types.Has<Options, \"as\"> extends true ? option_.Option<Schema.Type<S>> : Schema.Type<S>)\n    | (Types.Has<Options, \"as\" | \"default\" | \"exact\"> extends true ? never : undefined),\n    never,\n    \"?:\",\n    | Schema.Encoded<S>\n    | (Types.Has<Options, \"nullable\"> extends true ? null : never)\n    | (Types.Has<Options, \"exact\"> extends true ? never : undefined),\n    Types.Has<Options, \"default\">,\n    Schema.Context<S>\n  >\n{\n  readonly from: S\n  annotations(\n    annotations: PropertySignature.Annotations<\n      | (Types.Has<Options, \"as\"> extends true ? option_.Option<Schema.Type<S>> : Schema.Type<S>)\n      | (Types.Has<Options, \"as\" | \"default\" | \"exact\"> extends true ? never : undefined)\n    >\n  ): optionalWith<S, Options>\n}\n\nconst optionalPropertySignatureAST = <A, I, R>(\n  self: Schema<A, I, R>,\n  options?: {\n    readonly exact?: true\n    readonly default?: () => A\n    readonly nullable?: true\n    readonly as?: \"Option\"\n    readonly onNoneEncoding?: () => option_.Option<never>\n  }\n): PropertySignature.AST => {\n  const isExact = options?.exact\n  const defaultValue = options?.default\n  const isNullable = options?.nullable\n  const asOption = options?.as == \"Option\"\n  const asOptionEncode = options?.onNoneEncoding ? option_.orElse(options.onNoneEncoding) : identity\n\n  if (isExact) {\n    if (defaultValue) {\n      if (isNullable) {\n        return withConstructorDefault(\n          optionalToRequired(\n            NullOr(self),\n            typeSchema(self),\n            {\n              decode: option_.match({ onNone: defaultValue, onSome: (a) => a === null ? defaultValue() : a }),\n              encode: option_.some\n            }\n          ),\n          defaultValue\n        ).ast\n      } else {\n        return withConstructorDefault(\n          optionalToRequired(\n            self,\n            typeSchema(self),\n            { decode: option_.match({ onNone: defaultValue, onSome: identity }), encode: option_.some }\n          ),\n          defaultValue\n        ).ast\n      }\n    } else if (asOption) {\n      if (isNullable) {\n        return optionalToRequired(\n          NullOr(self),\n          OptionFromSelf(typeSchema(self)),\n          {\n            decode: option_.filter(Predicate.isNotNull<A | null>),\n            encode: asOptionEncode\n          }\n        ).ast\n      } else {\n        return optionalToRequired(\n          self,\n          OptionFromSelf(typeSchema(self)),\n          { decode: identity, encode: identity }\n        ).ast\n      }\n    } else {\n      if (isNullable) {\n        return optionalToOptional(\n          NullOr(self),\n          typeSchema(self),\n          { decode: option_.filter(Predicate.isNotNull<A | null>), encode: identity }\n        ).ast\n      } else {\n        return new PropertySignatureDeclaration(self.ast, true, true, {}, undefined)\n      }\n    }\n  } else {\n    if (defaultValue) {\n      if (isNullable) {\n        return withConstructorDefault(\n          optionalToRequired(\n            NullishOr(self),\n            typeSchema(self),\n            {\n              decode: option_.match({ onNone: defaultValue, onSome: (a) => (a == null ? defaultValue() : a) }),\n              encode: option_.some\n            }\n          ),\n          defaultValue\n        ).ast\n      } else {\n        return withConstructorDefault(\n          optionalToRequired(\n            UndefinedOr(self),\n            typeSchema(self),\n            {\n              decode: option_.match({ onNone: defaultValue, onSome: (a) => (a === undefined ? defaultValue() : a) }),\n              encode: option_.some\n            }\n          ),\n          defaultValue\n        ).ast\n      }\n    } else if (asOption) {\n      if (isNullable) {\n        return optionalToRequired(\n          NullishOr(self),\n          OptionFromSelf(typeSchema(self)),\n          {\n            decode: option_.filter<A | null | undefined, A>((a): a is A => a != null),\n            encode: asOptionEncode\n          }\n        ).ast\n      } else {\n        return optionalToRequired(\n          UndefinedOr(self),\n          OptionFromSelf(typeSchema(self)),\n          {\n            decode: option_.filter(Predicate.isNotUndefined<A | undefined>),\n            encode: asOptionEncode\n          }\n        ).ast\n      }\n    } else {\n      if (isNullable) {\n        return optionalToOptional(\n          NullishOr(self),\n          UndefinedOr(typeSchema(self)),\n          { decode: option_.filter(Predicate.isNotNull<A | null | undefined>), encode: identity }\n        ).ast\n      } else {\n        return new PropertySignatureDeclaration(UndefinedOr(self).ast, true, true, {}, undefined)\n      }\n    }\n  }\n}\n\n/**\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const optional = <S extends Schema.All>(self: S): optional<S> => {\n  const ast = self.ast === AST.undefinedKeyword || self.ast === AST.neverKeyword\n    ? AST.undefinedKeyword\n    : UndefinedOr(self).ast\n  return new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(ast, true, true, {}, undefined), self)\n}\n\n/**\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const optionalWith: {\n  /**\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <S extends Schema.All, Options extends OptionalOptions<Schema.Type<S>>>(\n    options: Options\n  ): (self: S) => optionalWith<S, Options>\n  /**\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <S extends Schema.All, Options extends OptionalOptions<Schema.Type<S>>>(\n    self: S,\n    options: Options\n  ): optionalWith<S, Options>\n} = dual((args) => isSchema(args[0]), (self, options) => {\n  return new PropertySignatureWithFromImpl(optionalPropertySignatureAST(self, options), self)\n})\n\n/**\n * @since 3.10.0\n */\nexport declare namespace Struct {\n  /**\n   * @since 3.10.0\n   */\n  export type Fields = {\n    readonly [x: PropertyKey]:\n      | Schema.All\n      | PropertySignature.All\n  }\n\n  type Key<F extends Fields, K extends keyof F> = [K] extends [never] ? never :\n    F[K] extends PropertySignature.All<infer Key> ? [Key] extends [never] ? K : Key :\n    K\n\n  type EncodedTokenKeys<Fields extends Struct.Fields> = {\n    [K in keyof Fields]: Fields[K] extends\n      | PropertySignature<PropertySignature.Token, any, PropertyKey, \"?:\", any, boolean, unknown>\n      | PropertySignature<PropertySignature.Token, any, PropertyKey, \"?:\", never, boolean, unknown>\n      | PropertySignature<PropertySignature.Token, never, PropertyKey, \"?:\", any, boolean, unknown>\n      | PropertySignature<PropertySignature.Token, never, PropertyKey, \"?:\", never, boolean, unknown> ? K\n      : never\n  }[keyof Fields]\n\n  type TypeTokenKeys<Fields extends Struct.Fields> = {\n    [K in keyof Fields]: Fields[K] extends OptionalPropertySignature ? K : never\n  }[keyof Fields]\n\n  type OptionalPropertySignature =\n    | PropertySignature<\"?:\", any, PropertyKey, PropertySignature.Token, any, boolean, unknown>\n    | PropertySignature<\"?:\", any, PropertyKey, PropertySignature.Token, never, boolean, unknown>\n    | PropertySignature<\"?:\", never, PropertyKey, PropertySignature.Token, any, boolean, unknown>\n    | PropertySignature<\"?:\", never, PropertyKey, PropertySignature.Token, never, boolean, unknown>\n\n  /**\n   * @since 3.10.0\n   */\n  export type Type<F extends Fields> = Types.UnionToIntersection<\n    {\n      [K in keyof F]: F[K] extends OptionalPropertySignature ? { readonly [H in K]?: Schema.Type<F[H]> } :\n        { readonly [h in K]: Schema.Type<F[h]> }\n    }[keyof F]\n  > extends infer Q ? Q : never\n\n  /**\n   * @since 3.10.0\n   */\n  export type Encoded<F extends Fields> =\n    & { readonly [K in Exclude<keyof F, EncodedTokenKeys<F>> as Key<F, K>]: Schema.Encoded<F[K]> }\n    & { readonly [K in EncodedTokenKeys<F> as Key<F, K>]?: Schema.Encoded<F[K]> }\n\n  /**\n   * @since 3.10.0\n   */\n  export type Context<F extends Fields> = Schema.Context<F[keyof F]>\n\n  type PropertySignatureWithDefault =\n    | PropertySignature<PropertySignature.Token, any, PropertyKey, PropertySignature.Token, any, true, unknown>\n    | PropertySignature<PropertySignature.Token, any, PropertyKey, PropertySignature.Token, never, true, unknown>\n    | PropertySignature<PropertySignature.Token, never, PropertyKey, PropertySignature.Token, any, true, unknown>\n    | PropertySignature<PropertySignature.Token, never, PropertyKey, PropertySignature.Token, never, true, unknown>\n\n  /**\n   * @since 3.10.0\n   */\n  export type Constructor<F extends Fields> = Types.UnionToIntersection<\n    {\n      [K in keyof F]: F[K] extends OptionalPropertySignature ? { readonly [H in K]?: Schema.Type<F[H]> } :\n        F[K] extends PropertySignatureWithDefault ? { readonly [H in K]?: Schema.Type<F[H]> } :\n        { readonly [h in K]: Schema.Type<F[h]> }\n    }[keyof F]\n  > extends infer Q ? Q : never\n}\n\n/**\n * @since 3.10.0\n */\nexport declare namespace IndexSignature {\n  /**\n   * @since 3.10.0\n   */\n  export type Record = { readonly key: Schema.All; readonly value: Schema.All }\n\n  /**\n   * @since 3.10.0\n   */\n  export type Records = ReadonlyArray<Record>\n\n  /**\n   * @since 3.10.0\n   */\n  export type NonEmptyRecords = array_.NonEmptyReadonlyArray<Record>\n\n  /**\n   * @since 3.10.0\n   */\n  export type Type<\n    Records extends IndexSignature.Records\n  > = Types.UnionToIntersection<\n    {\n      [K in keyof Records]: {\n        readonly [P in Schema.Type<Records[K][\"key\"]>]: Schema.Type<Records[K][\"value\"]>\n      }\n    }[number]\n  >\n\n  /**\n   * @since 3.10.0\n   */\n  export type Encoded<\n    Records extends IndexSignature.Records\n  > = Types.UnionToIntersection<\n    {\n      [K in keyof Records]: {\n        readonly [P in Schema.Encoded<Records[K][\"key\"]>]: Schema.Encoded<Records[K][\"value\"]>\n      }\n    }[number]\n  >\n\n  /**\n   * @since 3.10.0\n   */\n  export type Context<Records extends IndexSignature.Records> = {\n    [K in keyof Records]: Schema.Context<Records[K][\"key\"]> | Schema.Context<Records[K][\"value\"]>\n  }[number]\n}\n\n/**\n * @since 3.10.0\n */\nexport declare namespace TypeLiteral {\n  /**\n   * @since 3.10.0\n   */\n  export type Type<Fields extends Struct.Fields, Records extends IndexSignature.Records> =\n    & Struct.Type<Fields>\n    & IndexSignature.Type<Records>\n\n  /**\n   * @since 3.10.0\n   */\n  export type Encoded<Fields extends Struct.Fields, Records extends IndexSignature.Records> =\n    & Struct.Encoded<Fields>\n    & IndexSignature.Encoded<Records>\n\n  /**\n   * @since 3.10.0\n   */\n  export type Constructor<Fields extends Struct.Fields, Records extends IndexSignature.Records> =\n    & Struct.Constructor<Fields>\n    & IndexSignature.Type<Records>\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface TypeLiteral<\n  Fields extends Struct.Fields,\n  Records extends IndexSignature.Records\n> extends\n  AnnotableClass<\n    TypeLiteral<Fields, Records>,\n    Simplify<TypeLiteral.Type<Fields, Records>>,\n    Simplify<TypeLiteral.Encoded<Fields, Records>>,\n    | Struct.Context<Fields>\n    | IndexSignature.Context<Records>\n  >\n{\n  readonly fields: { readonly [K in keyof Fields]: Fields[K] }\n  readonly records: Readonly<Records>\n  annotations(\n    annotations: Annotations.Schema<Simplify<TypeLiteral.Type<Fields, Records>>>\n  ): TypeLiteral<Fields, Records>\n  make(\n    props: RequiredKeys<TypeLiteral.Constructor<Fields, Records>> extends never\n      ? void | Simplify<TypeLiteral.Constructor<Fields, Records>>\n      : Simplify<TypeLiteral.Constructor<Fields, Records>>,\n    options?: MakeOptions\n  ): Simplify<TypeLiteral.Type<Fields, Records>>\n}\n\nconst preserveMissingMessageAnnotation = AST.whiteListAnnotations([AST.MissingMessageAnnotationId])\n\nconst getDefaultTypeLiteralAST = <\n  Fields extends Struct.Fields,\n  const Records extends IndexSignature.Records\n>(fields: Fields, records: Records) => {\n  const ownKeys = util_.ownKeys(fields)\n  const pss: Array<AST.PropertySignature> = []\n  if (ownKeys.length > 0) {\n    const from: Array<AST.PropertySignature> = []\n    const to: Array<AST.PropertySignature> = []\n    const transformations: Array<AST.PropertySignatureTransformation> = []\n    for (let i = 0; i < ownKeys.length; i++) {\n      const key = ownKeys[i]\n      const field = fields[key]\n      if (isPropertySignature(field)) {\n        const ast: PropertySignature.AST = field.ast\n        switch (ast._tag) {\n          case \"PropertySignatureDeclaration\": {\n            const type = ast.type\n            const isOptional = ast.isOptional\n            const toAnnotations = ast.annotations\n            from.push(new AST.PropertySignature(key, type, isOptional, true, preserveMissingMessageAnnotation(ast)))\n            to.push(new AST.PropertySignature(key, AST.typeAST(type), isOptional, true, toAnnotations))\n            pss.push(\n              new AST.PropertySignature(key, type, isOptional, true, toAnnotations)\n            )\n            break\n          }\n          case \"PropertySignatureTransformation\": {\n            const fromKey = ast.from.fromKey ?? key\n            from.push(\n              new AST.PropertySignature(fromKey, ast.from.type, ast.from.isOptional, true, ast.from.annotations)\n            )\n            to.push(\n              new AST.PropertySignature(key, ast.to.type, ast.to.isOptional, true, ast.to.annotations)\n            )\n            transformations.push(new AST.PropertySignatureTransformation(fromKey, key, ast.decode, ast.encode))\n            break\n          }\n        }\n      } else {\n        from.push(new AST.PropertySignature(key, field.ast, false, true))\n        to.push(new AST.PropertySignature(key, AST.typeAST(field.ast), false, true))\n        pss.push(new AST.PropertySignature(key, field.ast, false, true))\n      }\n    }\n    if (array_.isNonEmptyReadonlyArray(transformations)) {\n      const issFrom: Array<AST.IndexSignature> = []\n      const issTo: Array<AST.IndexSignature> = []\n      for (const r of records) {\n        const { indexSignatures, propertySignatures } = AST.record(r.key.ast, r.value.ast)\n        propertySignatures.forEach((ps) => {\n          from.push(ps)\n          to.push(\n            new AST.PropertySignature(ps.name, AST.typeAST(ps.type), ps.isOptional, ps.isReadonly, ps.annotations)\n          )\n        })\n        indexSignatures.forEach((is) => {\n          issFrom.push(is)\n          issTo.push(new AST.IndexSignature(is.parameter, AST.typeAST(is.type), is.isReadonly))\n        })\n      }\n      return new AST.Transformation(\n        new AST.TypeLiteral(from, issFrom, { [AST.AutoTitleAnnotationId]: \"Struct (Encoded side)\" }),\n        new AST.TypeLiteral(to, issTo, { [AST.AutoTitleAnnotationId]: \"Struct (Type side)\" }),\n        new AST.TypeLiteralTransformation(transformations)\n      )\n    }\n  }\n  const iss: Array<AST.IndexSignature> = []\n  for (const r of records) {\n    const { indexSignatures, propertySignatures } = AST.record(r.key.ast, r.value.ast)\n    propertySignatures.forEach((ps) => pss.push(ps))\n    indexSignatures.forEach((is) => iss.push(is))\n  }\n  return new AST.TypeLiteral(pss, iss)\n}\n\nconst lazilyMergeDefaults = (\n  fields: Struct.Fields,\n  out: Record<PropertyKey, unknown>\n): { [x: string | symbol]: unknown } => {\n  const ownKeys = util_.ownKeys(fields)\n  for (const key of ownKeys) {\n    const field = fields[key]\n    if (out[key] === undefined && isPropertySignature(field)) {\n      const ast = field.ast\n      const defaultValue = ast._tag === \"PropertySignatureDeclaration\" ? ast.defaultValue : ast.to.defaultValue\n      if (defaultValue !== undefined) {\n        out[key] = defaultValue()\n      }\n    }\n  }\n  return out\n}\n\nconst makeTypeLiteralClass = <\n  Fields extends Struct.Fields,\n  const Records extends IndexSignature.Records\n>(\n  fields: Fields,\n  records: Records,\n  ast: AST.AST = getDefaultTypeLiteralAST(fields, records)\n): TypeLiteral<Fields, Records> => {\n  return class TypeLiteralClass extends make<\n    Simplify<TypeLiteral.Type<Fields, Records>>,\n    Simplify<TypeLiteral.Encoded<Fields, Records>>,\n    | Struct.Context<Fields>\n    | IndexSignature.Context<Records>\n  >(ast) {\n    static override annotations(\n      annotations: Annotations.Schema<Simplify<TypeLiteral.Type<Fields, Records>>>\n    ): TypeLiteral<Fields, Records> {\n      return makeTypeLiteralClass(this.fields, this.records, mergeSchemaAnnotations(this.ast, annotations))\n    }\n\n    static fields = { ...fields }\n\n    static records = [...records] as Records\n\n    static make = (\n      props: Simplify<TypeLiteral.Constructor<Fields, Records>>,\n      options?: MakeOptions\n    ): Simplify<TypeLiteral.Type<Fields, Records>> => {\n      const propsWithDefaults: any = lazilyMergeDefaults(fields, { ...props as any })\n      return getDisableValidationMakeOption(options)\n        ? propsWithDefaults\n        : ParseResult.validateSync(this)(propsWithDefaults)\n    }\n\n    static pick(...keys: Array<keyof Fields>): Struct<Simplify<Pick<Fields, typeof keys[number]>>> {\n      return Struct(struct_.pick(fields, ...keys) as any)\n    }\n\n    static omit(...keys: Array<keyof Fields>): Struct<Simplify<Omit<Fields, typeof keys[number]>>> {\n      return Struct(struct_.omit(fields, ...keys) as any)\n    }\n  }\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Struct<Fields extends Struct.Fields> extends TypeLiteral<Fields, []> {\n  annotations(annotations: Annotations.Schema<Simplify<Struct.Type<Fields>>>): Struct<Fields>\n  pick<Keys extends ReadonlyArray<keyof Fields>>(...keys: Keys): Struct<Simplify<Pick<Fields, Keys[number]>>>\n  omit<Keys extends ReadonlyArray<keyof Fields>>(...keys: Keys): Struct<Simplify<Omit<Fields, Keys[number]>>>\n}\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport function Struct<Fields extends Struct.Fields, const Records extends IndexSignature.NonEmptyRecords>(\n  fields: Fields,\n  ...records: Records\n): TypeLiteral<Fields, Records>\nexport function Struct<Fields extends Struct.Fields>(fields: Fields): Struct<Fields>\nexport function Struct<Fields extends Struct.Fields, const Records extends IndexSignature.Records>(\n  fields: Fields,\n  ...records: Records\n): TypeLiteral<Fields, Records> {\n  return makeTypeLiteralClass(fields, records)\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface tag<Tag extends AST.LiteralValue> extends PropertySignature<\":\", Tag, never, \":\", Tag, true, never> {}\n\n/**\n * Returns a property signature that represents a tag.\n * A tag is a literal value that is used to distinguish between different types of objects.\n * The tag is optional when using the `make` method.\n *\n * @see {@link TaggedStruct}\n *\n * @example\n * ```ts\n * import { Schema } from \"effect\"\n *\n * const User = Schema.Struct({\n *   _tag: Schema.tag(\"User\"),\n *   name: Schema.String,\n *   age: Schema.Number\n * })\n *\n * assert.deepStrictEqual(User.make({ name: \"John\", age: 44 }), { _tag: \"User\", name: \"John\", age: 44 })\n * ```\n *\n * @since 3.10.0\n */\nexport const tag = <Tag extends AST.LiteralValue>(tag: Tag): tag<Tag> =>\n  Literal(tag).pipe(propertySignature, withConstructorDefault(() => tag))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport type TaggedStruct<Tag extends AST.LiteralValue, Fields extends Struct.Fields> = Struct<\n  { _tag: tag<Tag> } & Fields\n>\n\n/**\n * A tagged struct is a struct that has a tag property that is used to distinguish between different types of objects.\n *\n * The tag is optional when using the `make` method.\n *\n * @example\n * ```ts\n * import { Schema } from \"effect\"\n *\n * const User = Schema.TaggedStruct(\"User\", {\n *   name: Schema.String,\n *   age: Schema.Number\n * })\n *\n * assert.deepStrictEqual(User.make({ name: \"John\", age: 44 }), { _tag: \"User\", name: \"John\", age: 44 })\n * ```\n *\n * @category constructors\n * @since 3.10.0\n */\nexport const TaggedStruct = <Tag extends AST.LiteralValue, Fields extends Struct.Fields>(\n  value: Tag,\n  fields: Fields\n): TaggedStruct<Tag, Fields> => Struct({ _tag: tag(value), ...fields })\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Record$<K extends Schema.All, V extends Schema.All> extends TypeLiteral<{}, [{ key: K; value: V }]> {\n  readonly key: K\n  readonly value: V\n  annotations(\n    annotations: Annotations.Schema<Simplify<TypeLiteral.Type<{}, [{ key: K; value: V }]>>>\n  ): Record$<K, V>\n}\n\nconst makeRecordClass = <K extends Schema.All, V extends Schema.All>(\n  key: K,\n  value: V,\n  ast?: AST.AST\n): Record$<K, V> => (class RecordClass extends makeTypeLiteralClass({}, [{ key, value }], ast) {\n  static override annotations(\n    annotations: Annotations.Schema<Simplify<TypeLiteral.Type<{}, [{ key: K; value: V }]>>>\n  ) {\n    return makeRecordClass(key, value, mergeSchemaAnnotations(this.ast, annotations))\n  }\n\n  static key = key\n\n  static value = value\n})\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport const Record = <K extends Schema.All, V extends Schema.All>(\n  options: { readonly key: K; readonly value: V }\n): Record$<K, V> => makeRecordClass(options.key, options.value)\n\n/**\n * @category struct transformations\n * @since 3.10.0\n */\nexport const pick = <A, I, Keys extends ReadonlyArray<keyof A & keyof I>>(...keys: Keys) =>\n<R>(\n  self: Schema<A, I, R>\n): SchemaClass<Simplify<Pick<A, Keys[number]>>, Simplify<Pick<I, Keys[number]>>, R> => make(AST.pick(self.ast, keys))\n\n/**\n * @category struct transformations\n * @since 3.10.0\n */\nexport const omit = <A, I, Keys extends ReadonlyArray<keyof A & keyof I>>(...keys: Keys) =>\n<R>(\n  self: Schema<A, I, R>\n): SchemaClass<Simplify<Omit<A, Keys[number]>>, Simplify<Omit<I, Keys[number]>>, R> => make(AST.omit(self.ast, keys))\n\n/**\n * Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,\n * producing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.\n *\n * @example\n * ```ts\n * import * as Schema from \"effect/Schema\"\n *\n * // ---------------------------------------------\n * // use case: pull out a single field from a\n * // struct through a transformation\n * // ---------------------------------------------\n *\n * const mytable = Schema.Struct({\n *   column1: Schema.NumberFromString,\n *   column2: Schema.Number\n * })\n *\n * // const pullOutColumn: S.Schema<number, {\n * //     readonly column1: string;\n * // }, never>\n * const pullOutColumn = mytable.pipe(Schema.pluck(\"column1\"))\n *\n * console.log(Schema.decodeUnknownEither(Schema.Array(pullOutColumn))([{ column1: \"1\", column2: 100 }, { column1: \"2\", column2: 300 }]))\n * // Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }\n * ```\n *\n * @category struct transformations\n * @since 3.10.0\n */\nexport const pluck: {\n  /**\n   * Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,\n   * producing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.\n   *\n   * @example\n   * ```ts\n   * import * as Schema from \"effect/Schema\"\n   *\n   * // ---------------------------------------------\n   * // use case: pull out a single field from a\n   * // struct through a transformation\n   * // ---------------------------------------------\n   *\n   * const mytable = Schema.Struct({\n   *   column1: Schema.NumberFromString,\n   *   column2: Schema.Number\n   * })\n   *\n   * // const pullOutColumn: S.Schema<number, {\n   * //     readonly column1: string;\n   * // }, never>\n   * const pullOutColumn = mytable.pipe(Schema.pluck(\"column1\"))\n   *\n   * console.log(Schema.decodeUnknownEither(Schema.Array(pullOutColumn))([{ column1: \"1\", column2: 100 }, { column1: \"2\", column2: 300 }]))\n   * // Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }\n   * ```\n   *\n   * @category struct transformations\n   * @since 3.10.0\n   */\n  <A, I, K extends keyof A & keyof I>(\n    key: K\n  ): <R>(schema: Schema<A, I, R>) => Schema<A[K], { readonly [P in K]: I[P] }, R>\n  /**\n   * Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,\n   * producing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.\n   *\n   * @example\n   * ```ts\n   * import * as Schema from \"effect/Schema\"\n   *\n   * // ---------------------------------------------\n   * // use case: pull out a single field from a\n   * // struct through a transformation\n   * // ---------------------------------------------\n   *\n   * const mytable = Schema.Struct({\n   *   column1: Schema.NumberFromString,\n   *   column2: Schema.Number\n   * })\n   *\n   * // const pullOutColumn: S.Schema<number, {\n   * //     readonly column1: string;\n   * // }, never>\n   * const pullOutColumn = mytable.pipe(Schema.pluck(\"column1\"))\n   *\n   * console.log(Schema.decodeUnknownEither(Schema.Array(pullOutColumn))([{ column1: \"1\", column2: 100 }, { column1: \"2\", column2: 300 }]))\n   * // Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }\n   * ```\n   *\n   * @category struct transformations\n   * @since 3.10.0\n   */\n  <A, I, R, K extends keyof A & keyof I>(schema: Schema<A, I, R>, key: K): Schema<A[K], { readonly [P in K]: I[P] }, R>\n} = dual(\n  2,\n  <A, I, R, K extends keyof A & keyof I>(\n    schema: Schema<A, I, R>,\n    key: K\n  ): Schema<A[K], Pick<I, K>, R> => {\n    const ps = AST.getPropertyKeyIndexedAccess(AST.typeAST(schema.ast), key)\n    const value = make<\n      /**\n       * Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,\n       * producing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.\n       *\n       * @example\n       * ```ts\n       * import * as Schema from \"effect/Schema\"\n       *\n       * // ---------------------------------------------\n       * // use case: pull out a single field from a\n       * // struct through a transformation\n       * // ---------------------------------------------\n       *\n       * const mytable = Schema.Struct({\n       *   column1: Schema.NumberFromString,\n       *   column2: Schema.Number\n       * })\n       *\n       * // const pullOutColumn: S.Schema<number, {\n       * //     readonly column1: string;\n       * // }, never>\n       * const pullOutColumn = mytable.pipe(Schema.pluck(\"column1\"))\n       *\n       * console.log(Schema.decodeUnknownEither(Schema.Array(pullOutColumn))([{ column1: \"1\", column2: 100 }, { column1: \"2\", column2: 300 }]))\n       * // Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }\n       * ```\n       *\n       * @category struct transformations\n       * @since 3.10.0\n       */\n      A[K], /**\n       * Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,\n       * producing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.\n       *\n       * @example\n       * ```ts\n       * import * as Schema from \"effect/Schema\"\n       *\n       * // ---------------------------------------------\n       * // use case: pull out a single field from a\n       * // struct through a transformation\n       * // ---------------------------------------------\n       *\n       * const mytable = Schema.Struct({\n       *   column1: Schema.NumberFromString,\n       *   column2: Schema.Number\n       * })\n       *\n       * // const pullOutColumn: S.Schema<number, {\n       * //     readonly column1: string;\n       * // }, never>\n       * const pullOutColumn = mytable.pipe(Schema.pluck(\"column1\"))\n       *\n       * console.log(Schema.decodeUnknownEither(Schema.Array(pullOutColumn))([{ column1: \"1\", column2: 100 }, { column1: \"2\", column2: 300 }]))\n       * // Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }\n       * ```\n       *\n       * @category struct transformations\n       * @since 3.10.0\n       */\n      A[K], /**\n       * Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,\n       * producing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.\n       *\n       * @example\n       * ```ts\n       * import * as Schema from \"effect/Schema\"\n       *\n       * // ---------------------------------------------\n       * // use case: pull out a single field from a\n       * // struct through a transformation\n       * // ---------------------------------------------\n       *\n       * const mytable = Schema.Struct({\n       *   column1: Schema.NumberFromString,\n       *   column2: Schema.Number\n       * })\n       *\n       * // const pullOutColumn: S.Schema<number, {\n       * //     readonly column1: string;\n       * // }, never>\n       * const pullOutColumn = mytable.pipe(Schema.pluck(\"column1\"))\n       *\n       * console.log(Schema.decodeUnknownEither(Schema.Array(pullOutColumn))([{ column1: \"1\", column2: 100 }, { column1: \"2\", column2: 300 }]))\n       * // Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }\n       * ```\n       *\n       * @category struct transformations\n       * @since 3.10.0\n       */\n      R\n    >(ps.isOptional ? AST.orUndefined(ps.type) : ps.type)\n    return transform(\n      schema.pipe(pick(key)),\n      value,\n      {\n        strict: true,\n        decode: (a: any) => a[key],\n        encode: (ak) => ps.isOptional && ak === undefined ? {} : { [key]: ak } as any\n      }\n    )\n  }\n)\n\n/**\n * @category branding\n * @since 3.10.0\n */\nexport interface BrandSchema<A extends Brand<any>, I = A, R = never>\n  extends AnnotableClass<BrandSchema<A, I, R>, A, I, R>\n{\n  make(a: Brand.Unbranded<A>, options?: MakeOptions): A\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface brand<S extends Schema.Any, B extends string | symbol>\n  extends BrandSchema<Schema.Type<S> & Brand<B>, Schema.Encoded<S>, Schema.Context<S>>\n{\n  annotations(annotations: Annotations.Schema<Schema.Type<S> & Brand<B>>): brand<S, B>\n}\n\nconst makeBrandClass = <S extends Schema.Any, B extends string | symbol>(\n  ast: AST.AST\n): brand<S, B> => (class BrandClass extends make<Schema.Type<S> & Brand<B>, Schema.Encoded<S>, Schema.Context<S>>(ast) {\n  static override annotations(annotations: Annotations.Schema<Schema.Type<S> & Brand<B>>): brand<S, B> {\n    return makeBrandClass(mergeSchemaAnnotations(this.ast, annotations))\n  }\n\n  static make = (a: Brand.Unbranded<Schema.Type<S> & Brand<B>>, options?: MakeOptions): Schema.Type<S> & Brand<B> => {\n    return getDisableValidationMakeOption(options) ? a : ParseResult.validateSync(this)(a)\n  }\n})\n\n/**\n * Returns a nominal branded schema by applying a brand to a given schema.\n *\n * ```\n * Schema<A> + B -> Schema<A & Brand<B>>\n * ```\n *\n * @param self - The input schema to be combined with the brand.\n * @param brand - The brand to apply.\n *\n * @example\n * ```ts\n * import * as Schema from \"effect/Schema\"\n *\n * const Int = Schema.Number.pipe(Schema.int(), Schema.brand(\"Int\"))\n * type Int = Schema.Schema.Type<typeof Int> // number & Brand<\"Int\">\n * ```\n *\n * @category branding\n * @since 3.10.0\n */\nexport const brand = <S extends Schema.AnyNoContext, B extends string | symbol>(\n  brand: B,\n  annotations?: Annotations.Schema<Schema.Type<S> & Brand<B>>\n) =>\n(self: S): brand<S, B> => {\n  const annotation: AST.BrandAnnotation = option_.match(AST.getBrandAnnotation(self.ast), {\n    onNone: () => [brand],\n    onSome: (brands) => [...brands, brand]\n  })\n  const ast = AST.annotations(\n    self.ast,\n    toASTAnnotations({\n      [AST.BrandAnnotationId]: annotation,\n      ...annotations\n    })\n  )\n  return makeBrandClass(ast)\n}\n\n/**\n * @category combinators\n * @since 3.10.0\n */\nexport const partial = <A, I, R>(\n  self: Schema<A, I, R>\n): SchemaClass<{ [K in keyof A]?: A[K] | undefined }, { [K in keyof I]?: I[K] | undefined }, R> =>\n  make(AST.partial(self.ast))\n\n/**\n * @category combinators\n * @since 3.10.0\n */\nexport const partialWith: {\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <const Options extends { readonly exact: true }>(options: Options): <A, I, R>(\n    self: Schema<A, I, R>\n  ) => SchemaClass<{ [K in keyof A]?: A[K] }, { [K in keyof I]?: I[K] }, R>\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <A, I, R, const Options extends { readonly exact: true } | undefined>(\n    self: Schema<A, I, R>,\n    options: Options\n  ): SchemaClass<{ [K in keyof A]?: A[K] }, { [K in keyof I]?: I[K] }, R>\n} = dual((args) => isSchema(args[0]), <A, I, R>(\n  self: Schema<A, I, R>,\n  options: { readonly exact: true }\n): SchemaClass<Partial<A>, Partial<I>, R> => make(AST.partial(self.ast, options)))\n\n/**\n * @category combinators\n * @since 3.10.0\n */\nexport const required = <A, I, R>(\n  self: Schema<A, I, R>\n): SchemaClass<{ [K in keyof A]-?: A[K] }, { [K in keyof I]-?: I[K] }, R> => make(AST.required(self.ast))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface mutable<S extends Schema.Any> extends\n  AnnotableClass<\n    mutable<S>,\n    SimplifyMutable<Schema.Type<S>>,\n    SimplifyMutable<Schema.Encoded<S>>,\n    Schema.Context<S>\n  >\n{}\n\n/**\n * Creates a new schema with shallow mutability applied to its properties.\n *\n * @param schema - The original schema to make properties mutable (shallowly).\n *\n * @category combinators\n * @since 3.10.0\n */\nexport const mutable = <S extends Schema.Any>(schema: S): mutable<S> => make(AST.mutable(schema.ast))\n\nconst intersectTypeLiterals = (\n  x: AST.AST,\n  y: AST.AST,\n  path: ReadonlyArray<PropertyKey>\n): AST.TypeLiteral => {\n  if (AST.isTypeLiteral(x) && AST.isTypeLiteral(y)) {\n    const propertySignatures = [...x.propertySignatures]\n    for (const ps of y.propertySignatures) {\n      const name = ps.name\n      const i = propertySignatures.findIndex((ps) => ps.name === name)\n      if (i === -1) {\n        propertySignatures.push(ps)\n      } else {\n        const { isOptional, type } = propertySignatures[i]\n        propertySignatures[i] = new AST.PropertySignature(\n          name,\n          extendAST(type, ps.type, path.concat(name)),\n          isOptional,\n          true\n        )\n      }\n    }\n    return new AST.TypeLiteral(\n      propertySignatures,\n      x.indexSignatures.concat(y.indexSignatures)\n    )\n  }\n  throw new Error(errors_.getSchemaExtendErrorMessage(x, y, path))\n}\n\nconst preserveRefinementAnnotations = AST.blackListAnnotations([\n  AST.IdentifierAnnotationId\n])\n\nconst addRefinementToMembers = (refinement: AST.Refinement, asts: ReadonlyArray<AST.AST>): Array<AST.Refinement> =>\n  asts.map((ast) => new AST.Refinement(ast, refinement.filter, preserveRefinementAnnotations(refinement)))\n\nconst extendAST = (\n  x: AST.AST,\n  y: AST.AST,\n  path: ReadonlyArray<PropertyKey>\n): AST.AST => AST.Union.make(intersectUnionMembers([x], [y], path))\n\nconst getTypes = (ast: AST.AST): ReadonlyArray<AST.AST> => AST.isUnion(ast) ? ast.types : [ast]\n\nconst intersectUnionMembers = (\n  xs: ReadonlyArray<AST.AST>,\n  ys: ReadonlyArray<AST.AST>,\n  path: ReadonlyArray<PropertyKey>\n): Array<AST.AST> =>\n  array_.flatMap(xs, (x) =>\n    array_.flatMap(ys, (y) => {\n      switch (y._tag) {\n        case \"Literal\": {\n          if (\n            (Predicate.isString(y.literal) && AST.isStringKeyword(x) ||\n              (Predicate.isNumber(y.literal) && AST.isNumberKeyword(x)) ||\n              (Predicate.isBoolean(y.literal) && AST.isBooleanKeyword(x)))\n          ) {\n            return [y]\n          }\n          break\n        }\n        case \"StringKeyword\": {\n          if (y === AST.stringKeyword) {\n            if (AST.isStringKeyword(x) || (AST.isLiteral(x) && Predicate.isString(x.literal))) {\n              return [x]\n            } else if (AST.isRefinement(x)) {\n              return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path))\n            }\n          } else if (x === AST.stringKeyword) {\n            return [y]\n          }\n          break\n        }\n        case \"NumberKeyword\": {\n          if (y === AST.numberKeyword) {\n            if (AST.isNumberKeyword(x) || (AST.isLiteral(x) && Predicate.isNumber(x.literal))) {\n              return [x]\n            } else if (AST.isRefinement(x)) {\n              return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path))\n            }\n          } else if (x === AST.numberKeyword) {\n            return [y]\n          }\n          break\n        }\n        case \"BooleanKeyword\": {\n          if (y === AST.booleanKeyword) {\n            if (AST.isBooleanKeyword(x) || (AST.isLiteral(x) && Predicate.isBoolean(x.literal))) {\n              return [x]\n            } else if (AST.isRefinement(x)) {\n              return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path))\n            }\n          } else if (x === AST.booleanKeyword) {\n            return [y]\n          }\n          break\n        }\n        case \"Union\":\n          return intersectUnionMembers(getTypes(x), y.types, path)\n        case \"Suspend\":\n          return [new AST.Suspend(() => extendAST(x, y.f(), path))]\n        case \"Refinement\":\n          return addRefinementToMembers(y, intersectUnionMembers(getTypes(x), getTypes(y.from), path))\n        case \"TypeLiteral\": {\n          switch (x._tag) {\n            case \"Union\":\n              return intersectUnionMembers(x.types, [y], path)\n            case \"Suspend\":\n              return [new AST.Suspend(() => extendAST(x.f(), y, path))]\n            case \"Refinement\":\n              return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path))\n            case \"TypeLiteral\":\n              return [intersectTypeLiterals(x, y, path)]\n            case \"Transformation\": {\n              if (AST.isTypeLiteralTransformation(x.transformation)) {\n                return [\n                  new AST.Transformation(\n                    intersectTypeLiterals(x.from, y, path),\n                    intersectTypeLiterals(x.to, AST.typeAST(y), path),\n                    new AST.TypeLiteralTransformation(\n                      x.transformation.propertySignatureTransformations\n                    )\n                  )\n                ]\n              }\n              break\n            }\n          }\n          break\n        }\n        case \"Transformation\": {\n          if (AST.isTypeLiteralTransformation(y.transformation)) {\n            switch (x._tag) {\n              case \"Union\":\n                return intersectUnionMembers(x.types, [y], path)\n              case \"Suspend\":\n                return [new AST.Suspend(() => extendAST(x.f(), y, path))]\n              case \"Refinement\":\n                return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path))\n              case \"TypeLiteral\":\n                return [\n                  new AST.Transformation(\n                    intersectTypeLiterals(x, y.from, path),\n                    intersectTypeLiterals(AST.typeAST(x), y.to, path),\n                    new AST.TypeLiteralTransformation(\n                      y.transformation.propertySignatureTransformations\n                    )\n                  )\n                ]\n              case \"Transformation\":\n                {\n                  if (AST.isTypeLiteralTransformation(x.transformation)) {\n                    return [\n                      new AST.Transformation(\n                        intersectTypeLiterals(x.from, y.from, path),\n                        intersectTypeLiterals(x.to, y.to, path),\n                        new AST.TypeLiteralTransformation(\n                          y.transformation.propertySignatureTransformations.concat(\n                            x.transformation.propertySignatureTransformations\n                          )\n                        )\n                      )\n                    ]\n                  }\n                }\n                break\n            }\n          }\n          break\n        }\n      }\n      throw new Error(errors_.getSchemaExtendErrorMessage(x, y, path))\n    }))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface extend<Self extends Schema.Any, That extends Schema.Any> extends\n  AnnotableClass<\n    extend<Self, That>,\n    Schema.Type<Self> & Schema.Type<That>,\n    Schema.Encoded<Self> & Schema.Encoded<That>,\n    Schema.Context<Self> | Schema.Context<That>\n  >\n{}\n\n/**\n * Extends a schema with another schema.\n *\n * Not all extensions are supported, and their support depends on the nature of the involved schemas.\n *\n * Possible extensions include:\n * - `Schema.String` with another `Schema.String` refinement or a string literal\n * - `Schema.Number` with another `Schema.Number` refinement or a number literal\n * - `Schema.Boolean` with another `Schema.Boolean` refinement or a boolean literal\n * - A struct with another struct where overlapping fields support extension\n * - A struct with in index signature\n * - A struct with a union of supported schemas\n * - A refinement of a struct with a supported schema\n * - A suspend of a struct with a supported schema\n *\n * @example\n * ```ts\n * import * as Schema from \"effect/Schema\"\n *\n * const schema = Schema.Struct({\n *   a: Schema.String,\n *   b: Schema.String\n * })\n *\n * // const extended: Schema<\n * //   {\n * //     readonly a: string\n * //     readonly b: string\n * //   } & {\n * //     readonly c: string\n * //   } & {\n * //     readonly [x: string]: string\n * //   }\n * // >\n * const extended = Schema.asSchema(schema.pipe(\n *   Schema.extend(Schema.Struct({ c: Schema.String })), // <= you can add more fields\n *   Schema.extend(Schema.Record({ key: Schema.String, value: Schema.String })) // <= you can add index signatures\n * ))\n * ```\n *\n * @category combinators\n * @since 3.10.0\n */\nexport const extend: {\n  /**\n   * Extends a schema with another schema.\n   *\n   * Not all extensions are supported, and their support depends on the nature of the involved schemas.\n   *\n   * Possible extensions include:\n   * - `Schema.String` with another `Schema.String` refinement or a string literal\n   * - `Schema.Number` with another `Schema.Number` refinement or a number literal\n   * - `Schema.Boolean` with another `Schema.Boolean` refinement or a boolean literal\n   * - A struct with another struct where overlapping fields support extension\n   * - A struct with in index signature\n   * - A struct with a union of supported schemas\n   * - A refinement of a struct with a supported schema\n   * - A suspend of a struct with a supported schema\n   *\n   * @example\n   * ```ts\n   * import * as Schema from \"effect/Schema\"\n   *\n   * const schema = Schema.Struct({\n   *   a: Schema.String,\n   *   b: Schema.String\n   * })\n   *\n   * // const extended: Schema<\n   * //   {\n   * //     readonly a: string\n   * //     readonly b: string\n   * //   } & {\n   * //     readonly c: string\n   * //   } & {\n   * //     readonly [x: string]: string\n   * //   }\n   * // >\n   * const extended = Schema.asSchema(schema.pipe(\n   *   Schema.extend(Schema.Struct({ c: Schema.String })), // <= you can add more fields\n   *   Schema.extend(Schema.Record({ key: Schema.String, value: Schema.String })) // <= you can add index signatures\n   * ))\n   * ```\n   *\n   * @category combinators\n   * @since 3.10.0\n   */\n  <That extends Schema.Any>(that: That): <Self extends Schema.Any>(self: Self) => extend<Self, That>\n  /**\n   * Extends a schema with another schema.\n   *\n   * Not all extensions are supported, and their support depends on the nature of the involved schemas.\n   *\n   * Possible extensions include:\n   * - `Schema.String` with another `Schema.String` refinement or a string literal\n   * - `Schema.Number` with another `Schema.Number` refinement or a number literal\n   * - `Schema.Boolean` with another `Schema.Boolean` refinement or a boolean literal\n   * - A struct with another struct where overlapping fields support extension\n   * - A struct with in index signature\n   * - A struct with a union of supported schemas\n   * - A refinement of a struct with a supported schema\n   * - A suspend of a struct with a supported schema\n   *\n   * @example\n   * ```ts\n   * import * as Schema from \"effect/Schema\"\n   *\n   * const schema = Schema.Struct({\n   *   a: Schema.String,\n   *   b: Schema.String\n   * })\n   *\n   * // const extended: Schema<\n   * //   {\n   * //     readonly a: string\n   * //     readonly b: string\n   * //   } & {\n   * //     readonly c: string\n   * //   } & {\n   * //     readonly [x: string]: string\n   * //   }\n   * // >\n   * const extended = Schema.asSchema(schema.pipe(\n   *   Schema.extend(Schema.Struct({ c: Schema.String })), // <= you can add more fields\n   *   Schema.extend(Schema.Record({ key: Schema.String, value: Schema.String })) // <= you can add index signatures\n   * ))\n   * ```\n   *\n   * @category combinators\n   * @since 3.10.0\n   */\n  <Self extends Schema.Any, That extends Schema.Any>(self: Self, that: That): extend<Self, That>\n} = dual(\n  2,\n  <Self extends Schema.Any, That extends Schema.Any>(self: Self, that: That) => make(extendAST(self.ast, that.ast, []))\n)\n\n/**\n * @category combinators\n * @since 3.10.0\n */\nexport const compose: {\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <D, C extends B, R2, B>(to: Schema<D, C, R2>): <A, R1>(from: Schema<B, A, R1>) => SchemaClass<D, A, R1 | R2>\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <D, C, R2>(to: Schema<D, C, R2>): <B extends C, A, R1>(from: Schema<B, A, R1>) => SchemaClass<D, A, R1 | R2>\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <C, B, R2>(\n    to: Schema<C, B, R2>,\n    options?: { readonly strict: true }\n  ): <A, R1>(from: Schema<B, A, R1>) => SchemaClass<C, A, R1 | R2>\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <D, C, R2>(\n    to: Schema<D, C, R2>,\n    options: { readonly strict: false }\n  ): <B, A, R1>(from: Schema<B, A, R1>) => SchemaClass<D, A, R1 | R2>\n\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <B, A, R1, D, C extends B, R2>(from: Schema<B, A, R1>, to: Schema<D, C, R2>): SchemaClass<D, A, R1 | R2>\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <B extends C, A, R1, D, C, R2>(from: Schema<B, A, R1>, to: Schema<D, C, R2>): SchemaClass<D, A, R1 | R2>\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <B, A, R1, C, R2>(\n    from: Schema<B, A, R1>,\n    to: Schema<C, B, R2>,\n    options?: { readonly strict: true }\n  ): SchemaClass<C, A, R1 | R2>\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <B, A, R1, D, C, R2>(\n    from: Schema<B, A, R1>,\n    to: Schema<D, C, R2>,\n    options: { readonly strict: false }\n  ): SchemaClass<D, A, R1 | R2>\n} = dual(\n  (args) => isSchema(args[1]),\n  <B, A, R1, D, C, R2>(from: Schema<B, A, R1>, to: Schema<D, C, R2>): SchemaClass<D, A, R1 | R2> =>\n    make(AST.compose(from.ast, to.ast))\n)\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface suspend<A, I, R> extends AnnotableClass<suspend<A, I, R>, A, I, R> {}\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport const suspend = <A, I, R>(f: () => Schema<A, I, R>): suspend<A, I, R> => make(new AST.Suspend(() => f().ast))\n\n/**\n * @since 3.10.0\n * @category symbol\n */\nexport const RefineSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/Refine\")\n\n/**\n * @since 3.10.0\n * @category symbol\n */\nexport type RefineSchemaId = typeof RefineSchemaId\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface refine<A, From extends Schema.Any>\n  extends AnnotableClass<refine<A, From>, A, Schema.Encoded<From>, Schema.Context<From>>\n{\n  readonly [RefineSchemaId]: From // required for `type HasFields = ...`\n  readonly from: From\n  readonly filter: (\n    a: Schema.Type<From>,\n    options: ParseOptions,\n    self: AST.Refinement\n  ) => option_.Option<ParseResult.ParseIssue>\n  make(a: Schema.Type<From>, options?: MakeOptions): A\n}\n\nconst makeRefineClass = <From extends Schema.Any, A>(\n  from: From,\n  filter: (\n    a: Schema.Type<From>,\n    options: ParseOptions,\n    self: AST.Refinement\n  ) => option_.Option<ParseResult.ParseIssue>,\n  ast: AST.AST\n): refine<A, From> => (class RefineClass extends make<A, Schema.Encoded<From>, Schema.Context<From>>(ast) {\n  static override annotations(annotations: Annotations.Schema<A>): refine<A, From> {\n    return makeRefineClass(this.from, this.filter, mergeSchemaAnnotations(this.ast, annotations))\n  }\n\n  static [RefineSchemaId] = from\n\n  static from = from\n\n  static filter = filter\n\n  static make = (a: Schema.Type<From>, options?: MakeOptions): A => {\n    return getDisableValidationMakeOption(options) ? a : ParseResult.validateSync(this)(a)\n  }\n})\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface filter<From extends Schema.Any> extends refine<Schema.Type<From>, From> {}\n\nconst fromFilterPredicateReturnTypeItem = (\n  item: FilterOutput,\n  ast: AST.Refinement | AST.Transformation,\n  input: unknown\n): option_.Option<ParseResult.ParseIssue> => {\n  if (Predicate.isBoolean(item)) {\n    return item\n      ? option_.none()\n      : option_.some(new ParseResult.Type(ast, input))\n  }\n  if (Predicate.isString(item)) {\n    return option_.some(new ParseResult.Type(ast, input, item))\n  }\n  if (item !== undefined) {\n    if (\"_tag\" in item) {\n      return option_.some(item)\n    }\n    const issue = new ParseResult.Type(ast, input, item.message)\n    return option_.some(\n      array_.isNonEmptyReadonlyArray(item.path) ? new ParseResult.Pointer(item.path, input, issue) : issue\n    )\n  }\n  return option_.none()\n}\n\nconst toFilterParseIssue = (\n  out: FilterReturnType,\n  ast: AST.Refinement | AST.Transformation,\n  input: unknown\n): option_.Option<ParseResult.ParseIssue> => {\n  if (util_.isSingle(out)) {\n    return fromFilterPredicateReturnTypeItem(out, ast, input)\n  }\n  if (array_.isNonEmptyReadonlyArray(out)) {\n    const issues = array_.filterMap(out, (issue) => fromFilterPredicateReturnTypeItem(issue, ast, input))\n    if (array_.isNonEmptyReadonlyArray(issues)) {\n      return option_.some(issues.length === 1 ? issues[0] : new ParseResult.Composite(ast, input, issues))\n    }\n  }\n  return option_.none()\n}\n\n/**\n * @category filtering\n * @since 3.10.0\n */\nexport interface FilterIssue {\n  readonly path: ReadonlyArray<PropertyKey>\n  readonly message: string\n}\n\n/**\n * @category filtering\n * @since 3.10.0\n */\nexport type FilterOutput = undefined | boolean | string | ParseResult.ParseIssue | FilterIssue\n\ntype FilterReturnType = FilterOutput | ReadonlyArray<FilterOutput>\n\n/**\n * @category filtering\n * @since 3.10.0\n */\nexport function filter<C extends A, B extends A, A = C>(\n  refinement: (a: A, options: ParseOptions, self: AST.Refinement) => a is B,\n  annotations?: Annotations.Filter<C & B, C>\n): <I, R>(self: Schema<C, I, R>) => refine<C & B, Schema<A, I, R>>\nexport function filter<A, B extends A>(\n  refinement: (a: A, options: ParseOptions, self: AST.Refinement) => a is B,\n  annotations?: Annotations.Filter<B, A>\n): <I, R>(self: Schema<A, I, R>) => refine<B, Schema<A, I, R>>\nexport function filter<S extends Schema.Any>(\n  predicate: (\n    a: Types.NoInfer<Schema.Type<S>>,\n    options: ParseOptions,\n    self: AST.Refinement\n  ) => FilterReturnType,\n  annotations?: Annotations.Filter<Types.NoInfer<Schema.Type<S>>>\n): (self: S) => filter<S>\nexport function filter<A>(\n  predicate: (\n    a: A,\n    options: ParseOptions,\n    self: AST.Refinement\n  ) => FilterReturnType,\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => refine<A, Schema<A, I, R>> {\n  return <I, R>(self: Schema<A, I, R>) => {\n    function filter(input: A, options: AST.ParseOptions, ast: AST.Refinement) {\n      return toFilterParseIssue(predicate(input, options, ast), ast, input)\n    }\n    const ast = new AST.Refinement(\n      self.ast,\n      filter,\n      toASTAnnotations(annotations)\n    )\n    return makeRefineClass(self, filter, ast)\n  }\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface filterEffect<S extends Schema.Any, FD = never>\n  extends transformOrFail<S, SchemaClass<Schema.Type<S>>, FD>\n{}\n\n/**\n * @category transformations\n * @since 3.10.0\n */\nexport const filterEffect: {\n  /**\n   * @category transformations\n   * @since 3.10.0\n   */\n  <S extends Schema.Any, FD>(\n    f: (\n      a: Types.NoInfer<Schema.Type<S>>,\n      options: ParseOptions,\n      self: AST.Transformation\n    ) => Effect.Effect<FilterReturnType, never, FD>\n  ): (self: S) => filterEffect<S, FD>\n  /**\n   * @category transformations\n   * @since 3.10.0\n   */\n  <S extends Schema.Any, RD>(\n    self: S,\n    f: (\n      a: Types.NoInfer<Schema.Type<S>>,\n      options: ParseOptions,\n      self: AST.Transformation\n    ) => Effect.Effect<FilterReturnType, never, RD>\n  ): filterEffect<S, RD>\n} = dual(2, <S extends Schema.Any, FD>(\n  self: S,\n  f: (\n    a: Types.NoInfer<Schema.Type<S>>,\n    options: ParseOptions,\n    self: AST.Transformation\n  ) => Effect.Effect<FilterReturnType, never, FD>\n): filterEffect<S, FD> =>\n  transformOrFail(\n    self,\n    typeSchema(self),\n    {\n      strict: true,\n      decode: (a, options, ast) =>\n        ParseResult.flatMap(\n          f(a, options, ast),\n          (filterReturnType) =>\n            option_.match(toFilterParseIssue(filterReturnType, ast, a), {\n              onNone: () => ParseResult.succeed(a),\n              onSome: ParseResult.fail\n            })\n        ),\n      encode: ParseResult.succeed\n    }\n  ))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface transformOrFail<From extends Schema.Any, To extends Schema.Any, R = never> extends\n  AnnotableClass<\n    transformOrFail<From, To, R>,\n    Schema.Type<To>,\n    Schema.Encoded<From>,\n    Schema.Context<From> | Schema.Context<To> | R\n  >\n{\n  readonly from: From\n  readonly to: To\n}\n\nconst makeTransformationClass = <From extends Schema.Any, To extends Schema.Any, R>(\n  from: From,\n  to: To,\n  ast: AST.AST\n): transformOrFail<\n  From,\n  To,\n  R\n> => (class TransformationClass\n  extends make<Schema.Type<To>, Schema.Encoded<From>, Schema.Context<From> | Schema.Context<To> | R>(ast)\n{\n  static override annotations(annotations: Annotations.Schema<Schema.Type<To>>) {\n    return makeTransformationClass<From, To, R>(\n      this.from,\n      this.to,\n      mergeSchemaAnnotations(this.ast, annotations)\n    )\n  }\n\n  static from = from\n\n  static to = to\n})\n\n/**\n * Create a new `Schema` by transforming the input and output of an existing `Schema`\n * using the provided decoding functions.\n *\n * @category transformations\n * @since 3.10.0\n */\nexport const transformOrFail: {\n  /**\n   * Create a new `Schema` by transforming the input and output of an existing `Schema`\n   * using the provided decoding functions.\n   *\n   * @category transformations\n   * @since 3.10.0\n   */\n  <To extends Schema.Any, From extends Schema.Any, RD, RE>(\n    to: To,\n    options: {\n      readonly decode: (\n        fromA: Schema.Type<From>,\n        options: ParseOptions,\n        ast: AST.Transformation,\n        fromI: Schema.Encoded<From>\n      ) => Effect.Effect<Schema.Encoded<To>, ParseResult.ParseIssue, RD>\n      readonly encode: (\n        toI: Schema.Encoded<To>,\n        options: ParseOptions,\n        ast: AST.Transformation,\n        toA: Schema.Type<To>\n      ) => Effect.Effect<Schema.Type<From>, ParseResult.ParseIssue, RE>\n      readonly strict?: true\n    } | {\n      readonly decode: (\n        fromA: Schema.Type<From>,\n        options: ParseOptions,\n        ast: AST.Transformation,\n        fromI: Schema.Encoded<From>\n      ) => Effect.Effect<unknown, ParseResult.ParseIssue, RD>\n      readonly encode: (\n        toI: Schema.Encoded<To>,\n        options: ParseOptions,\n        ast: AST.Transformation,\n        toA: Schema.Type<To>\n      ) => Effect.Effect<unknown, ParseResult.ParseIssue, RE>\n      readonly strict: false\n    }\n  ): (from: From) => transformOrFail<From, To, RD | RE>\n  /**\n   * Create a new `Schema` by transforming the input and output of an existing `Schema`\n   * using the provided decoding functions.\n   *\n   * @category transformations\n   * @since 3.10.0\n   */\n  <To extends Schema.Any, From extends Schema.Any, RD, RE>(\n    from: From,\n    to: To,\n    options: {\n      readonly decode: (\n        fromA: Schema.Type<From>,\n        options: ParseOptions,\n        ast: AST.Transformation,\n        fromI: Schema.Encoded<From>\n      ) => Effect.Effect<Schema.Encoded<To>, ParseResult.ParseIssue, RD>\n      readonly encode: (\n        toI: Schema.Encoded<To>,\n        options: ParseOptions,\n        ast: AST.Transformation,\n        toA: Schema.Type<To>\n      ) => Effect.Effect<Schema.Type<From>, ParseResult.ParseIssue, RE>\n      readonly strict?: true\n    } | {\n      readonly decode: (\n        fromA: Schema.Type<From>,\n        options: ParseOptions,\n        ast: AST.Transformation,\n        fromI: Schema.Encoded<From>\n      ) => Effect.Effect<unknown, ParseResult.ParseIssue, RD>\n      readonly encode: (\n        toI: Schema.Encoded<To>,\n        options: ParseOptions,\n        ast: AST.Transformation,\n        toA: Schema.Type<To>\n      ) => Effect.Effect<unknown, ParseResult.ParseIssue, RE>\n      readonly strict: false\n    }\n  ): transformOrFail<From, To, RD | RE>\n} = dual((args) => isSchema(args[0]) && isSchema(args[1]), <FromA, FromI, FromR, ToA, ToI, ToR, RD, RE>(\n  from: Schema<FromA, FromI, FromR>,\n  to: Schema<ToA, ToI, ToR>,\n  options: {\n    readonly decode: (\n      fromA: FromA,\n      options: ParseOptions,\n      ast: AST.Transformation,\n      fromI: FromI\n    ) => Effect.Effect<ToI, ParseResult.ParseIssue, RD>\n    readonly encode: (\n      toI: ToI,\n      options: ParseOptions,\n      ast: AST.Transformation,\n      toA: ToA\n    ) => Effect.Effect<FromA, ParseResult.ParseIssue, RE>\n  }\n): Schema<ToA, FromI, FromR | ToR | RD | RE> =>\n  makeTransformationClass(\n    from,\n    to,\n    new AST.Transformation(\n      from.ast,\n      to.ast,\n      new AST.FinalTransformation(options.decode, options.encode)\n    )\n  ))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface transform<From extends Schema.Any, To extends Schema.Any> extends transformOrFail<From, To> {\n  annotations(annotations: Annotations.Schema<Schema.Type<To>>): transform<From, To>\n}\n\n/**\n * Create a new `Schema` by transforming the input and output of an existing `Schema`\n * using the provided mapping functions.\n *\n * @category transformations\n * @since 3.10.0\n */\nexport const transform: {\n  /**\n   * Create a new `Schema` by transforming the input and output of an existing `Schema`\n   * using the provided mapping functions.\n   *\n   * @category transformations\n   * @since 3.10.0\n   */\n  <To extends Schema.Any, From extends Schema.Any>(\n    to: To,\n    options: {\n      readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => Schema.Encoded<To>\n      readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => Schema.Type<From>\n      readonly strict?: true\n    } | {\n      readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => unknown\n      readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => unknown\n      readonly strict: false\n    }\n  ): (from: From) => transform<From, To>\n  /**\n   * Create a new `Schema` by transforming the input and output of an existing `Schema`\n   * using the provided mapping functions.\n   *\n   * @category transformations\n   * @since 3.10.0\n   */\n  <To extends Schema.Any, From extends Schema.Any>(\n    from: From,\n    to: To,\n    options: {\n      readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => Schema.Encoded<To>\n      readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => Schema.Type<From>\n      readonly strict?: true\n    } | {\n      readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => unknown\n      readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => unknown\n      readonly strict: false\n    }\n  ): transform<From, To>\n} = dual(\n  (args) => isSchema(args[0]) && isSchema(args[1]),\n  <FromA, FromI, FromR, ToA, ToI, ToR>(\n    from: Schema<FromA, FromI, FromR>,\n    to: Schema<ToA, ToI, ToR>,\n    options: {\n      readonly decode: (fromA: FromA, fromI: FromI) => ToI\n      readonly encode: (toI: ToI, toA: ToA) => FromA\n    }\n  ): Schema<ToA, FromI, FromR | ToR> =>\n    transformOrFail(\n      from,\n      to,\n      {\n        strict: true,\n        decode: (fromA, _options, _ast, toA) => ParseResult.succeed(options.decode(fromA, toA)),\n        encode: (toI, _options, _ast, toA) => ParseResult.succeed(options.encode(toI, toA))\n      }\n    )\n)\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface transformLiteral<Type, Encoded> extends Annotable<transformLiteral<Type, Encoded>, Type, Encoded> {}\n\n/**\n * Creates a new `Schema` which transforms literal values.\n *\n * @example\n * ```ts\n * import * as S from \"effect/Schema\"\n *\n * const schema = S.transformLiteral(0, \"a\")\n *\n * assert.deepStrictEqual(S.decodeSync(schema)(0), \"a\")\n * ```\n *\n * @category constructors\n * @since 3.10.0\n */\nexport const transformLiteral = <Encoded extends AST.LiteralValue, Type extends AST.LiteralValue>(\n  from: Encoded,\n  to: Type\n): transformLiteral<Type, Encoded> =>\n  transform(Literal(from), Literal(to), { strict: true, decode: () => to, encode: () => from })\n\n/**\n * Creates a new `Schema` which maps between corresponding literal values.\n *\n * @example\n * ```ts\n * import * as S from \"effect/Schema\"\n *\n * const Animal = S.transformLiterals(\n *   [0, \"cat\"],\n *   [1, \"dog\"],\n *   [2, \"cow\"]\n * )\n *\n * assert.deepStrictEqual(S.decodeSync(Animal)(1), \"dog\")\n * ```\n *\n * @category constructors\n * @since 3.10.0\n */\nexport function transformLiterals<const A extends AST.Members<readonly [from: AST.LiteralValue, to: AST.LiteralValue]>>(\n  ...pairs: A\n): Union<{ -readonly [I in keyof A]: transformLiteral<A[I][1], A[I][0]> }>\nexport function transformLiterals<Encoded extends AST.LiteralValue, Type extends AST.LiteralValue>(\n  pairs: [Encoded, Type]\n): transformLiteral<Type, Encoded>\nexport function transformLiterals<\n  const A extends ReadonlyArray<readonly [from: AST.LiteralValue, to: AST.LiteralValue]>\n>(...pairs: A): Schema<A[number][1], A[number][0]>\nexport function transformLiterals<\n  const A extends ReadonlyArray<readonly [from: AST.LiteralValue, to: AST.LiteralValue]>\n>(...pairs: A): Schema<A[number][1], A[number][0]> {\n  return Union(...pairs.map(([from, to]) => transformLiteral(from, to)))\n}\n\n/**\n * Attaches a property signature with the specified key and value to the schema.\n * This API is useful when you want to add a property to your schema which doesn't describe the shape of the input,\n * but rather maps to another schema, for example when you want to add a discriminant to a simple union.\n *\n * @param self - The input schema.\n * @param key - The name of the property to add to the schema.\n * @param value - The value of the property to add to the schema.\n *\n * @example\n * ```ts\n * import * as S from \"effect/Schema\"\n * import { pipe } from \"effect/Function\"\n *\n * const Circle = S.Struct({ radius: S.Number })\n * const Square = S.Struct({ sideLength: S.Number })\n * const Shape = S.Union(\n *   Circle.pipe(S.attachPropertySignature(\"kind\", \"circle\")),\n *   Square.pipe(S.attachPropertySignature(\"kind\", \"square\"))\n * )\n *\n * assert.deepStrictEqual(S.decodeSync(Shape)({ radius: 10 }), {\n *   kind: \"circle\",\n *   radius: 10\n * })\n * ```\n *\n * @category combinators\n * @since 3.10.0\n */\nexport const attachPropertySignature: {\n  /**\n   * Attaches a property signature with the specified key and value to the schema.\n   * This API is useful when you want to add a property to your schema which doesn't describe the shape of the input,\n   * but rather maps to another schema, for example when you want to add a discriminant to a simple union.\n   *\n   * @param self - The input schema.\n   * @param key - The name of the property to add to the schema.\n   * @param value - The value of the property to add to the schema.\n   *\n   * @example\n   * ```ts\n   * import * as S from \"effect/Schema\"\n   * import { pipe } from \"effect/Function\"\n   *\n   * const Circle = S.Struct({ radius: S.Number })\n   * const Square = S.Struct({ sideLength: S.Number })\n   * const Shape = S.Union(\n   *   Circle.pipe(S.attachPropertySignature(\"kind\", \"circle\")),\n   *   Square.pipe(S.attachPropertySignature(\"kind\", \"square\"))\n   * )\n   *\n   * assert.deepStrictEqual(S.decodeSync(Shape)({ radius: 10 }), {\n   *   kind: \"circle\",\n   *   radius: 10\n   * })\n   * ```\n   *\n   * @category combinators\n   * @since 3.10.0\n   */\n  <K extends PropertyKey, V extends AST.LiteralValue | symbol, A>(\n    key: K,\n    value: V,\n    annotations?: Annotations.Schema<Simplify<A & { readonly [k in K]: V }>>\n  ): <I, R>(\n    schema: SchemaClass<A, I, R>\n  ) => SchemaClass<Simplify<A & { readonly [k in K]: V }>, I, R>\n  /**\n   * Attaches a property signature with the specified key and value to the schema.\n   * This API is useful when you want to add a property to your schema which doesn't describe the shape of the input,\n   * but rather maps to another schema, for example when you want to add a discriminant to a simple union.\n   *\n   * @param self - The input schema.\n   * @param key - The name of the property to add to the schema.\n   * @param value - The value of the property to add to the schema.\n   *\n   * @example\n   * ```ts\n   * import * as S from \"effect/Schema\"\n   * import { pipe } from \"effect/Function\"\n   *\n   * const Circle = S.Struct({ radius: S.Number })\n   * const Square = S.Struct({ sideLength: S.Number })\n   * const Shape = S.Union(\n   *   Circle.pipe(S.attachPropertySignature(\"kind\", \"circle\")),\n   *   Square.pipe(S.attachPropertySignature(\"kind\", \"square\"))\n   * )\n   *\n   * assert.deepStrictEqual(S.decodeSync(Shape)({ radius: 10 }), {\n   *   kind: \"circle\",\n   *   radius: 10\n   * })\n   * ```\n   *\n   * @category combinators\n   * @since 3.10.0\n   */\n  <A, I, R, K extends PropertyKey, V extends AST.LiteralValue | symbol>(\n    schema: Schema<A, I, R>,\n    key: K,\n    value: V,\n    annotations?: Annotations.Schema<Simplify<A & { readonly [k in K]: V }>>\n  ): SchemaClass<Simplify<A & { readonly [k in K]: V }>, I, R>\n} = dual(\n  (args) => isSchema(args[0]),\n  <A, I, R, K extends PropertyKey, V extends AST.LiteralValue | symbol>(\n    schema: Schema<A, I, R>,\n    key: K,\n    value: V,\n    annotations?: Annotations.Schema<Simplify<A & { readonly [k in K]: V }>>\n  ): SchemaClass<Simplify<A & { readonly [k in K]: V }>, I, R> => {\n    const ast = extend(\n      typeSchema(schema),\n      Struct({ [key]: Predicate.isSymbol(value) ? UniqueSymbolFromSelf(value) : Literal(value) })\n    ).ast\n    return make(\n      new AST.Transformation(\n        schema.ast,\n        annotations ? mergeSchemaAnnotations(ast, annotations) : ast,\n        new AST.TypeLiteralTransformation(\n          [\n            new AST.PropertySignatureTransformation(\n              key,\n              key,\n              () => option_.some(value),\n              () => option_.none()\n            )\n          ]\n        )\n      )\n    )\n  }\n)\n\n/**\n * @category annotations\n * @since 3.10.0\n */\nexport declare namespace Annotations {\n  /**\n   * @category annotations\n   * @since 3.10.0\n   */\n  export interface Doc<A> extends AST.Annotations {\n    readonly title?: AST.TitleAnnotation\n    readonly description?: AST.DescriptionAnnotation\n    readonly documentation?: AST.DocumentationAnnotation\n    readonly examples?: AST.ExamplesAnnotation<A>\n    readonly default?: AST.DefaultAnnotation<A>\n  }\n\n  /**\n   * @since 3.10.0\n   */\n  export interface Schema<A, TypeParameters extends ReadonlyArray<any> = readonly []> extends Doc<A> {\n    readonly identifier?: AST.IdentifierAnnotation\n    readonly message?: AST.MessageAnnotation\n    readonly schemaId?: AST.SchemaIdAnnotation\n    readonly jsonSchema?: AST.JSONSchemaAnnotation\n    readonly arbitrary?: ArbitraryAnnotation<A, TypeParameters>\n    readonly pretty?: pretty_.PrettyAnnotation<A, TypeParameters>\n    readonly equivalence?: AST.EquivalenceAnnotation<A, TypeParameters>\n    readonly concurrency?: AST.ConcurrencyAnnotation\n    readonly batching?: AST.BatchingAnnotation\n    readonly parseIssueTitle?: AST.ParseIssueTitleAnnotation\n    readonly parseOptions?: AST.ParseOptions\n    readonly decodingFallback?: AST.DecodingFallbackAnnotation<A>\n  }\n\n  /**\n   * @since 3.11.6\n   */\n  export interface GenericSchema<A> extends Schema<A> {\n    readonly arbitrary?: (..._: any) => LazyArbitrary<A>\n    readonly pretty?: (..._: any) => pretty_.Pretty<A>\n    readonly equivalence?: (..._: any) => Equivalence.Equivalence<A>\n  }\n\n  /**\n   * @since 3.10.0\n   */\n  export interface Filter<A, P = A> extends Schema<A, readonly [P]> {}\n}\n\n/**\n * Merges a set of new annotations with existing ones, potentially overwriting\n * any duplicates.\n *\n * @category annotations\n * @since 3.10.0\n */\nexport const annotations: {\n  /**\n   * Merges a set of new annotations with existing ones, potentially overwriting\n   * any duplicates.\n   *\n   * @category annotations\n   * @since 3.10.0\n   */\n  <S extends Annotable.All>(annotations: Annotations.GenericSchema<Schema.Type<S>>): (self: S) => Annotable.Self<S>\n  /**\n   * Merges a set of new annotations with existing ones, potentially overwriting\n   * any duplicates.\n   *\n   * @category annotations\n   * @since 3.10.0\n   */\n  <S extends Annotable.All>(self: S, annotations: Annotations.GenericSchema<Schema.Type<S>>): Annotable.Self<S>\n} = dual(\n  2,\n  <A, I, R>(self: Schema<A, I, R>, annotations: Annotations.GenericSchema<A>): Schema<A, I, R> =>\n    self.annotations(annotations)\n)\n\ntype Rename<A, M> = {\n  [\n    K in keyof A as K extends keyof M ? M[K] extends PropertyKey ? M[K]\n      : never\n      : K\n  ]: A[K]\n}\n\n/**\n * @category renaming\n * @since 3.10.0\n */\nexport const rename: {\n  /**\n   * @category renaming\n   * @since 3.10.0\n   */\n  <\n    A,\n    const M extends\n      & { readonly [K in keyof A]?: PropertyKey }\n      & { readonly [K in Exclude<keyof M, keyof A>]: never }\n  >(mapping: M): <I, R>(self: Schema<A, I, R>) => SchemaClass<Simplify<Rename<A, M>>, I, R>\n  /**\n   * @category renaming\n   * @since 3.10.0\n   */\n  <\n    A,\n    I,\n    R,\n    const M extends\n      & { readonly [K in keyof A]?: PropertyKey }\n      & { readonly [K in Exclude<keyof M, keyof A>]: never }\n  >(self: Schema<A, I, R>, mapping: M): SchemaClass<Simplify<Rename<A, M>>, I, R>\n} = dual(\n  2,\n  <\n    A,\n    I,\n    R,\n    const M extends\n      & { readonly [K in keyof A]?: PropertyKey }\n      & { readonly [K in Exclude<keyof M, keyof A>]: never }\n  >(\n    self: Schema<A, I, R>,\n    mapping: M\n  ): SchemaClass<Simplify<Rename<A, M>>, I, R> => make(AST.rename(self.ast, mapping))\n)\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const TrimmedSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/Trimmed\")\n\n/**\n * Verifies that a string contains no leading or trailing whitespaces.\n *\n * Note. This combinator does not make any transformations, it only validates.\n * If what you were looking for was a combinator to trim strings, then check out the `trim` combinator.\n *\n * @category string filters\n * @since 3.10.0\n */\nexport const trimmed =\n  <A extends string>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n    self.pipe(\n      filter((a) => a === a.trim(), {\n        schemaId: TrimmedSchemaId,\n        title: \"trimmed\",\n        description: \"a string with no leading or trailing whitespace\",\n        jsonSchema: { pattern: \"^\\\\S[\\\\s\\\\S]*\\\\S$|^\\\\S$|^$\" },\n        ...annotations\n      })\n    )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const MaxLengthSchemaId: unique symbol = schemaId_.MaxLengthSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type MaxLengthSchemaId = typeof MaxLengthSchemaId\n\n/**\n * @category string filters\n * @since 3.10.0\n */\nexport const maxLength = <A extends string>(\n  maxLength: number,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter(\n      (a) => a.length <= maxLength,\n      {\n        schemaId: MaxLengthSchemaId,\n        title: `maxLength(${maxLength})`,\n        description: `a string at most ${maxLength} character(s) long`,\n        jsonSchema: { maxLength },\n        ...annotations\n      }\n    )\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const MinLengthSchemaId: unique symbol = schemaId_.MinLengthSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type MinLengthSchemaId = typeof MinLengthSchemaId\n\n/**\n * @category string filters\n * @since 3.10.0\n */\nexport const minLength = <A extends string>(\n  minLength: number,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter(\n      (a) => a.length >= minLength,\n      {\n        schemaId: MinLengthSchemaId,\n        title: `minLength(${minLength})`,\n        description: `a string at least ${minLength} character(s) long`,\n        jsonSchema: { minLength },\n        ...annotations\n      }\n    )\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const PatternSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/Pattern\")\n\n/**\n * @category string filters\n * @since 3.10.0\n */\nexport const pattern = <A extends string>(\n  regex: RegExp,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> => {\n  const source = regex.source\n  return self.pipe(\n    filter(\n      (a): a is A => {\n        // The following line ensures that `lastIndex` is reset to `0` in case the user has specified the `g` flag\n        regex.lastIndex = 0\n        return regex.test(a)\n      },\n      {\n        schemaId: PatternSchemaId,\n        [PatternSchemaId]: { regex },\n        // title: `pattern(/${source}/)`, // avoiding this because it can be very long\n        description: `a string matching the pattern ${source}`,\n        jsonSchema: { pattern: source },\n        ...annotations\n      }\n    )\n  )\n}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const StartsWithSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/StartsWith\")\n\n/**\n * @category string filters\n * @since 3.10.0\n */\nexport const startsWith = <A extends string>(\n  startsWith: string,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> => {\n  const formatted = JSON.stringify(startsWith)\n  return self.pipe(\n    filter(\n      (a) => a.startsWith(startsWith),\n      {\n        schemaId: StartsWithSchemaId,\n        [StartsWithSchemaId]: { startsWith },\n        title: `startsWith(${formatted})`,\n        description: `a string starting with ${formatted}`,\n        jsonSchema: { pattern: `^${startsWith}` },\n        ...annotations\n      }\n    )\n  )\n}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const EndsWithSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/EndsWith\")\n\n/**\n * @category string filters\n * @since 3.10.0\n */\nexport const endsWith = <A extends string>(\n  endsWith: string,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> => {\n  const formatted = JSON.stringify(endsWith)\n  return self.pipe(\n    filter(\n      (a) => a.endsWith(endsWith),\n      {\n        schemaId: EndsWithSchemaId,\n        [EndsWithSchemaId]: { endsWith },\n        title: `endsWith(${formatted})`,\n        description: `a string ending with ${formatted}`,\n        jsonSchema: { pattern: `^.*${endsWith}$` },\n        ...annotations\n      }\n    )\n  )\n}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const IncludesSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/Includes\")\n\n/**\n * @category string filters\n * @since 3.10.0\n */\nexport const includes = <A extends string>(\n  searchString: string,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> => {\n  const formatted = JSON.stringify(searchString)\n  return self.pipe(\n    filter(\n      (a) => a.includes(searchString),\n      {\n        schemaId: IncludesSchemaId,\n        [IncludesSchemaId]: { includes: searchString },\n        title: `includes(${formatted})`,\n        description: `a string including ${formatted}`,\n        jsonSchema: { pattern: `.*${searchString}.*` },\n        ...annotations\n      }\n    )\n  )\n}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LowercasedSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/Lowercased\")\n\n/**\n * Verifies that a string is lowercased.\n *\n * @category string filters\n * @since 3.10.0\n */\nexport const lowercased =\n  <A extends string>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n    self.pipe(\n      filter((a) => a === a.toLowerCase(), {\n        schemaId: LowercasedSchemaId,\n        title: \"lowercased\",\n        description: \"a lowercase string\",\n        jsonSchema: { pattern: \"^[^A-Z]*$\" },\n        ...annotations\n      })\n    )\n\n/**\n * @category string constructors\n * @since 3.10.0\n */\nexport class Lowercased extends String$.pipe(\n  lowercased({ identifier: \"Lowercased\" })\n) {}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const CapitalizedSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/Capitalized\")\n\n/**\n * Verifies that a string is capitalized.\n *\n * @category string filters\n * @since 3.10.0\n */\nexport const capitalized =\n  <A extends string>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n    self.pipe(\n      filter((a) => a[0]?.toUpperCase() === a[0], {\n        schemaId: CapitalizedSchemaId,\n        title: \"capitalized\",\n        description: \"a capitalized string\",\n        jsonSchema: { pattern: \"^[^a-z]?.*$\" },\n        ...annotations\n      })\n    )\n\n/**\n * @category string constructors\n * @since 3.10.0\n */\nexport class Capitalized extends String$.pipe(\n  capitalized({ identifier: \"Capitalized\" })\n) {}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const UncapitalizedSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/Uncapitalized\")\n\n/**\n * Verifies that a string is uncapitalized.\n *\n * @category string filters\n * @since 3.10.0\n */\nexport const uncapitalized =\n  <A extends string>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n    self.pipe(\n      filter((a) => a[0]?.toLowerCase() === a[0], {\n        schemaId: UncapitalizedSchemaId,\n        title: \"uncapitalized\",\n        description: \"a uncapitalized string\",\n        jsonSchema: { pattern: \"^[^A-Z]?.*$\" },\n        ...annotations\n      })\n    )\n\n/**\n * @category string constructors\n * @since 3.10.0\n */\nexport class Uncapitalized extends String$.pipe(\n  uncapitalized({ identifier: \"Uncapitalized\" })\n) {}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const UppercasedSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/Uppercased\")\n\n/**\n * Verifies that a string is uppercased.\n *\n * @category string filters\n * @since 3.10.0\n */\nexport const uppercased =\n  <A extends string>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n    self.pipe(\n      filter((a) => a === a.toUpperCase(), {\n        schemaId: UppercasedSchemaId,\n        title: \"uppercased\",\n        description: \"an uppercase string\",\n        jsonSchema: { pattern: \"^[^a-z]*$\" },\n        ...annotations\n      })\n    )\n\n/**\n * @category string constructors\n * @since 3.10.0\n */\nexport class Uppercased extends String$.pipe(\n  uppercased({ identifier: \"Uppercased\" })\n) {}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LengthSchemaId: unique symbol = schemaId_.LengthSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type LengthSchemaId = typeof LengthSchemaId\n\n/**\n * @category string filters\n * @since 3.10.0\n */\nexport const length = <A extends string>(\n  length: number | { readonly min: number; readonly max: number },\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> => {\n  const minLength = Predicate.isObject(length) ? Math.max(0, Math.floor(length.min)) : Math.max(0, Math.floor(length))\n  const maxLength = Predicate.isObject(length) ? Math.max(minLength, Math.floor(length.max)) : minLength\n  if (minLength !== maxLength) {\n    return self.pipe(\n      filter((a) => a.length >= minLength && a.length <= maxLength, {\n        schemaId: LengthSchemaId,\n        title: `length({ min: ${minLength}, max: ${maxLength})`,\n        description: `a string at least ${minLength} character(s) and at most ${maxLength} character(s) long`,\n        jsonSchema: { minLength, maxLength },\n        ...annotations\n      })\n    )\n  }\n  return self.pipe(\n    filter((a) => a.length === minLength, {\n      schemaId: LengthSchemaId,\n      title: `length(${minLength})`,\n      description: minLength === 1 ? `a single character` : `a string ${minLength} character(s) long`,\n      jsonSchema: { minLength, maxLength: minLength },\n      ...annotations\n    })\n  )\n}\n\n/**\n * A schema representing a single character.\n *\n * @category string constructors\n * @since 3.10.0\n */\nexport class Char extends String$.pipe(length(1, { identifier: \"Char\" })) {}\n\n/**\n * @category string filters\n * @since 3.10.0\n */\nexport const nonEmptyString = <A extends string>(\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>> =>\n  minLength(1, {\n    title: \"nonEmptyString\",\n    description: \"a non empty string\",\n    ...annotations\n  })\n\n/**\n * This schema converts a string to lowercase.\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport class Lowercase extends transform(\n  String$.annotations({ description: \"a string that will be converted to lowercase\" }),\n  Lowercased,\n  { strict: true, decode: (s) => s.toLowerCase(), encode: identity }\n).annotations({ identifier: \"Lowercase\" }) {}\n\n/**\n * This schema converts a string to uppercase.\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport class Uppercase extends transform(\n  String$.annotations({ description: \"a string that will be converted to uppercase\" }),\n  Uppercased,\n  { strict: true, decode: (s) => s.toUpperCase(), encode: identity }\n).annotations({ identifier: \"Uppercase\" }) {}\n\n/**\n * This schema converts a string to capitalized one.\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport class Capitalize extends transform(\n  String$.annotations({ description: \"a string that will be converted to a capitalized format\" }),\n  Capitalized,\n  { strict: true, decode: (s) => string_.capitalize(s), encode: identity }\n).annotations({ identifier: \"Capitalize\" }) {}\n\n/**\n * This schema converts a string to uncapitalized one.\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport class Uncapitalize extends transform(\n  String$.annotations({ description: \"a string that will be converted to an uncapitalized format\" }),\n  Uncapitalized,\n  { strict: true, decode: (s) => string_.uncapitalize(s), encode: identity }\n).annotations({ identifier: \"Uncapitalize\" }) {}\n\n/**\n * @category string constructors\n * @since 3.10.0\n */\nexport class Trimmed extends String$.pipe(\n  trimmed({ identifier: \"Trimmed\" })\n) {}\n\n/**\n * Useful for validating strings that must contain meaningful characters without\n * leading or trailing whitespace.\n *\n * @example\n * ```ts\n * import { Schema } from \"effect\"\n *\n * console.log(Schema.decodeOption(Schema.NonEmptyTrimmedString)(\"\")) // Option.none()\n * console.log(Schema.decodeOption(Schema.NonEmptyTrimmedString)(\" a \")) // Option.none()\n * console.log(Schema.decodeOption(Schema.NonEmptyTrimmedString)(\"a\")) // Option.some(\"a\")\n * ```\n *\n * @category string constructors\n * @since 3.10.0\n */\nexport class NonEmptyTrimmedString extends Trimmed.pipe(\n  nonEmptyString({ identifier: \"NonEmptyTrimmedString\" })\n) {}\n\n/**\n * This schema allows removing whitespaces from the beginning and end of a string.\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport class Trim extends transform(\n  String$.annotations({ description: \"a string that will be trimmed\" }),\n  Trimmed,\n  { strict: true, decode: (s) => s.trim(), encode: identity }\n).annotations({ identifier: \"Trim\" }) {}\n\n/**\n * Returns a schema that allows splitting a string into an array of strings.\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport const split = (separator: string): transform<typeof String$, Array$<typeof String$>> =>\n  transform(\n    String$.annotations({ description: \"a string that will be split\" }),\n    Array$(String$),\n    { strict: true, decode: string_.split(separator), encode: array_.join(separator) }\n  )\n\n/**\n * @since 3.10.0\n */\nexport type ParseJsonOptions = {\n  readonly reviver?: Parameters<typeof JSON.parse>[1]\n  readonly replacer?: Parameters<typeof JSON.stringify>[1]\n  readonly space?: Parameters<typeof JSON.stringify>[2]\n}\n\nconst JsonString = String$.annotations({\n  [AST.IdentifierAnnotationId]: \"JsonString\",\n  [AST.TitleAnnotationId]: \"JsonString\",\n  [AST.DescriptionAnnotationId]: \"a string that will be parsed as JSON\"\n})\n\nconst getParseJsonTransformation = (options?: ParseJsonOptions) =>\n  transformOrFail(\n    JsonString,\n    Unknown,\n    {\n      strict: true,\n      decode: (s, _, ast) =>\n        ParseResult.try({\n          try: () => JSON.parse(s, options?.reviver),\n          catch: (e: any) => new ParseResult.Type(ast, s, e.message)\n        }),\n      encode: (u, _, ast) =>\n        ParseResult.try({\n          try: () => JSON.stringify(u, options?.replacer, options?.space),\n          catch: (e: any) => new ParseResult.Type(ast, u, e.message)\n        })\n    }\n  ).annotations({ schemaId: AST.ParseJsonSchemaId })\n\n/**\n * The `ParseJson` combinator provides a method to convert JSON strings into the `unknown` type using the underlying\n * functionality of `JSON.parse`. It also utilizes `JSON.stringify` for encoding.\n *\n * You can optionally provide a `ParseJsonOptions` to configure both `JSON.parse` and `JSON.stringify` executions.\n *\n * Optionally, you can pass a schema `Schema<A, I, R>` to obtain an `A` type instead of `unknown`.\n *\n * @example\n * ```ts\n * import * as Schema from \"effect/Schema\"\n *\n * assert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson())(`{\"a\":\"1\"}`), { a: \"1\" })\n * assert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson(Schema.Struct({ a: Schema.NumberFromString })))(`{\"a\":\"1\"}`), { a: 1 })\n * ```\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport const parseJson: {\n  /**\n   * The `ParseJson` combinator provides a method to convert JSON strings into the `unknown` type using the underlying\n   * functionality of `JSON.parse`. It also utilizes `JSON.stringify` for encoding.\n   *\n   * You can optionally provide a `ParseJsonOptions` to configure both `JSON.parse` and `JSON.stringify` executions.\n   *\n   * Optionally, you can pass a schema `Schema<A, I, R>` to obtain an `A` type instead of `unknown`.\n   *\n   * @example\n   * ```ts\n   * import * as Schema from \"effect/Schema\"\n   *\n   * assert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson())(`{\"a\":\"1\"}`), { a: \"1\" })\n   * assert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson(Schema.Struct({ a: Schema.NumberFromString })))(`{\"a\":\"1\"}`), { a: 1 })\n   * ```\n   *\n   * @category string transformations\n   * @since 3.10.0\n   */\n  <A, I, R>(schema: Schema<A, I, R>, options?: ParseJsonOptions): SchemaClass<A, string, R>\n  /**\n   * The `ParseJson` combinator provides a method to convert JSON strings into the `unknown` type using the underlying\n   * functionality of `JSON.parse`. It also utilizes `JSON.stringify` for encoding.\n   *\n   * You can optionally provide a `ParseJsonOptions` to configure both `JSON.parse` and `JSON.stringify` executions.\n   *\n   * Optionally, you can pass a schema `Schema<A, I, R>` to obtain an `A` type instead of `unknown`.\n   *\n   * @example\n   * ```ts\n   * import * as Schema from \"effect/Schema\"\n   *\n   * assert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson())(`{\"a\":\"1\"}`), { a: \"1\" })\n   * assert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson(Schema.Struct({ a: Schema.NumberFromString })))(`{\"a\":\"1\"}`), { a: 1 })\n   * ```\n   *\n   * @category string transformations\n   * @since 3.10.0\n   */\n  (options?: ParseJsonOptions): SchemaClass<unknown, string>\n} = <A, I, R>(schemaOrOptions?: Schema<A, I, R> | ParseJsonOptions, o?: ParseJsonOptions) =>\n  isSchema(schemaOrOptions)\n    ? compose(parseJson(o), schemaOrOptions) as any\n    : getParseJsonTransformation(schemaOrOptions as ParseJsonOptions | undefined)\n\n/**\n * @category string constructors\n * @since 3.10.0\n */\nexport class NonEmptyString extends String$.pipe(\n  nonEmptyString({ identifier: \"NonEmptyString\" })\n) {}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const UUIDSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/UUID\")\n\nconst uuidRegexp = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i\n\n/**\n * Represents a Universally Unique Identifier (UUID).\n *\n * This schema ensures that the provided string adheres to the standard UUID format.\n *\n * @category string constructors\n * @since 3.10.0\n */\nexport class UUID extends String$.pipe(\n  pattern(uuidRegexp, {\n    schemaId: UUIDSchemaId,\n    identifier: \"UUID\",\n    jsonSchema: {\n      format: \"uuid\",\n      pattern: uuidRegexp.source\n    },\n    description: \"a Universally Unique Identifier\",\n    arbitrary: (): LazyArbitrary<string> => (fc) => fc.uuid()\n  })\n) {}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const ULIDSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/ULID\")\n\nconst ulidRegexp = /^[0-7][0-9A-HJKMNP-TV-Z]{25}$/i\n\n/**\n * Represents a Universally Unique Lexicographically Sortable Identifier (ULID).\n *\n * ULIDs are designed to be compact, URL-safe, and ordered, making them suitable for use as identifiers.\n * This schema ensures that the provided string adheres to the standard ULID format.\n *\n * @category string constructors\n * @since 3.10.0\n */\nexport class ULID extends String$.pipe(\n  pattern(ulidRegexp, {\n    schemaId: ULIDSchemaId,\n    identifier: \"ULID\",\n    description: \"a Universally Unique Lexicographically Sortable Identifier\",\n    arbitrary: (): LazyArbitrary<string> => (fc) => fc.ulid()\n  })\n) {}\n\n/**\n * Defines a schema that represents a `URL` object.\n *\n * @category URL constructors\n * @since 3.11.0\n */\nexport class URLFromSelf extends instanceOf(URL, {\n  identifier: \"URLFromSelf\",\n  arbitrary: (): LazyArbitrary<URL> => (fc) => fc.webUrl().map((s) => new URL(s)),\n  pretty: () => (url) => url.toString()\n}) {}\n\n/** @ignore */\nclass URL$ extends transformOrFail(\n  String$.annotations({ description: \"a string that will be parsed into a URL\" }),\n  URLFromSelf,\n  {\n    strict: true,\n    decode: (str, _, ast) =>\n      ParseResult.try({\n        try: () => new URL(str),\n        catch: () => new ParseResult.Type(ast, str)\n      }),\n    encode: (url) => ParseResult.succeed(url.toString())\n  }\n).annotations({\n  identifier: \"URL\",\n  pretty: () => (url) => url.toString()\n}) {}\n\nexport {\n  /**\n   * Defines a schema that attempts to convert a `string` to a `URL` object using\n   * the `new URL` constructor.\n   *\n   * @category URL transformations\n   * @since 3.11.0\n   */\n  URL$ as URL\n}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const FiniteSchemaId: unique symbol = schemaId_.FiniteSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type FiniteSchemaId = typeof FiniteSchemaId\n\n/**\n * Ensures that the provided value is a finite number (excluding NaN, +Infinity, and -Infinity).\n *\n * @category number filters\n * @since 3.10.0\n */\nexport const finite =\n  <A extends number>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n    self.pipe(\n      filter(Number.isFinite, {\n        schemaId: FiniteSchemaId,\n        title: \"finite\",\n        description: \"a finite number\",\n        jsonSchema: { \"type\": \"number\" },\n        ...annotations\n      })\n    )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanSchemaId: unique symbol = schemaId_.GreaterThanSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type GreaterThanSchemaId = typeof GreaterThanSchemaId\n\n/**\n * This filter checks whether the provided number is greater than the specified minimum.\n *\n * @category number filters\n * @since 3.10.0\n */\nexport const greaterThan = <A extends number>(\n  exclusiveMinimum: number,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a > exclusiveMinimum, {\n      schemaId: GreaterThanSchemaId,\n      title: `greaterThan(${exclusiveMinimum})`,\n      description: exclusiveMinimum === 0 ? \"a positive number\" : `a number greater than ${exclusiveMinimum}`,\n      jsonSchema: { exclusiveMinimum },\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanOrEqualToSchemaId: unique symbol = schemaId_.GreaterThanOrEqualToSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type GreaterThanOrEqualToSchemaId = typeof GreaterThanOrEqualToSchemaId\n\n/**\n * This filter checks whether the provided number is greater than or equal to the specified minimum.\n *\n * @category number filters\n * @since 3.10.0\n */\nexport const greaterThanOrEqualTo = <A extends number>(\n  minimum: number,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a >= minimum, {\n      schemaId: GreaterThanOrEqualToSchemaId,\n      title: `greaterThanOrEqualTo(${minimum})`,\n      description: minimum === 0 ? \"a non-negative number\" : `a number greater than or equal to ${minimum}`,\n      jsonSchema: { minimum },\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const MultipleOfSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/MultipleOf\")\n\n/**\n * @category number filters\n * @since 3.10.0\n */\nexport const multipleOf = <A extends number>(\n  divisor: number,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> => {\n  const positiveDivisor = Math.abs(divisor) // spec requires positive divisor\n  return self.pipe(\n    filter((a) => number_.remainder(a, divisor) === 0, {\n      schemaId: MultipleOfSchemaId,\n      title: `multipleOf(${positiveDivisor})`,\n      description: `a number divisible by ${positiveDivisor}`,\n      jsonSchema: { multipleOf: positiveDivisor },\n      ...annotations\n    })\n  )\n}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const IntSchemaId: unique symbol = schemaId_.IntSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type IntSchemaId = typeof IntSchemaId\n\n/**\n * Ensures that the provided value is an integer number (excluding NaN, +Infinity, and -Infinity).\n *\n * @category number filters\n * @since 3.10.0\n */\nexport const int =\n  <A extends number>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n    self.pipe(\n      filter((a) => Number.isSafeInteger(a), {\n        schemaId: IntSchemaId,\n        title: \"int\",\n        description: \"an integer\",\n        jsonSchema: { type: \"integer\" },\n        ...annotations\n      })\n    )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanSchemaId: unique symbol = schemaId_.LessThanSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type LessThanSchemaId = typeof LessThanSchemaId\n\n/**\n * This filter checks whether the provided number is less than the specified maximum.\n *\n * @category number filters\n * @since 3.10.0\n */\nexport const lessThan =\n  <A extends number>(exclusiveMaximum: number, annotations?: Annotations.Filter<A>) =>\n  <I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n    self.pipe(\n      filter((a) => a < exclusiveMaximum, {\n        schemaId: LessThanSchemaId,\n        title: `lessThan(${exclusiveMaximum})`,\n        description: exclusiveMaximum === 0 ? \"a negative number\" : `a number less than ${exclusiveMaximum}`,\n        jsonSchema: { exclusiveMaximum },\n        ...annotations\n      })\n    )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanOrEqualToSchemaId: unique symbol = schemaId_.LessThanOrEqualToSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type LessThanOrEqualToSchemaId = typeof LessThanOrEqualToSchemaId\n\n/**\n * This schema checks whether the provided number is less than or equal to the specified maximum.\n *\n * @category number filters\n * @since 3.10.0\n */\nexport const lessThanOrEqualTo = <A extends number>(\n  maximum: number,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a <= maximum, {\n      schemaId: LessThanOrEqualToSchemaId,\n      title: `lessThanOrEqualTo(${maximum})`,\n      description: maximum === 0 ? \"a non-positive number\" : `a number less than or equal to ${maximum}`,\n      jsonSchema: { maximum },\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const BetweenSchemaId: unique symbol = schemaId_.BetweenSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type BetweenSchemaId = typeof BetweenSchemaId\n\n/**\n * This filter checks whether the provided number falls within the specified minimum and maximum values.\n *\n * @category number filters\n * @since 3.10.0\n */\nexport const between = <A extends number>(\n  minimum: number,\n  maximum: number,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a >= minimum && a <= maximum, {\n      schemaId: BetweenSchemaId,\n      title: `between(${minimum}, ${maximum})`,\n      description: `a number between ${minimum} and ${maximum}`,\n      jsonSchema: { minimum, maximum },\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const NonNaNSchemaId: unique symbol = schemaId_.NonNaNSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type NonNaNSchemaId = typeof NonNaNSchemaId\n\n/**\n * @category number filters\n * @since 3.10.0\n */\nexport const nonNaN =\n  <A extends number>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n    self.pipe(\n      filter((a) => !Number.isNaN(a), {\n        schemaId: NonNaNSchemaId,\n        title: \"nonNaN\",\n        description: \"a number excluding NaN\",\n        ...annotations\n      })\n    )\n\n/**\n * @category number filters\n * @since 3.10.0\n */\nexport const positive = <A extends number>(\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>> => greaterThan(0, { title: \"positive\", ...annotations })\n\n/**\n * @category number filters\n * @since 3.10.0\n */\nexport const negative = <A extends number>(\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>> => lessThan(0, { title: \"negative\", ...annotations })\n\n/**\n * @category number filters\n * @since 3.10.0\n */\nexport const nonPositive = <A extends number>(\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>> =>\n  lessThanOrEqualTo(0, { title: \"nonPositive\", ...annotations })\n\n/**\n * @category number filters\n * @since 3.10.0\n */\nexport const nonNegative = <A extends number>(\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>> =>\n  greaterThanOrEqualTo(0, { title: \"nonNegative\", ...annotations })\n\n/**\n * Clamps a number between a minimum and a maximum value.\n *\n * @category number transformations\n * @since 3.10.0\n */\nexport const clamp =\n  (minimum: number, maximum: number) =>\n  <A extends number, I, R>(self: Schema<A, I, R>): transform<Schema<A, I, R>, filter<Schema<A>>> =>\n    transform(\n      self,\n      self.pipe(typeSchema, between(minimum, maximum)),\n      { strict: false, decode: (self) => number_.clamp(self, { minimum, maximum }), encode: identity }\n    )\n\n/**\n * Transforms a `string` into a `number` by parsing the string using the `parse` function of the `effect/Number` module.\n *\n * It returns an error if the value can't be converted (for example when non-numeric characters are provided).\n *\n * The following special string values are supported: \"NaN\", \"Infinity\", \"-Infinity\".\n *\n * @category number transformations\n * @since 3.10.0\n */\nexport const parseNumber = <A extends string, I, R>(\n  self: Schema<A, I, R>\n): transformOrFail<Schema<A, I, R>, typeof Number$> =>\n  transformOrFail(\n    self,\n    Number$,\n    {\n      strict: false,\n      decode: (s, _, ast) => ParseResult.fromOption(number_.parse(s), () => new ParseResult.Type(ast, s)),\n      encode: (n) => ParseResult.succeed(String(n))\n    }\n  )\n\n/**\n * This schema transforms a `string` into a `number` by parsing the string using the `parse` function of the `effect/Number` module.\n *\n * It returns an error if the value can't be converted (for example when non-numeric characters are provided).\n *\n * The following special string values are supported: \"NaN\", \"Infinity\", \"-Infinity\".\n *\n * @category number transformations\n * @since 3.10.0\n */\nexport class NumberFromString extends parseNumber(String$.annotations({\n  description: \"a string that will be parsed into a number\"\n})).annotations({ identifier: \"NumberFromString\" }) {}\n\n/**\n * @category number constructors\n * @since 3.10.0\n */\nexport class Finite extends Number$.pipe(finite({ identifier: \"Finite\" })) {}\n\n/**\n * @category number constructors\n * @since 3.10.0\n */\nexport class Int extends Number$.pipe(int({ identifier: \"Int\" })) {}\n\n/**\n * @category number constructors\n * @since 3.10.0\n */\nexport class NonNaN extends Number$.pipe(nonNaN({ identifier: \"NonNaN\" })) {}\n\n/**\n * @category number constructors\n * @since 3.10.0\n */\nexport class Positive extends Number$.pipe(\n  positive({ identifier: \"Positive\" })\n) {}\n\n/**\n * @category number constructors\n * @since 3.10.0\n */\nexport class Negative extends Number$.pipe(\n  negative({ identifier: \"Negative\" })\n) {}\n\n/**\n * @category number constructors\n * @since 3.10.0\n */\nexport class NonPositive extends Number$.pipe(\n  nonPositive({ identifier: \"NonPositive\" })\n) {}\n\n/**\n * @category number constructors\n * @since 3.10.0\n */\nexport class NonNegative extends Number$.pipe(\n  nonNegative({ identifier: \"NonNegative\" })\n) {}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const JsonNumberSchemaId: unique symbol = schemaId_.JsonNumberSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type JsonNumberSchemaId = typeof JsonNumberSchemaId\n\n/**\n * The `JsonNumber` is a schema for representing JSON numbers. It ensures that the provided value is a valid\n * number by filtering out `NaN` and `(+/-) Infinity`. This is useful when you want to validate and represent numbers in JSON\n * format.\n *\n * @example\n * ```ts\n * import * as Schema from \"effect/Schema\"\n *\n * const is = Schema.is(S.JsonNumber)\n *\n * assert.deepStrictEqual(is(42), true)\n * assert.deepStrictEqual(is(Number.NaN), false)\n * assert.deepStrictEqual(is(Number.POSITIVE_INFINITY), false)\n * assert.deepStrictEqual(is(Number.NEGATIVE_INFINITY), false)\n * ```\n *\n * @category number constructors\n * @since 3.10.0\n */\nexport class JsonNumber extends Number$.pipe(\n  finite({\n    schemaId: JsonNumberSchemaId,\n    identifier: \"JsonNumber\"\n  })\n) {}\n\n/**\n * @category boolean transformations\n * @since 3.10.0\n */\nexport class Not extends transform(Boolean$.annotations({ description: \"a boolean that will be negated\" }), Boolean$, {\n  strict: true,\n  decode: boolean_.not,\n  encode: boolean_.not\n}) {}\n\n/** @ignore */\nclass Symbol$ extends transform(\n  String$.annotations({ description: \"a string that will be converted to a symbol\" }),\n  SymbolFromSelf,\n  { strict: false, decode: (s) => Symbol.for(s), encode: (sym) => sym.description }\n).annotations({ identifier: \"symbol\" }) {}\n\nexport {\n  /**\n   * This schema transforms a `string` into a `symbol`.\n   *\n   * @category symbol transformations\n   * @since 3.10.0\n   */\n  Symbol$ as Symbol\n}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanBigIntSchemaId: unique symbol = schemaId_.GreaterThanBigintSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type GreaterThanBigIntSchemaId = typeof GreaterThanBigIntSchemaId\n\n/**\n * @category bigint filters\n * @since 3.10.0\n */\nexport const greaterThanBigInt = <A extends bigint>(\n  min: bigint,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a > min, {\n      schemaId: GreaterThanBigIntSchemaId,\n      [GreaterThanBigIntSchemaId]: { min },\n      title: `greaterThanBigInt(${min})`,\n      description: min === 0n ? \"a positive bigint\" : `a bigint greater than ${min}n`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanOrEqualToBigIntSchemaId: unique symbol = schemaId_.GreaterThanOrEqualToBigIntSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type GreaterThanOrEqualToBigIntSchemaId = typeof GreaterThanOrEqualToBigIntSchemaId\n\n/**\n * @category bigint filters\n * @since 3.10.0\n */\nexport const greaterThanOrEqualToBigInt = <A extends bigint>(\n  min: bigint,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a >= min, {\n      schemaId: GreaterThanOrEqualToBigIntSchemaId,\n      [GreaterThanOrEqualToBigIntSchemaId]: { min },\n      title: `greaterThanOrEqualToBigInt(${min})`,\n      description: min === 0n\n        ? \"a non-negative bigint\"\n        : `a bigint greater than or equal to ${min}n`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanBigIntSchemaId: unique symbol = schemaId_.LessThanBigIntSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type LessThanBigIntSchemaId = typeof LessThanBigIntSchemaId\n\n/**\n * @category bigint filters\n * @since 3.10.0\n */\nexport const lessThanBigInt = <A extends bigint>(\n  max: bigint,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a < max, {\n      schemaId: LessThanBigIntSchemaId,\n      [LessThanBigIntSchemaId]: { max },\n      title: `lessThanBigInt(${max})`,\n      description: max === 0n ? \"a negative bigint\" : `a bigint less than ${max}n`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanOrEqualToBigIntSchemaId: unique symbol = schemaId_.LessThanOrEqualToBigIntSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type LessThanOrEqualToBigIntSchemaId = typeof LessThanOrEqualToBigIntSchemaId\n\n/**\n * @category bigint filters\n * @since 3.10.0\n */\nexport const lessThanOrEqualToBigInt = <A extends bigint>(\n  max: bigint,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a <= max, {\n      schemaId: LessThanOrEqualToBigIntSchemaId,\n      [LessThanOrEqualToBigIntSchemaId]: { max },\n      title: `lessThanOrEqualToBigInt(${max})`,\n      description: max === 0n ? \"a non-positive bigint\" : `a bigint less than or equal to ${max}n`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const BetweenBigIntSchemaId: unique symbol = schemaId_.BetweenBigintSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type BetweenBigIntSchemaId = typeof BetweenBigIntSchemaId\n\n/**\n * @category bigint filters\n * @since 3.10.0\n */\nexport const betweenBigInt = <A extends bigint>(\n  min: bigint,\n  max: bigint,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a >= min && a <= max, {\n      schemaId: BetweenBigIntSchemaId,\n      [BetweenBigIntSchemaId]: { min, max },\n      title: `betweenBigInt(${min}, ${max})`,\n      description: `a bigint between ${min}n and ${max}n`,\n      ...annotations\n    })\n  )\n\n/**\n * @category bigint filters\n * @since 3.10.0\n */\nexport const positiveBigInt = <A extends bigint>(\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>> =>\n  greaterThanBigInt(0n, { title: \"positiveBigInt\", ...annotations })\n\n/**\n * @category bigint filters\n * @since 3.10.0\n */\nexport const negativeBigInt = <A extends bigint>(\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>> =>\n  lessThanBigInt(0n, { title: \"negativeBigInt\", ...annotations })\n\n/**\n * @category bigint filters\n * @since 3.10.0\n */\nexport const nonNegativeBigInt = <A extends bigint>(\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>> =>\n  greaterThanOrEqualToBigInt(0n, { title: \"nonNegativeBigInt\", ...annotations })\n\n/**\n * @category bigint filters\n * @since 3.10.0\n */\nexport const nonPositiveBigInt = <A extends bigint>(\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>> =>\n  lessThanOrEqualToBigInt(0n, { title: \"nonPositiveBigInt\", ...annotations })\n\n/**\n * Clamps a bigint between a minimum and a maximum value.\n *\n * @category bigint transformations\n * @since 3.10.0\n */\nexport const clampBigInt =\n  (minimum: bigint, maximum: bigint) =>\n  <A extends bigint, I, R>(self: Schema<A, I, R>): transform<Schema<A, I, R>, filter<Schema<A>>> =>\n    transform(\n      self,\n      self.pipe(typeSchema, betweenBigInt(minimum, maximum)),\n      { strict: false, decode: (self) => bigInt_.clamp(self, { minimum, maximum }), encode: identity }\n    )\n\n/** @ignore */\nclass BigInt$ extends transformOrFail(\n  String$.annotations({ description: \"a string that will be parsed into a bigint\" }),\n  BigIntFromSelf,\n  {\n    strict: true,\n    decode: (s, _, ast) => ParseResult.fromOption(bigInt_.fromString(s), () => new ParseResult.Type(ast, s)),\n    encode: (n) => ParseResult.succeed(String(n))\n  }\n).annotations({ identifier: \"bigint\" }) {}\n\nexport {\n  /**\n   * This schema transforms a `string` into a `bigint` by parsing the string using the `BigInt` function.\n   *\n   * It returns an error if the value can't be converted (for example when non-numeric characters are provided).\n   *\n   * @category bigint transformations\n   * @since 3.10.0\n   */\n  BigInt$ as BigInt\n}\n\n/**\n * @category bigint constructors\n * @since 3.10.0\n */\nexport const PositiveBigIntFromSelf: filter<Schema<bigint>> = BigIntFromSelf.pipe(\n  positiveBigInt({ identifier: \"PositiveBigintFromSelf\" })\n)\n\n/**\n * @category bigint constructors\n * @since 3.10.0\n */\nexport const PositiveBigInt: filter<Schema<bigint, string>> = BigInt$.pipe(\n  positiveBigInt({ identifier: \"PositiveBigint\" })\n)\n\n/**\n * @category bigint constructors\n * @since 3.10.0\n */\nexport const NegativeBigIntFromSelf: filter<Schema<bigint>> = BigIntFromSelf.pipe(\n  negativeBigInt({ identifier: \"NegativeBigintFromSelf\" })\n)\n\n/**\n * @category bigint constructors\n * @since 3.10.0\n */\nexport const NegativeBigInt: filter<Schema<bigint, string>> = BigInt$.pipe(\n  negativeBigInt({ identifier: \"NegativeBigint\" })\n)\n\n/**\n * @category bigint constructors\n * @since 3.10.0\n */\nexport const NonPositiveBigIntFromSelf: filter<Schema<bigint>> = BigIntFromSelf.pipe(\n  nonPositiveBigInt({ identifier: \"NonPositiveBigintFromSelf\" })\n)\n\n/**\n * @category bigint constructors\n * @since 3.10.0\n */\nexport const NonPositiveBigInt: filter<Schema<bigint, string>> = BigInt$.pipe(\n  nonPositiveBigInt({ identifier: \"NonPositiveBigint\" })\n)\n\n/**\n * @category bigint constructors\n * @since 3.10.0\n */\nexport const NonNegativeBigIntFromSelf: filter<Schema<bigint>> = BigIntFromSelf.pipe(\n  nonNegativeBigInt({ identifier: \"NonNegativeBigintFromSelf\" })\n)\n\n/**\n * @category bigint constructors\n * @since 3.10.0\n */\nexport const NonNegativeBigInt: filter<Schema<bigint, string>> = BigInt$.pipe(\n  nonNegativeBigInt({ identifier: \"NonNegativeBigint\" })\n)\n\n/**\n * This schema transforms a `number` into a `bigint` by parsing the number using the `BigInt` function.\n *\n * It returns an error if the value can't be safely encoded as a `number` due to being out of range.\n *\n * @category bigint transformations\n * @since 3.10.0\n */\nexport class BigIntFromNumber extends transformOrFail(\n  Number$.annotations({ description: \"a number that will be parsed into a bigint\" }),\n  BigIntFromSelf,\n  {\n    strict: true,\n    decode: (n, _, ast) =>\n      ParseResult.fromOption(\n        bigInt_.fromNumber(n),\n        () => new ParseResult.Type(ast, n)\n      ),\n    encode: (b, _, ast) => ParseResult.fromOption(bigInt_.toNumber(b), () => new ParseResult.Type(ast, b))\n  }\n).annotations({ identifier: \"BigintFromNumber\" }) {}\n\nconst redactedArbitrary = <A>(value: LazyArbitrary<A>): LazyArbitrary<redacted_.Redacted<A>> => (fc) =>\n  value(fc).map(redacted_.make)\n\nconst toComposite = <A, R, B>(\n  eff: Effect.Effect<A, ParseResult.ParseIssue, R>,\n  onSuccess: (a: A) => B,\n  ast: AST.AST,\n  actual: unknown\n): Effect.Effect<B, ParseResult.Composite, R> =>\n  ParseResult.mapBoth(eff, {\n    onFailure: (e) => new ParseResult.Composite(ast, actual, e),\n    onSuccess\n  })\n\nconst redactedParse = <A, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<A, R>\n): ParseResult.DeclarationDecodeUnknown<redacted_.Redacted<A>, R> =>\n(u, options, ast) =>\n  redacted_.isRedacted(u) ?\n    toComposite(decodeUnknown(redacted_.value(u), options), redacted_.make, ast, u) :\n    ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface RedactedFromSelf<Value extends Schema.Any> extends\n  AnnotableClass<\n    RedactedFromSelf<Value>,\n    redacted_.Redacted<Schema.Type<Value>>,\n    redacted_.Redacted<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Redacted constructors\n * @since 3.10.0\n */\nexport const RedactedFromSelf = <Value extends Schema.Any>(\n  value: Value\n): RedactedFromSelf<Value> =>\n  declare(\n    [value],\n    {\n      decode: (value) => redactedParse(ParseResult.decodeUnknown(value)),\n      encode: (value) => redactedParse(ParseResult.encodeUnknown(value))\n    },\n    {\n      description: \"Redacted(<redacted>)\",\n      pretty: () => () => \"Redacted(<redacted>)\",\n      arbitrary: redactedArbitrary,\n      equivalence: redacted_.getEquivalence\n    }\n  )\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Redacted<Value extends Schema.Any> extends\n  AnnotableClass<\n    Redacted<Value>,\n    redacted_.Redacted<Schema.Type<Value>>,\n    Schema.Encoded<Value>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * A schema that transforms any type `A` into a `Redacted<A>`.\n *\n * @category Redacted transformations\n * @since 3.10.0\n */\nexport const Redacted = <Value extends Schema.Any>(\n  value: Value\n): Redacted<Value> => {\n  return transform(\n    value,\n    RedactedFromSelf(typeSchema(value)),\n    {\n      strict: true,\n      decode: (value) => redacted_.make(value),\n      encode: (value) => redacted_.value(value)\n    }\n  )\n}\n\n/**\n * @category Duration constructors\n * @since 3.10.0\n */\nexport class DurationFromSelf extends declare(\n  duration_.isDuration,\n  {\n    identifier: \"DurationFromSelf\",\n    pretty: (): pretty_.Pretty<duration_.Duration> => String,\n    arbitrary: (): LazyArbitrary<duration_.Duration> => (fc) =>\n      fc.oneof(\n        fc.constant(duration_.infinity),\n        fc.bigUint().map((_) => duration_.nanos(_)),\n        fc.bigUint().map((_) => duration_.micros(_)),\n        fc.maxSafeNat().map((_) => duration_.millis(_)),\n        fc.maxSafeNat().map((_) => duration_.seconds(_)),\n        fc.maxSafeNat().map((_) => duration_.minutes(_)),\n        fc.maxSafeNat().map((_) => duration_.hours(_)),\n        fc.maxSafeNat().map((_) => duration_.days(_)),\n        fc.maxSafeNat().map((_) => duration_.weeks(_))\n      ),\n    equivalence: (): Equivalence.Equivalence<duration_.Duration> => duration_.Equivalence\n  }\n) {}\n\n/**\n * A schema that transforms a `bigint` tuple into a `Duration`.\n * Treats the value as the number of nanoseconds.\n *\n * @category Duration transformations\n * @since 3.10.0\n */\nexport class DurationFromNanos extends transformOrFail(\n  BigIntFromSelf.annotations({ description: \"a bigint that will be parsed into a Duration\" }),\n  DurationFromSelf,\n  {\n    strict: true,\n    decode: (nanos) => ParseResult.succeed(duration_.nanos(nanos)),\n    encode: (duration, _, ast) =>\n      option_.match(duration_.toNanos(duration), {\n        onNone: () => ParseResult.fail(new ParseResult.Type(ast, duration)),\n        onSome: (val) => ParseResult.succeed(val)\n      })\n  }\n).annotations({ identifier: \"DurationFromNanos\" }) {}\n\n/**\n * A schema that transforms a `number` tuple into a `Duration`.\n * Treats the value as the number of milliseconds.\n *\n * @category Duration transformations\n * @since 3.10.0\n */\nexport class DurationFromMillis extends transform(\n  Number$.annotations({ description: \"a number that will be parsed into a Duration\" }),\n  DurationFromSelf,\n  { strict: true, decode: (ms) => duration_.millis(ms), encode: (n) => duration_.toMillis(n) }\n).annotations({ identifier: \"DurationFromMillis\" }) {}\n\n/**\n * @category number constructors\n * @since 3.11.10\n */\nexport const NonNegativeInt = NonNegative.pipe(int()).annotations({ identifier: \"NonNegativeInt\" })\n\nconst HRTime: Schema<readonly [seconds: number, nanos: number]> = Tuple(\n  element(NonNegativeInt).annotations({ title: \"seconds\" }),\n  element(NonNegativeInt).annotations({ title: \"nanos\" })\n).annotations({ identifier: \"HRTime\" })\n\n/**\n * A schema that transforms a `[number, number]` tuple into a `Duration`.\n *\n * @category Duration transformations\n * @since 3.10.0\n */\nexport class Duration extends transform(\n  HRTime.annotations({ description: \"a tuple of seconds and nanos that will be parsed into a Duration\" }),\n  DurationFromSelf,\n  {\n    strict: true,\n    decode: ([seconds, nanos]) => duration_.nanos(BigInt(seconds) * BigInt(1e9) + BigInt(nanos)),\n    encode: (duration) => duration_.toHrTime(duration)\n  }\n).annotations({ identifier: \"Duration\" }) {}\n\n/**\n * Clamps a `Duration` between a minimum and a maximum value.\n *\n * @category Duration transformations\n * @since 3.10.0\n */\nexport const clampDuration =\n  (minimum: duration_.DurationInput, maximum: duration_.DurationInput) =>\n  <A extends duration_.Duration, I, R>(self: Schema<A, I, R>): transform<Schema<A, I, R>, filter<Schema<A>>> =>\n    transform(\n      self,\n      self.pipe(typeSchema, betweenDuration(minimum, maximum)),\n      { strict: false, decode: (self) => duration_.clamp(self, { minimum, maximum }), encode: identity }\n    )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanDurationSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/LessThanDuration\")\n\n/**\n * @category Duration filters\n * @since 3.10.0\n */\nexport const lessThanDuration = <A extends duration_.Duration>(\n  max: duration_.DurationInput,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => duration_.lessThan(a, max), {\n      schemaId: LessThanDurationSchemaId,\n      [LessThanDurationSchemaId]: { max },\n      title: `lessThanDuration(${max})`,\n      description: `a Duration less than ${duration_.decode(max)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanOrEqualToDurationSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/LessThanOrEqualToDuration\"\n)\n\n/**\n * @category Duration filters\n * @since 3.10.0\n */\nexport const lessThanOrEqualToDuration = <A extends duration_.Duration>(\n  max: duration_.DurationInput,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => duration_.lessThanOrEqualTo(a, max), {\n      schemaId: LessThanDurationSchemaId,\n      [LessThanDurationSchemaId]: { max },\n      title: `lessThanOrEqualToDuration(${max})`,\n      description: `a Duration less than or equal to ${duration_.decode(max)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanDurationSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/GreaterThanDuration\")\n\n/**\n * @category Duration filters\n * @since 3.10.0\n */\nexport const greaterThanDuration = <A extends duration_.Duration>(\n  min: duration_.DurationInput,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => duration_.greaterThan(a, min), {\n      schemaId: GreaterThanDurationSchemaId,\n      [GreaterThanDurationSchemaId]: { min },\n      title: `greaterThanDuration(${min})`,\n      description: `a Duration greater than ${duration_.decode(min)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanOrEqualToDurationSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/GreaterThanOrEqualToDuration\"\n)\n\n/**\n * @category Duration filters\n * @since 3.10.0\n */\nexport const greaterThanOrEqualToDuration = <A extends duration_.Duration>(\n  min: duration_.DurationInput,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => duration_.greaterThanOrEqualTo(a, min), {\n      schemaId: GreaterThanOrEqualToDurationSchemaId,\n      [GreaterThanOrEqualToDurationSchemaId]: { min },\n      title: `greaterThanOrEqualToDuration(${min})`,\n      description: `a Duration greater than or equal to ${duration_.decode(min)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const BetweenDurationSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/BetweenDuration\")\n\n/**\n * @category Duration filters\n * @since 3.10.0\n */\nexport const betweenDuration = <A extends duration_.Duration>(\n  minimum: duration_.DurationInput,\n  maximum: duration_.DurationInput,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => duration_.between(a, { minimum, maximum }), {\n      schemaId: BetweenDurationSchemaId,\n      [BetweenDurationSchemaId]: { maximum, minimum },\n      title: `betweenDuration(${minimum}, ${maximum})`,\n      description: `a Duration between ${duration_.decode(minimum)} and ${duration_.decode(maximum)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category Uint8Array constructors\n * @since 3.10.0\n */\nexport const Uint8ArrayFromSelf: Schema<Uint8Array> = declare(\n  Predicate.isUint8Array,\n  {\n    identifier: \"Uint8ArrayFromSelf\",\n    pretty: (): pretty_.Pretty<Uint8Array> => (u8arr) => `new Uint8Array(${JSON.stringify(Array.from(u8arr))})`,\n    arbitrary: (): LazyArbitrary<Uint8Array> => (fc) => fc.uint8Array(),\n    equivalence: (): Equivalence.Equivalence<Uint8Array> => array_.getEquivalence(Equal.equals) as any\n  }\n)\n\n/**\n * @category number constructors\n * @since 3.11.10\n */\nexport const Uint8 = Number$.pipe(\n  between(0, 255, {\n    identifier: \"Uint8\",\n    description: \"a 8-bit unsigned integer\"\n  })\n)\n\nconst Uint8Array$: Schema<Uint8Array, ReadonlyArray<number>> = transform(\n  Array$(Uint8).annotations({\n    description: \"an array of 8-bit unsigned integers that will be parsed into a Uint8Array\"\n  }),\n  Uint8ArrayFromSelf,\n  { strict: true, decode: (numbers) => Uint8Array.from(numbers), encode: (uint8Array) => Array.from(uint8Array) }\n).annotations({ identifier: \"Uint8Array\" })\n\nexport {\n  /**\n   * A schema that transforms an array of numbers into a `Uint8Array`.\n   *\n   * @category Uint8Array transformations\n   * @since 3.10.0\n   */\n  Uint8Array$ as Uint8Array\n}\n\nconst makeUint8ArrayTransformation = (\n  id: string,\n  decode: (s: string) => either_.Either<Uint8Array, Encoding.DecodeException>,\n  encode: (u: Uint8Array) => string\n) =>\n  transformOrFail(\n    String$.annotations({ description: \"a string that will be parsed into a Uint8Array\" }),\n    Uint8ArrayFromSelf,\n    {\n      strict: true,\n      decode: (s, _, ast) =>\n        either_.mapLeft(\n          decode(s),\n          (decodeException) => new ParseResult.Type(ast, s, decodeException.message)\n        ),\n      encode: (u) => ParseResult.succeed(encode(u))\n    }\n  ).annotations({ identifier: id })\n\n/**\n * Decodes a base64 (RFC4648) encoded string into a `Uint8Array`.\n *\n * @category Uint8Array transformations\n * @since 3.10.0\n */\nexport const Uint8ArrayFromBase64: Schema<Uint8Array, string> = makeUint8ArrayTransformation(\n  \"Uint8ArrayFromBase64\",\n  Encoding.decodeBase64,\n  Encoding.encodeBase64\n)\n\n/**\n * Decodes a base64 (URL) encoded string into a `Uint8Array`.\n *\n * @category Uint8Array transformations\n * @since 3.10.0\n */\nexport const Uint8ArrayFromBase64Url: Schema<Uint8Array, string> = makeUint8ArrayTransformation(\n  \"Uint8ArrayFromBase64Url\",\n  Encoding.decodeBase64Url,\n  Encoding.encodeBase64Url\n)\n\n/**\n * Decodes a hex encoded string into a `Uint8Array`.\n *\n * @category Uint8Array transformations\n * @since 3.10.0\n */\nexport const Uint8ArrayFromHex: Schema<Uint8Array, string> = makeUint8ArrayTransformation(\n  \"Uint8ArrayFromHex\",\n  Encoding.decodeHex,\n  Encoding.encodeHex\n)\n\nconst makeEncodingTransformation = (\n  id: string,\n  decode: (s: string) => either_.Either<string, Encoding.DecodeException>,\n  encode: (u: string) => string\n) =>\n  transformOrFail(\n    String$.annotations({\n      description: `A string that is interpreted as being ${id}-encoded and will be decoded into a UTF-8 string`\n    }),\n    String$,\n    {\n      strict: true,\n      decode: (s, _, ast) =>\n        either_.mapLeft(\n          decode(s),\n          (decodeException) => new ParseResult.Type(ast, s, decodeException.message)\n        ),\n      encode: (u) => ParseResult.succeed(encode(u))\n    }\n  ).annotations({ identifier: `StringFrom${id}` })\n\n/**\n * Decodes a base64 (RFC4648) encoded string into a UTF-8 string.\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport const StringFromBase64: Schema<string> = makeEncodingTransformation(\n  \"Base64\",\n  Encoding.decodeBase64String,\n  Encoding.encodeBase64\n)\n\n/**\n * Decodes a base64 (URL) encoded string into a UTF-8 string.\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport const StringFromBase64Url: Schema<string> = makeEncodingTransformation(\n  \"Base64Url\",\n  Encoding.decodeBase64UrlString,\n  Encoding.encodeBase64Url\n)\n\n/**\n * Decodes a hex encoded string into a UTF-8 string.\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport const StringFromHex: Schema<string> = makeEncodingTransformation(\n  \"Hex\",\n  Encoding.decodeHexString,\n  Encoding.encodeHex\n)\n\n/**\n * Decodes a URI component encoded string into a UTF-8 string.\n * Can be used to store data in a URL.\n *\n * @example\n * ```ts\n * import { Schema } from \"effect\"\n *\n * const PaginationSchema = Schema.Struct({\n *   maxItemPerPage: Schema.Number,\n *   page: Schema.Number\n * })\n *\n * const UrlSchema = Schema.compose(Schema.StringFromUriComponent, Schema.parseJson(PaginationSchema))\n *\n * console.log(Schema.encodeSync(UrlSchema)({ maxItemPerPage: 10, page: 1 }))\n * // Output: %7B%22maxItemPerPage%22%3A10%2C%22page%22%3A1%7D\n * ```\n *\n * @category string transformations\n * @since 3.12.0\n */\nexport const StringFromUriComponent = transformOrFail(\n  String$.annotations({\n    description: `A string that is interpreted as being UriComponent-encoded and will be decoded into a UTF-8 string`\n  }),\n  String$,\n  {\n    strict: true,\n    decode: (s, _, ast) =>\n      either_.mapLeft(\n        Encoding.decodeUriComponent(s),\n        (decodeException) => new ParseResult.Type(ast, s, decodeException.message)\n      ),\n    encode: (u, _, ast) =>\n      either_.mapLeft(\n        Encoding.encodeUriComponent(u),\n        (encodeException) => new ParseResult.Type(ast, u, encodeException.message)\n      )\n  }\n).annotations({ identifier: `StringFromUriComponent` })\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const MinItemsSchemaId: unique symbol = schemaId_.MinItemsSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type MinItemsSchemaId = typeof MinItemsSchemaId\n\n/**\n * @category ReadonlyArray filters\n * @since 3.10.0\n */\nexport const minItems = <A>(\n  n: number,\n  annotations?: Annotations.Filter<ReadonlyArray<A>>\n) =>\n<I, R>(self: Schema<ReadonlyArray<A>, I, R>): filter<Schema<ReadonlyArray<A>, I, R>> => {\n  const minItems = Math.floor(n)\n  if (minItems < 1) {\n    throw new Error(\n      errors_.getInvalidArgumentErrorMessage(`Expected an integer greater than or equal to 1, actual ${n}`)\n    )\n  }\n  return self.pipe(\n    filter(\n      (a) => a.length >= minItems,\n      {\n        schemaId: MinItemsSchemaId,\n        title: `minItems(${minItems})`,\n        description: `an array of at least ${minItems} item(s)`,\n        jsonSchema: { minItems },\n        [AST.StableFilterAnnotationId]: true,\n        ...annotations\n      }\n    )\n  )\n}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const MaxItemsSchemaId: unique symbol = schemaId_.MaxItemsSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type MaxItemsSchemaId = typeof MaxItemsSchemaId\n\n/**\n * @category ReadonlyArray filters\n * @since 3.10.0\n */\nexport const maxItems = <A>(\n  n: number,\n  annotations?: Annotations.Filter<ReadonlyArray<A>>\n) =>\n<I, R>(self: Schema<ReadonlyArray<A>, I, R>): filter<Schema<ReadonlyArray<A>, I, R>> =>\n  self.pipe(\n    filter((a) => a.length <= n, {\n      schemaId: MaxItemsSchemaId,\n      title: `maxItems(${n})`,\n      description: `an array of at most ${n} item(s)`,\n      jsonSchema: { maxItems: n },\n      [AST.StableFilterAnnotationId]: true,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const ItemsCountSchemaId: unique symbol = schemaId_.ItemsCountSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type ItemsCountSchemaId = typeof ItemsCountSchemaId\n\n/**\n * @category ReadonlyArray filters\n * @since 3.10.0\n */\nexport const itemsCount = <A>(\n  n: number,\n  annotations?: Annotations.Filter<ReadonlyArray<A>>\n) =>\n<I, R>(self: Schema<ReadonlyArray<A>, I, R>): filter<Schema<ReadonlyArray<A>, I, R>> =>\n  self.pipe(\n    filter((a) => a.length === n, {\n      schemaId: ItemsCountSchemaId,\n      title: `itemsCount(${n})`,\n      description: `an array of exactly ${n} item(s)`,\n      jsonSchema: { minItems: n, maxItems: n },\n      [AST.StableFilterAnnotationId]: true,\n      ...annotations\n    })\n  )\n\n/**\n * @category ReadonlyArray transformations\n * @since 3.10.0\n */\nexport const getNumberIndexedAccess = <A extends ReadonlyArray<any>, I extends ReadonlyArray<any>, R>(\n  self: Schema<A, I, R>\n): SchemaClass<A[number], I[number], R> => make(AST.getNumberIndexedAccess(self.ast))\n\n/**\n * Get the first element of a `ReadonlyArray`, or `None` if the array is empty.\n *\n * @category ReadonlyArray transformations\n * @since 3.10.0\n */\nexport const head = <A, I, R>(self: Schema<ReadonlyArray<A>, I, R>): SchemaClass<option_.Option<A>, I, R> =>\n  transform(\n    self,\n    OptionFromSelf(getNumberIndexedAccess(typeSchema(self))),\n    { strict: true, decode: array_.head, encode: option_.match({ onNone: () => [], onSome: array_.of }) }\n  )\n\n/**\n * Get the first element of a `NonEmptyReadonlyArray`.\n *\n * @category NonEmptyReadonlyArray transformations\n * @since 3.12.0\n */\nexport const headNonEmpty = <A, I, R>(self: Schema<array_.NonEmptyReadonlyArray<A>, I, R>): SchemaClass<A, I, R> =>\n  transform(\n    self,\n    getNumberIndexedAccess(typeSchema(self)),\n    { strict: true, decode: array_.headNonEmpty, encode: array_.of }\n  )\n\n/**\n * Retrieves the first element of a `ReadonlyArray`.\n *\n * If the array is empty, it returns the `fallback` argument if provided; otherwise, it fails.\n *\n * @category ReadonlyArray transformations\n * @since 3.10.0\n */\nexport const headOrElse: {\n  /**\n   * Retrieves the first element of a `ReadonlyArray`.\n   *\n   * If the array is empty, it returns the `fallback` argument if provided; otherwise, it fails.\n   *\n   * @category ReadonlyArray transformations\n   * @since 3.10.0\n   */\n  <A>(fallback?: LazyArg<A>): <I, R>(self: Schema<ReadonlyArray<A>, I, R>) => SchemaClass<A, I, R>\n  /**\n   * Retrieves the first element of a `ReadonlyArray`.\n   *\n   * If the array is empty, it returns the `fallback` argument if provided; otherwise, it fails.\n   *\n   * @category ReadonlyArray transformations\n   * @since 3.10.0\n   */\n  <A, I, R>(self: Schema<ReadonlyArray<A>, I, R>, fallback?: LazyArg<A>): SchemaClass<A, I, R>\n} = dual(\n  (args) => isSchema(args[0]),\n  <A, I, R>(self: Schema<ReadonlyArray<A>, I, R>, fallback?: LazyArg<A>): SchemaClass<A, I, R> =>\n    transformOrFail(\n      self,\n      getNumberIndexedAccess(typeSchema(self)),\n      {\n        strict: true,\n        decode: (as, _, ast) =>\n          as.length > 0\n            ? ParseResult.succeed(as[0])\n            : fallback\n            ? ParseResult.succeed(fallback())\n            : ParseResult.fail(new ParseResult.Type(ast, as)),\n        encode: (a) => ParseResult.succeed(array_.of(a))\n      }\n    )\n)\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const ValidDateSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/ValidDate\")\n\n/**\n * Defines a filter that specifically rejects invalid dates, such as `new\n * Date(\"Invalid Date\")`. This filter ensures that only properly formatted and\n * valid date objects are accepted, enhancing data integrity by preventing\n * erroneous date values from being processed.\n *\n * @category Date filters\n * @since 3.10.0\n */\nexport const validDate =\n  (annotations?: Annotations.Filter<Date>) => <I, R>(self: Schema<Date, I, R>): filter<Schema<Date, I, R>> =>\n    self.pipe(\n      filter((a) => !Number.isNaN(a.getTime()), {\n        schemaId: ValidDateSchemaId,\n        [ValidDateSchemaId]: { noInvalidDate: true },\n        title: \"validDate\",\n        description: \"a valid Date\",\n        ...annotations\n      })\n    )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanDateSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/LessThanDate\")\n\n/**\n * @category Date filters\n * @since 3.10.0\n */\nexport const lessThanDate = <A extends Date>(\n  max: Date,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a < max, {\n      schemaId: LessThanDateSchemaId,\n      [LessThanDateSchemaId]: { max },\n      title: `lessThanDate(${util_.formatDate(max)})`,\n      description: `a date before ${util_.formatDate(max)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanOrEqualToDateSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/LessThanOrEqualToDate\"\n)\n\n/**\n * @category Date filters\n * @since 3.10.0\n */\nexport const lessThanOrEqualToDate = <A extends Date>(\n  max: Date,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a <= max, {\n      schemaId: LessThanDateSchemaId,\n      [LessThanDateSchemaId]: { max },\n      title: `lessThanOrEqualToDate(${util_.formatDate(max)})`,\n      description: `a date before or equal to ${util_.formatDate(max)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanDateSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/GreaterThanDate\")\n\n/**\n * @category Date filters\n * @since 3.10.0\n */\nexport const greaterThanDate = <A extends Date>(\n  min: Date,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a > min, {\n      schemaId: GreaterThanDateSchemaId,\n      [GreaterThanDateSchemaId]: { min },\n      title: `greaterThanDate(${util_.formatDate(min)})`,\n      description: `a date after ${util_.formatDate(min)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanOrEqualToDateSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/GreaterThanOrEqualToDate\"\n)\n\n/**\n * @category Date filters\n * @since 3.10.0\n */\nexport const greaterThanOrEqualToDate = <A extends Date>(\n  min: Date,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a >= min, {\n      schemaId: GreaterThanOrEqualToDateSchemaId,\n      [GreaterThanOrEqualToDateSchemaId]: { min },\n      title: `greaterThanOrEqualToDate(${util_.formatDate(min)})`,\n      description: `a date after or equal to ${util_.formatDate(min)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const BetweenDateSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/BetweenDate\")\n\n/**\n * @category Date filters\n * @since 3.10.0\n */\nexport const betweenDate = <A extends Date>(\n  min: Date,\n  max: Date,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a <= max && a >= min, {\n      schemaId: BetweenDateSchemaId,\n      [BetweenDateSchemaId]: { max, min },\n      title: `betweenDate(${util_.formatDate(min)}, ${util_.formatDate(max)})`,\n      description: `a date between ${util_.formatDate(min)} and ${util_.formatDate(max)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.11.8\n */\nexport const DateFromSelfSchemaId: unique symbol = schemaId_.DateFromSelfSchemaId\n\n/**\n * @category schema id\n * @since 3.11.8\n */\nexport type DateFromSelfSchemaId = typeof DateFromSelfSchemaId\n\n/**\n * Describes a schema that accommodates potentially invalid `Date` instances,\n * such as `new Date(\"Invalid Date\")`, without rejection.\n *\n * @category Date constructors\n * @since 3.10.0\n */\nexport class DateFromSelf extends declare(\n  Predicate.isDate,\n  {\n    identifier: \"DateFromSelf\",\n    schemaId: DateFromSelfSchemaId,\n    [DateFromSelfSchemaId]: { noInvalidDate: false },\n    description: \"a potentially invalid Date instance\",\n    pretty: () => (date) => `new Date(${JSON.stringify(date)})`,\n    arbitrary: () => (fc) => fc.date({ noInvalidDate: false }),\n    equivalence: () => Equivalence.Date\n  }\n) {}\n\n/**\n * Defines a schema that ensures only valid dates are accepted. This schema\n * rejects values like `new Date(\"Invalid Date\")`, which, despite being a `Date`\n * instance, represents an invalid date. Such stringent validation ensures that\n * all date objects processed through this schema are properly formed and\n * represent real dates.\n *\n * @category Date constructors\n * @since 3.10.0\n */\nexport class ValidDateFromSelf extends DateFromSelf.pipe(\n  validDate({\n    identifier: \"ValidDateFromSelf\",\n    description: \"a valid Date instance\"\n  })\n) {}\n\n/**\n * Defines a schema that attempts to convert a `string` to a `Date` object using\n * the `new Date` constructor. This conversion is lenient, meaning it does not\n * reject strings that do not form valid dates (e.g., using `new Date(\"Invalid\n * Date\")` results in a `Date` object, despite being invalid).\n *\n * @category Date transformations\n * @since 3.10.0\n */\nexport class DateFromString extends transform(\n  String$.annotations({ description: \"a string that will be parsed into a Date\" }),\n  DateFromSelf,\n  { strict: true, decode: (s) => new Date(s), encode: (d) => util_.formatDate(d) }\n).annotations({ identifier: \"DateFromString\" }) {}\n\n/** @ignore */\nclass Date$ extends DateFromString.pipe(\n  validDate({ identifier: \"Date\" })\n) {}\n\nexport {\n  /**\n   * This schema converts a `string` into a `Date` object using the `new Date`\n   * constructor. It ensures that only valid date strings are accepted,\n   * rejecting any strings that would result in an invalid date, such as `new\n   * Date(\"Invalid Date\")`.\n   *\n   * @category Date transformations\n   * @since 3.10.0\n   */\n  Date$ as Date\n}\n\n/**\n * Defines a schema that converts a `number` into a `Date` object using the `new\n * Date` constructor. This schema does not validate the numerical input,\n * allowing potentially invalid values such as `NaN`, `Infinity`, and\n * `-Infinity` to be converted into `Date` objects. During the encoding process,\n * any invalid `Date` object will be encoded to `NaN`.\n *\n * @category Date transformations\n * @since 3.10.0\n */\nexport class DateFromNumber extends transform(\n  Number$.annotations({ description: \"a number that will be parsed into a Date\" }),\n  DateFromSelf,\n  { strict: true, decode: (n) => new Date(n), encode: (d) => d.getTime() }\n).annotations({ identifier: \"DateFromNumber\" }) {}\n\n/**\n * Describes a schema that represents a `DateTime.Utc` instance.\n *\n * @category DateTime.Utc constructors\n * @since 3.10.0\n */\nexport class DateTimeUtcFromSelf extends declare(\n  (u) => dateTime.isDateTime(u) && dateTime.isUtc(u),\n  {\n    identifier: \"DateTimeUtcFromSelf\",\n    description: \"a DateTime.Utc instance\",\n    pretty: (): pretty_.Pretty<dateTime.Utc> => (dateTime) => dateTime.toString(),\n    arbitrary: (): LazyArbitrary<dateTime.Utc> => (fc) => fc.date().map((date) => dateTime.unsafeFromDate(date)),\n    equivalence: () => dateTime.Equivalence\n  }\n) {}\n\nconst decodeDateTime = <A extends dateTime.DateTime.Input>(input: A, _: ParseOptions, ast: AST.AST) =>\n  ParseResult.try({\n    try: () => dateTime.unsafeMake(input),\n    catch: () => new ParseResult.Type(ast, input)\n  })\n\n/**\n * Defines a schema that attempts to convert a `number` to a `DateTime.Utc` instance using the `DateTime.unsafeMake` constructor.\n *\n * @category DateTime.Utc transformations\n * @since 3.10.0\n */\nexport class DateTimeUtcFromNumber extends transformOrFail(\n  Number$.annotations({ description: \"a number that will be parsed into a DateTime.Utc\" }),\n  DateTimeUtcFromSelf,\n  {\n    strict: true,\n    decode: decodeDateTime,\n    encode: (dt) => ParseResult.succeed(dateTime.toEpochMillis(dt))\n  }\n).annotations({ identifier: \"DateTimeUtcFromNumber\" }) {}\n\n/**\n * Defines a schema that attempts to convert a `Date` to a `DateTime.Utc` instance using the `DateTime.unsafeMake` constructor.\n *\n * @category DateTime.Utc transformations\n * @since 3.12.0\n */\nexport class DateTimeUtcFromDate extends transformOrFail(\n  DateFromSelf.annotations({ description: \"a Date that will be parsed into a DateTime.Utc\" }),\n  DateTimeUtcFromSelf,\n  {\n    strict: true,\n    decode: decodeDateTime,\n    encode: (dt) => ParseResult.succeed(dateTime.toDateUtc(dt))\n  }\n).annotations({ identifier: \"DateTimeUtcFromDate\" }) {}\n\n/**\n * Defines a schema that attempts to convert a `string` to a `DateTime.Utc` instance using the `DateTime.unsafeMake` constructor.\n *\n * @category DateTime.Utc transformations\n * @since 3.10.0\n */\nexport class DateTimeUtc extends transformOrFail(\n  String$.annotations({ description: \"a string that will be parsed into a DateTime.Utc\" }),\n  DateTimeUtcFromSelf,\n  {\n    strict: true,\n    decode: decodeDateTime,\n    encode: (dt) => ParseResult.succeed(dateTime.formatIso(dt))\n  }\n).annotations({ identifier: \"DateTimeUtc\" }) {}\n\nconst timeZoneOffsetArbitrary = (): LazyArbitrary<dateTime.TimeZone.Offset> => (fc) =>\n  fc.integer({ min: -12 * 60 * 60 * 1000, max: 12 * 60 * 60 * 1000 }).map(dateTime.zoneMakeOffset)\n\n/**\n * Describes a schema that represents a `TimeZone.Offset` instance.\n *\n * @category TimeZone constructors\n * @since 3.10.0\n */\nexport class TimeZoneOffsetFromSelf extends declare(\n  dateTime.isTimeZoneOffset,\n  {\n    identifier: \"TimeZoneOffsetFromSelf\",\n    description: \"a TimeZone.Offset instance\",\n    pretty: (): pretty_.Pretty<dateTime.TimeZone.Offset> => (zone) => zone.toString(),\n    arbitrary: timeZoneOffsetArbitrary\n  }\n) {}\n\n/**\n * Defines a schema that converts a `number` to a `TimeZone.Offset` instance using the `DateTime.zoneMakeOffset` constructor.\n *\n * @category TimeZone transformations\n * @since 3.10.0\n */\nexport class TimeZoneOffset extends transform(\n  Number$.annotations({ description: \"a number that will be parsed into a TimeZone.Offset\" }),\n  TimeZoneOffsetFromSelf,\n  { strict: true, decode: dateTime.zoneMakeOffset, encode: (tz) => tz.offset }\n).annotations({ identifier: \"TimeZoneOffset\" }) {}\n\nconst timeZoneNamedArbitrary = (): LazyArbitrary<dateTime.TimeZone.Named> => (fc) =>\n  fc.constantFrom(...Intl.supportedValuesOf(\"timeZone\")).map(dateTime.zoneUnsafeMakeNamed)\n\n/**\n * Describes a schema that represents a `TimeZone.Named` instance.\n *\n * @category TimeZone constructors\n * @since 3.10.0\n */\nexport class TimeZoneNamedFromSelf extends declare(\n  dateTime.isTimeZoneNamed,\n  {\n    identifier: \"TimeZoneNamedFromSelf\",\n    description: \"a TimeZone.Named instance\",\n    pretty: (): pretty_.Pretty<dateTime.TimeZone.Named> => (zone) => zone.toString(),\n    arbitrary: timeZoneNamedArbitrary\n  }\n) {}\n\n/**\n * Defines a schema that attempts to convert a `string` to a `TimeZone.Named` instance using the `DateTime.zoneUnsafeMakeNamed` constructor.\n *\n * @category TimeZone transformations\n * @since 3.10.0\n */\nexport class TimeZoneNamed extends transformOrFail(\n  String$.annotations({ description: \"a string that will be parsed into a TimeZone.Named\" }),\n  TimeZoneNamedFromSelf,\n  {\n    strict: true,\n    decode: (s, _, ast) =>\n      ParseResult.try({\n        try: () => dateTime.zoneUnsafeMakeNamed(s),\n        catch: () => new ParseResult.Type(ast, s)\n      }),\n    encode: (tz) => ParseResult.succeed(tz.id)\n  }\n).annotations({ identifier: \"TimeZoneNamed\" }) {}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface TimeZoneFromSelf extends Union<[typeof TimeZoneOffsetFromSelf, typeof TimeZoneNamedFromSelf]> {\n  annotations(annotations: Annotations.Schema<dateTime.TimeZone>): TimeZoneFromSelf\n}\n\n/**\n * @category TimeZone constructors\n * @since 3.10.0\n */\nexport const TimeZoneFromSelf: TimeZoneFromSelf = Union(TimeZoneOffsetFromSelf, TimeZoneNamedFromSelf)\n\n/**\n * Defines a schema that attempts to convert a `string` to a `TimeZone` using the `DateTime.zoneFromString` constructor.\n *\n * @category TimeZone transformations\n * @since 3.10.0\n */\nexport class TimeZone extends transformOrFail(\n  String$.annotations({ description: \"a string that will be parsed into a TimeZone\" }),\n  TimeZoneFromSelf,\n  {\n    strict: true,\n    decode: (s, _, ast) =>\n      option_.match(dateTime.zoneFromString(s), {\n        onNone: () => ParseResult.fail(new ParseResult.Type(ast, s)),\n        onSome: ParseResult.succeed\n      }),\n    encode: (tz) => ParseResult.succeed(dateTime.zoneToString(tz))\n  }\n).annotations({ identifier: \"TimeZone\" }) {}\n\nconst timeZoneArbitrary: LazyArbitrary<dateTime.TimeZone> = (fc) =>\n  fc.oneof(\n    timeZoneOffsetArbitrary()(fc),\n    timeZoneNamedArbitrary()(fc)\n  )\n\n/**\n * Describes a schema that represents a `DateTime.Zoned` instance.\n *\n * @category DateTime.Zoned constructors\n * @since 3.10.0\n */\nexport class DateTimeZonedFromSelf extends declare(\n  (u) => dateTime.isDateTime(u) && dateTime.isZoned(u),\n  {\n    identifier: \"DateTimeZonedFromSelf\",\n    description: \"a DateTime.Zoned instance\",\n    pretty: (): pretty_.Pretty<dateTime.Zoned> => (dateTime) => dateTime.toString(),\n    arbitrary: (): LazyArbitrary<dateTime.Zoned> => (fc) =>\n      fc.date().chain((date) => timeZoneArbitrary(fc).map((timeZone) => dateTime.unsafeMakeZoned(date, { timeZone }))),\n    equivalence: () => dateTime.Equivalence\n  }\n) {}\n\n/**\n * Defines a schema that attempts to convert a `string` to a `DateTime.Zoned` instance.\n *\n * @category DateTime.Zoned transformations\n * @since 3.10.0\n */\nexport class DateTimeZoned extends transformOrFail(\n  String$.annotations({ description: \"a string that will be parsed into a DateTime.Zoned\" }),\n  DateTimeZonedFromSelf,\n  {\n    strict: true,\n    decode: (s, _, ast) =>\n      option_.match(dateTime.makeZonedFromString(s), {\n        onNone: () => ParseResult.fail(new ParseResult.Type(ast, s)),\n        onSome: ParseResult.succeed\n      }),\n    encode: (dt) => ParseResult.succeed(dateTime.formatIsoZoned(dt))\n  }\n).annotations({ identifier: \"DateTimeZoned\" }) {}\n\n/**\n * @category Option utils\n * @since 3.10.0\n */\nexport type OptionEncoded<I> =\n  | {\n    readonly _tag: \"None\"\n  }\n  | {\n    readonly _tag: \"Some\"\n    readonly value: I\n  }\n\nconst OptionNoneEncoded = Struct({\n  _tag: Literal(\"None\")\n}).annotations({ description: \"NoneEncoded\" })\n\nconst optionSomeEncoded = <A, I, R>(value: Schema<A, I, R>) =>\n  Struct({\n    _tag: Literal(\"Some\"),\n    value\n  }).annotations({ description: `SomeEncoded<${format(value)}>` })\n\nconst optionEncoded = <A, I, R>(value: Schema<A, I, R>) =>\n  Union(\n    OptionNoneEncoded,\n    optionSomeEncoded(value)\n  ).annotations({\n    description: `OptionEncoded<${format(value)}>`\n  })\n\nconst optionDecode = <A>(input: OptionEncoded<A>): option_.Option<A> =>\n  input._tag === \"None\" ? option_.none() : option_.some(input.value)\n\nconst optionArbitrary =\n  <A>(value: LazyArbitrary<A>, ctx: ArbitraryGenerationContext): LazyArbitrary<option_.Option<A>> => (fc) =>\n    fc.oneof(\n      ctx,\n      fc.record({ _tag: fc.constant(\"None\" as const) }),\n      fc.record({ _tag: fc.constant(\"Some\" as const), value: value(fc) })\n    ).map(optionDecode)\n\nconst optionPretty = <A>(value: pretty_.Pretty<A>): pretty_.Pretty<option_.Option<A>> =>\n  option_.match({\n    onNone: () => \"none()\",\n    onSome: (a) => `some(${value(a)})`\n  })\n\nconst optionParse =\n  <A, R>(decodeUnknown: ParseResult.DecodeUnknown<A, R>): ParseResult.DeclarationDecodeUnknown<option_.Option<A>, R> =>\n  (u, options, ast) =>\n    option_.isOption(u) ?\n      option_.isNone(u) ?\n        ParseResult.succeed(option_.none())\n        : toComposite(decodeUnknown(u.value, options), option_.some, ast, u)\n      : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface OptionFromSelf<Value extends Schema.Any> extends\n  AnnotableClass<\n    OptionFromSelf<Value>,\n    option_.Option<Schema.Type<Value>>,\n    option_.Option<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Option transformations\n * @since 3.10.0\n */\nexport const OptionFromSelf = <Value extends Schema.Any>(\n  value: Value\n): OptionFromSelf<Value> => {\n  return declare(\n    [value],\n    {\n      decode: (value) => optionParse(ParseResult.decodeUnknown(value)),\n      encode: (value) => optionParse(ParseResult.encodeUnknown(value))\n    },\n    {\n      description: `Option<${format(value)}>`,\n      pretty: optionPretty,\n      arbitrary: optionArbitrary,\n      equivalence: option_.getEquivalence\n    }\n  )\n}\n\nconst makeNoneEncoded = {\n  _tag: \"None\"\n} as const\nconst makeSomeEncoded = <A>(value: A) => ({\n  _tag: \"Some\",\n  value\n} as const)\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Option<Value extends Schema.Any> extends\n  AnnotableClass<\n    Option<Value>,\n    option_.Option<Schema.Type<Value>>,\n    OptionEncoded<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Option transformations\n * @since 3.10.0\n */\nexport const Option = <Value extends Schema.Any>(value: Value): Option<Value> => {\n  const value_ = asSchema(value)\n  return transform(\n    optionEncoded(value_),\n    OptionFromSelf(typeSchema(value_)),\n    {\n      strict: true,\n      decode: optionDecode,\n      encode: option_.match({\n        onNone: () => makeNoneEncoded,\n        onSome: makeSomeEncoded\n      })\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface OptionFromNullOr<Value extends Schema.Any> extends\n  AnnotableClass<\n    OptionFromNullOr<Value>,\n    option_.Option<Schema.Type<Value>>,\n    Schema.Encoded<Value> | null,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Option transformations\n * @since 3.10.0\n */\nexport const OptionFromNullOr = <Value extends Schema.Any>(\n  value: Value\n): OptionFromNullOr<Value> => {\n  const value_ = asSchema(value)\n  return transform(NullOr(value_), OptionFromSelf(typeSchema(value_)), {\n    strict: true,\n    decode: option_.fromNullable,\n    encode: option_.getOrNull\n  })\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface OptionFromNullishOr<Value extends Schema.Any> extends\n  AnnotableClass<\n    OptionFromNullishOr<Value>,\n    option_.Option<Schema.Type<Value>>,\n    Schema.Encoded<Value> | null | undefined,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Option transformations\n * @since 3.10.0\n */\nexport const OptionFromNullishOr = <Value extends Schema.Any>(\n  value: Value,\n  onNoneEncoding: null | undefined\n): OptionFromNullishOr<Value> => {\n  const value_ = asSchema(value)\n  return transform(\n    NullishOr(value_),\n    OptionFromSelf(typeSchema(value_)),\n    {\n      strict: true,\n      decode: option_.fromNullable,\n      encode: onNoneEncoding === null ? option_.getOrNull : option_.getOrUndefined\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface OptionFromUndefinedOr<Value extends Schema.Any> extends\n  AnnotableClass<\n    OptionFromUndefinedOr<Value>,\n    option_.Option<Schema.Type<Value>>,\n    Schema.Encoded<Value> | undefined,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Option transformations\n * @since 3.10.0\n */\nexport const OptionFromUndefinedOr = <Value extends Schema.Any>(\n  value: Value\n): OptionFromUndefinedOr<Value> => {\n  const value_ = asSchema(value)\n  return transform(UndefinedOr(value_), OptionFromSelf(typeSchema(value_)), {\n    strict: true,\n    decode: option_.fromNullable,\n    encode: option_.getOrUndefined\n  })\n}\n\n/**\n * Transforms strings into an Option type, effectively filtering out empty or\n * whitespace-only strings by trimming them and checking their length. Returns\n * `none` for invalid inputs and `some` for valid non-empty strings.\n *\n * @example\n * ```ts\n * import { Schema } from \"effect\"\n *\n * console.log(Schema.decodeSync(Schema.OptionFromNonEmptyTrimmedString)(\"\")) // Option.none()\n * console.log(Schema.decodeSync(Schema.OptionFromNonEmptyTrimmedString)(\" a \")) // Option.some(\"a\")\n * console.log(Schema.decodeSync(Schema.OptionFromNonEmptyTrimmedString)(\"a\")) // Option.some(\"a\")\n * ```\n *\n * @category Option transformations\n * @since 3.10.0\n */\nexport const OptionFromNonEmptyTrimmedString = transform(String$, OptionFromSelf(NonEmptyTrimmedString), {\n  strict: true,\n  decode: (s) => {\n    const out = s.trim()\n    return out.length === 0 ? option_.none() : option_.some(out)\n  },\n  encode: option_.getOrElse(() => \"\")\n})\n\n/**\n * @category Either utils\n * @since 3.10.0\n */\nexport type RightEncoded<IA> = {\n  readonly _tag: \"Right\"\n  readonly right: IA\n}\n\n/**\n * @category Either utils\n * @since 3.10.0\n */\nexport type LeftEncoded<IE> = {\n  readonly _tag: \"Left\"\n  readonly left: IE\n}\n\n/**\n * @category Either utils\n * @since 3.10.0\n */\nexport type EitherEncoded<IR, IL> = RightEncoded<IR> | LeftEncoded<IL>\n\nconst rightEncoded = <RA, RI, RR>(right: Schema<RA, RI, RR>): Schema<RightEncoded<RA>, RightEncoded<RI>, RR> =>\n  Struct({\n    _tag: Literal(\"Right\"),\n    right\n  }).annotations({ description: `RightEncoded<${format(right)}>` })\n\nconst leftEncoded = <LA, LI, LR>(left: Schema<LA, LI, LR>): Schema<LeftEncoded<LA>, LeftEncoded<LI>, LR> =>\n  Struct({\n    _tag: Literal(\"Left\"),\n    left\n  }).annotations({ description: `LeftEncoded<${format(left)}>` })\n\nconst eitherEncoded = <RA, RI, RR, LA, LI, LR>(\n  right: Schema<RA, RI, RR>,\n  left: Schema<LA, LI, LR>\n) =>\n  Union(rightEncoded(right), leftEncoded(left)).annotations({\n    description: `EitherEncoded<${format(left)}, ${format(right)}>`\n  })\n\nconst eitherDecode = <R, L>(input: EitherEncoded<R, L>): either_.Either<R, L> =>\n  input._tag === \"Left\" ? either_.left(input.left) : either_.right(input.right)\n\nconst eitherArbitrary = <R, L>(\n  right: LazyArbitrary<R>,\n  left: LazyArbitrary<L>\n): LazyArbitrary<either_.Either<R, L>> =>\n(fc) =>\n  fc.oneof(\n    fc.record({ _tag: fc.constant(\"Left\" as const), left: left(fc) }),\n    fc.record({ _tag: fc.constant(\"Right\" as const), right: right(fc) })\n  ).map(eitherDecode)\n\nconst eitherPretty = <R, L>(\n  right: pretty_.Pretty<R>,\n  left: pretty_.Pretty<L>\n): pretty_.Pretty<either_.Either<R, L>> =>\n  either_.match({\n    onLeft: (e) => `left(${left(e)})`,\n    onRight: (a) => `right(${right(a)})`\n  })\n\nconst eitherParse = <RR, R, LR, L>(\n  parseRight: ParseResult.DecodeUnknown<R, RR>,\n  decodeUnknownLeft: ParseResult.DecodeUnknown<L, LR>\n): ParseResult.DeclarationDecodeUnknown<either_.Either<R, L>, LR | RR> =>\n(u, options, ast) =>\n  either_.isEither(u) ?\n    either_.match(u, {\n      onLeft: (left) => toComposite(decodeUnknownLeft(left, options), either_.left, ast, u),\n      onRight: (right) => toComposite(parseRight(right, options), either_.right, ast, u)\n    })\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface EitherFromSelf<R extends Schema.All, L extends Schema.All> extends\n  AnnotableClass<\n    EitherFromSelf<R, L>,\n    either_.Either<Schema.Type<R>, Schema.Type<L>>,\n    either_.Either<Schema.Encoded<R>, Schema.Encoded<L>>,\n    Schema.Context<R> | Schema.Context<L>\n  >\n{}\n\n/**\n * @category Either transformations\n * @since 3.10.0\n */\nexport const EitherFromSelf = <R extends Schema.All, L extends Schema.All>({ left, right }: {\n  readonly left: L\n  readonly right: R\n}): EitherFromSelf<R, L> => {\n  return declare(\n    [right, left],\n    {\n      decode: (right, left) => eitherParse(ParseResult.decodeUnknown(right), ParseResult.decodeUnknown(left)),\n      encode: (right, left) => eitherParse(ParseResult.encodeUnknown(right), ParseResult.encodeUnknown(left))\n    },\n    {\n      description: `Either<${format(right)}, ${format(left)}>`,\n      pretty: eitherPretty,\n      arbitrary: eitherArbitrary,\n      equivalence: (right, left) => either_.getEquivalence({ left, right })\n    }\n  )\n}\n\nconst makeLeftEncoded = <E>(left: E) => (({\n  _tag: \"Left\",\n  left\n}) as const)\nconst makeRightEncoded = <A>(right: A) => (({\n  _tag: \"Right\",\n  right\n}) as const)\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Either<R extends Schema.All, L extends Schema.All> extends\n  AnnotableClass<\n    Either<R, L>,\n    either_.Either<Schema.Type<R>, Schema.Type<L>>,\n    EitherEncoded<Schema.Encoded<R>, Schema.Encoded<L>>,\n    Schema.Context<R> | Schema.Context<L>\n  >\n{}\n\n/**\n * @category Either transformations\n * @since 3.10.0\n */\nexport const Either = <R extends Schema.All, L extends Schema.All>({ left, right }: {\n  readonly left: L\n  readonly right: R\n}): Either<R, L> => {\n  const right_ = asSchema(right)\n  const left_ = asSchema(left)\n  return transform(\n    eitherEncoded(right_, left_),\n    EitherFromSelf({ left: typeSchema(left_), right: typeSchema(right_) }),\n    {\n      strict: true,\n      decode: eitherDecode,\n      encode: either_.match({ onLeft: makeLeftEncoded, onRight: makeRightEncoded })\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface EitherFromUnion<R extends Schema.All, L extends Schema.All> extends\n  AnnotableClass<\n    EitherFromUnion<R, L>,\n    either_.Either<Schema.Type<R>, Schema.Type<L>>,\n    Schema.Encoded<R> | Schema.Encoded<L>,\n    Schema.Context<R> | Schema.Context<L>\n  >\n{}\n\n/**\n * @example\n * ```ts\n * import * as Schema from \"effect/Schema\"\n *\n * // Schema<string | number, Either<string, number>>\n * Schema.EitherFromUnion({ left: Schema.String, right: Schema.Number })\n * ```\n *\n * @category Either transformations\n * @since 3.10.0\n */\nexport const EitherFromUnion = <R extends Schema.All, L extends Schema.All>({ left, right }: {\n  readonly left: L\n  readonly right: R\n}): EitherFromUnion<R, L> => {\n  const right_ = asSchema(right)\n  const left_ = asSchema(left)\n  const toright = typeSchema(right_)\n  const toleft = typeSchema(left_)\n  const fromRight = transform(right_, rightEncoded(toright), {\n    strict: true,\n    decode: makeRightEncoded,\n    encode: (r) => r.right\n  })\n  const fromLeft = transform(left_, leftEncoded(toleft), {\n    strict: true,\n    decode: makeLeftEncoded,\n    encode: (l) => l.left\n  })\n  return transform(\n    Union(fromRight, fromLeft),\n    EitherFromSelf({ left: toleft, right: toright }),\n    {\n      strict: true,\n      decode: (from) => from._tag === \"Left\" ? either_.left(from.left) : either_.right(from.right),\n      encode: either_.match({ onLeft: makeLeftEncoded, onRight: makeRightEncoded })\n    }\n  )\n}\n\nconst mapArbitrary = <K, V>(\n  key: LazyArbitrary<K>,\n  value: LazyArbitrary<V>,\n  ctx: ArbitraryGenerationContext\n): LazyArbitrary<Map<K, V>> => {\n  return (fc) => {\n    const items = fc.array(fc.tuple(key(fc), value(fc)))\n    return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map((as) => new Map(as))\n  }\n}\n\nconst readonlyMapPretty = <K, V>(\n  key: pretty_.Pretty<K>,\n  value: pretty_.Pretty<V>\n): pretty_.Pretty<ReadonlyMap<K, V>> =>\n(map) =>\n  `new Map([${\n    Array.from(map.entries())\n      .map(([k, v]) => `[${key(k)}, ${value(v)}]`)\n      .join(\", \")\n  }])`\n\nconst readonlyMapEquivalence = <K, V>(\n  key: Equivalence.Equivalence<K>,\n  value: Equivalence.Equivalence<V>\n): Equivalence.Equivalence<ReadonlyMap<K, V>> => {\n  const arrayEquivalence = array_.getEquivalence(\n    Equivalence.make<[K, V]>(([ka, va], [kb, vb]) => key(ka, kb) && value(va, vb))\n  )\n  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a.entries()), Array.from(b.entries())))\n}\n\nconst readonlyMapParse = <R, K, V>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<readonly [K, V]>, R>\n): ParseResult.DeclarationDecodeUnknown<ReadonlyMap<K, V>, R> =>\n(u, options, ast) =>\n  Predicate.isMap(u) ?\n    toComposite(decodeUnknown(Array.from(u.entries()), options), (as) => new Map(as), ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface ReadonlyMapFromSelf<K extends Schema.Any, V extends Schema.Any> extends\n  AnnotableClass<\n    ReadonlyMapFromSelf<K, V>,\n    ReadonlyMap<Schema.Type<K>, Schema.Type<V>>,\n    ReadonlyMap<Schema.Encoded<K>, Schema.Encoded<V>>,\n    Schema.Context<K> | Schema.Context<V>\n  >\n{}\n\nconst mapFromSelf_ = <K extends Schema.Any, V extends Schema.Any>(\n  key: K,\n  value: V,\n  description: string\n): ReadonlyMapFromSelf<K, V> =>\n  declare(\n    [key, value],\n    {\n      decode: (Key, Value) => readonlyMapParse(ParseResult.decodeUnknown(Array$(Tuple(Key, Value)))),\n      encode: (Key, Value) => readonlyMapParse(ParseResult.encodeUnknown(Array$(Tuple(Key, Value))))\n    },\n    {\n      description,\n      pretty: readonlyMapPretty,\n      arbitrary: mapArbitrary,\n      equivalence: readonlyMapEquivalence\n    }\n  )\n\n/**\n * @category ReadonlyMap\n * @since 3.10.0\n */\nexport const ReadonlyMapFromSelf = <K extends Schema.Any, V extends Schema.Any>({ key, value }: {\n  readonly key: K\n  readonly value: V\n}): ReadonlyMapFromSelf<K, V> => mapFromSelf_(key, value, `ReadonlyMap<${format(key)}, ${format(value)}>`)\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface MapFromSelf<K extends Schema.Any, V extends Schema.Any> extends\n  AnnotableClass<\n    MapFromSelf<K, V>,\n    Map<Schema.Type<K>, Schema.Type<V>>,\n    ReadonlyMap<Schema.Encoded<K>, Schema.Encoded<V>>,\n    Schema.Context<K> | Schema.Context<V>\n  >\n{}\n\n/**\n * @category Map\n * @since 3.10.0\n */\nexport const MapFromSelf = <K extends Schema.Any, V extends Schema.Any>({ key, value }: {\n  readonly key: K\n  readonly value: V\n}): MapFromSelf<K, V> => mapFromSelf_(key, value, `Map<${format(key)}, ${format(value)}>`) as any\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface ReadonlyMap$<K extends Schema.Any, V extends Schema.Any> extends\n  AnnotableClass<\n    ReadonlyMap$<K, V>,\n    ReadonlyMap<Schema.Type<K>, Schema.Type<V>>,\n    ReadonlyArray<readonly [Schema.Encoded<K>, Schema.Encoded<V>]>,\n    Schema.Context<K> | Schema.Context<V>\n  >\n{}\n\n/**\n * @category ReadonlyMap transformations\n * @since 3.10.0\n */\nexport const ReadonlyMap = <K extends Schema.Any, V extends Schema.Any>({ key, value }: {\n  readonly key: K\n  readonly value: V\n}): ReadonlyMap$<K, V> => {\n  const key_ = asSchema(key)\n  const value_ = asSchema(value)\n  return transform(\n    Array$(Tuple(key_, value_)),\n    ReadonlyMapFromSelf({ key: typeSchema(key_), value: typeSchema(value_) }),\n    { strict: true, decode: (as) => new Map(as), encode: (map) => Array.from(map.entries()) }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Map$<K extends Schema.Any, V extends Schema.Any> extends\n  AnnotableClass<\n    Map$<K, V>,\n    Map<Schema.Type<K>, Schema.Type<V>>,\n    ReadonlyArray<readonly [Schema.Encoded<K>, Schema.Encoded<V>]>,\n    Schema.Context<K> | Schema.Context<V>\n  >\n{}\n\nconst map = <K extends Schema.Any, V extends Schema.Any>({ key, value }: {\n  readonly key: K\n  readonly value: V\n}): Map$<K, V> => {\n  const key_ = asSchema(key)\n  const value_ = asSchema(value)\n  return transform(\n    Array$(Tuple(key_, value_)),\n    MapFromSelf({ key: typeSchema(key_), value: typeSchema(value_) }),\n    { strict: true, decode: (as) => new Map(as), encode: (map) => Array.from(map.entries()) }\n  )\n}\n\nexport {\n  /**\n   * @category Map transformations\n   * @since 3.10.0\n   */\n  map as Map\n}\n\n/**\n * @category ReadonlyMap transformations\n * @since 3.10.0\n */\nexport const ReadonlyMapFromRecord = <KA, KR, VA, VI, VR>({ key, value }: {\n  key: Schema<KA, string, KR>\n  value: Schema<VA, VI, VR>\n}): Schema<ReadonlyMap<KA, VA>, { readonly [x: string]: VI }, KR | VR> =>\n  transform(\n    Record({ key: encodedBoundSchema(key), value }).annotations({\n      description: \"a record that will be parsed into a ReadonlyMap\"\n    }),\n    ReadonlyMapFromSelf({ key, value: typeSchema(value) }),\n    {\n      strict: true,\n      decode: (record) => new Map(Object.entries(record)),\n      encode: record_.fromEntries\n    }\n  )\n\n/**\n * @category Map transformations\n * @since 3.10.0\n */\nexport const MapFromRecord = <KA, KR, VA, VI, VR>({ key, value }: {\n  key: Schema<KA, string, KR>\n  value: Schema<VA, VI, VR>\n}): Schema<Map<KA, VA>, { readonly [x: string]: VI }, KR | VR> =>\n  transform(\n    Record({ key: encodedBoundSchema(key), value }).annotations({\n      description: \"a record that will be parsed into a Map\"\n    }),\n    MapFromSelf({ key, value: typeSchema(value) }),\n    {\n      strict: true,\n      decode: (record) => new Map(Object.entries(record)),\n      encode: record_.fromEntries\n    }\n  )\n\nconst setArbitrary =\n  <A>(item: LazyArbitrary<A>, ctx: ArbitraryGenerationContext): LazyArbitrary<ReadonlySet<A>> => (fc) => {\n    const items = fc.array(item(fc))\n    return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map((as) => new Set(as))\n  }\n\nconst readonlySetPretty = <A>(item: pretty_.Pretty<A>): pretty_.Pretty<ReadonlySet<A>> => (set) =>\n  `new Set([${Array.from(set.values()).map((a) => item(a)).join(\", \")}])`\n\nconst readonlySetEquivalence = <A>(\n  item: Equivalence.Equivalence<A>\n): Equivalence.Equivalence<ReadonlySet<A>> => {\n  const arrayEquivalence = array_.getEquivalence(item)\n  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a.values()), Array.from(b.values())))\n}\n\nconst readonlySetParse = <A, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<A>, R>\n): ParseResult.DeclarationDecodeUnknown<ReadonlySet<A>, R> =>\n(u, options, ast) =>\n  Predicate.isSet(u) ?\n    toComposite(decodeUnknown(Array.from(u.values()), options), (as) => new Set(as), ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface ReadonlySetFromSelf<Value extends Schema.Any> extends\n  AnnotableClass<\n    ReadonlySetFromSelf<Value>,\n    ReadonlySet<Schema.Type<Value>>,\n    ReadonlySet<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\nconst setFromSelf_ = <Value extends Schema.Any>(value: Value, description: string): ReadonlySetFromSelf<Value> =>\n  declare(\n    [value],\n    {\n      decode: (item) => readonlySetParse(ParseResult.decodeUnknown(Array$(item))),\n      encode: (item) => readonlySetParse(ParseResult.encodeUnknown(Array$(item)))\n    },\n    {\n      description,\n      pretty: readonlySetPretty,\n      arbitrary: setArbitrary,\n      equivalence: readonlySetEquivalence\n    }\n  )\n\n/**\n * @category ReadonlySet\n * @since 3.10.0\n */\nexport const ReadonlySetFromSelf = <Value extends Schema.Any>(value: Value): ReadonlySetFromSelf<Value> =>\n  setFromSelf_(value, `ReadonlySet<${format(value)}>`)\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface SetFromSelf<Value extends Schema.Any> extends\n  AnnotableClass<\n    SetFromSelf<Value>,\n    Set<Schema.Type<Value>>,\n    ReadonlySet<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Set\n * @since 3.10.0\n */\nexport const SetFromSelf = <Value extends Schema.Any>(value: Value): SetFromSelf<Value> =>\n  setFromSelf_(value, `Set<${format(value)}>`) as any\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface ReadonlySet$<Value extends Schema.Any> extends\n  AnnotableClass<\n    ReadonlySet$<Value>,\n    ReadonlySet<Schema.Type<Value>>,\n    ReadonlyArray<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category ReadonlySet transformations\n * @since 3.10.0\n */\nexport const ReadonlySet = <Value extends Schema.Any>(value: Value): ReadonlySet$<Value> => {\n  const value_ = asSchema(value)\n  return transform(\n    Array$(value_),\n    ReadonlySetFromSelf(typeSchema(value_)),\n    { strict: true, decode: (as) => new Set(as), encode: (set) => Array.from(set) }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Set$<Value extends Schema.Any> extends\n  AnnotableClass<\n    Set$<Value>,\n    Set<Schema.Type<Value>>,\n    ReadonlyArray<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\nconst set = <Value extends Schema.Any>(value: Value): Set$<Value> => {\n  const value_ = asSchema(value)\n  return transform(\n    Array$(value_),\n    SetFromSelf(typeSchema(value_)),\n    { strict: true, decode: (as) => new Set(as), encode: (set) => Array.from(set) }\n  )\n}\n\nexport {\n  /**\n   * @category Set transformations\n   * @since 3.10.0\n   */\n  set as Set\n}\n\nconst bigDecimalPretty = (): pretty_.Pretty<bigDecimal_.BigDecimal> => (val) =>\n  `BigDecimal(${bigDecimal_.format(bigDecimal_.normalize(val))})`\n\nconst bigDecimalArbitrary = (): LazyArbitrary<bigDecimal_.BigDecimal> => (fc) =>\n  fc.tuple(fc.bigInt(), fc.integer({ min: 0, max: 18 }))\n    .map(([value, scale]) => bigDecimal_.make(value, scale))\n\n/**\n * @category BigDecimal constructors\n * @since 3.10.0\n */\nexport class BigDecimalFromSelf extends declare(\n  bigDecimal_.isBigDecimal,\n  {\n    identifier: \"BigDecimalFromSelf\",\n    pretty: bigDecimalPretty,\n    arbitrary: bigDecimalArbitrary,\n    equivalence: () => bigDecimal_.Equivalence\n  }\n) {}\n\n/**\n * @category BigDecimal transformations\n * @since 3.10.0\n */\nexport class BigDecimal extends transformOrFail(\n  String$.annotations({ description: \"a string that will be parsed into a BigDecimal\" }),\n  BigDecimalFromSelf,\n  {\n    strict: true,\n    decode: (num, _, ast) =>\n      bigDecimal_.fromString(num).pipe(option_.match({\n        onNone: () => ParseResult.fail(new ParseResult.Type(ast, num)),\n        onSome: (val) => ParseResult.succeed(bigDecimal_.normalize(val))\n      })),\n    encode: (val) => ParseResult.succeed(bigDecimal_.format(bigDecimal_.normalize(val)))\n  }\n).annotations({ identifier: \"BigDecimal\" }) {}\n\n/**\n * A schema that transforms a `number` into a `BigDecimal`.\n * When encoding, this Schema will produce incorrect results if the BigDecimal exceeds the 64-bit range of a number.\n *\n * @category BigDecimal transformations\n * @since 3.10.0\n */\nexport class BigDecimalFromNumber extends transformOrFail(\n  Number$.annotations({ description: \"a number that will be parsed into a BigDecimal\" }),\n  BigDecimalFromSelf,\n  {\n    strict: true,\n    decode: (num) => ParseResult.succeed(bigDecimal_.unsafeFromNumber(num)),\n    encode: (val) => ParseResult.succeed(bigDecimal_.unsafeToNumber(val))\n  }\n).annotations({ identifier: \"BigDecimalFromNumber\" }) {}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanBigDecimalSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/GreaterThanBigDecimal\")\n\n/**\n * @category BigDecimal filters\n * @since 3.10.0\n */\nexport const greaterThanBigDecimal = <A extends bigDecimal_.BigDecimal>(\n  min: bigDecimal_.BigDecimal,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> => {\n  const formatted = bigDecimal_.format(min)\n  return self.pipe(\n    filter((a) => bigDecimal_.greaterThan(a, min), {\n      schemaId: GreaterThanBigDecimalSchemaId,\n      [GreaterThanBigDecimalSchemaId]: { min },\n      title: `greaterThanBigDecimal(${formatted})`,\n      description: `a BigDecimal greater than ${formatted}`,\n      ...annotations\n    })\n  )\n}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanOrEqualToBigDecimalSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/GreaterThanOrEqualToBigDecimal\"\n)\n\n/**\n * @category BigDecimal filters\n * @since 3.10.0\n */\nexport const greaterThanOrEqualToBigDecimal = <A extends bigDecimal_.BigDecimal>(\n  min: bigDecimal_.BigDecimal,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> => {\n  const formatted = bigDecimal_.format(min)\n  return self.pipe(\n    filter((a) => bigDecimal_.greaterThanOrEqualTo(a, min), {\n      schemaId: GreaterThanOrEqualToBigDecimalSchemaId,\n      [GreaterThanOrEqualToBigDecimalSchemaId]: { min },\n      title: `greaterThanOrEqualToBigDecimal(${formatted})`,\n      description: `a BigDecimal greater than or equal to ${formatted}`,\n      ...annotations\n    })\n  )\n}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanBigDecimalSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/LessThanBigDecimal\")\n\n/**\n * @category BigDecimal filters\n * @since 3.10.0\n */\nexport const lessThanBigDecimal = <A extends bigDecimal_.BigDecimal>(\n  max: bigDecimal_.BigDecimal,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> => {\n  const formatted = bigDecimal_.format(max)\n  return self.pipe(\n    filter((a) => bigDecimal_.lessThan(a, max), {\n      schemaId: LessThanBigDecimalSchemaId,\n      [LessThanBigDecimalSchemaId]: { max },\n      title: `lessThanBigDecimal(${formatted})`,\n      description: `a BigDecimal less than ${formatted}`,\n      ...annotations\n    })\n  )\n}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanOrEqualToBigDecimalSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/LessThanOrEqualToBigDecimal\"\n)\n\n/**\n * @category BigDecimal filters\n * @since 3.10.0\n */\nexport const lessThanOrEqualToBigDecimal = <A extends bigDecimal_.BigDecimal>(\n  max: bigDecimal_.BigDecimal,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> => {\n  const formatted = bigDecimal_.format(max)\n  return self.pipe(\n    filter((a) => bigDecimal_.lessThanOrEqualTo(a, max), {\n      schemaId: LessThanOrEqualToBigDecimalSchemaId,\n      [LessThanOrEqualToBigDecimalSchemaId]: { max },\n      title: `lessThanOrEqualToBigDecimal(${formatted})`,\n      description: `a BigDecimal less than or equal to ${formatted}`,\n      ...annotations\n    })\n  )\n}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const PositiveBigDecimalSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/PositiveBigDecimal\"\n)\n\n/**\n * @category BigDecimal filters\n * @since 3.10.0\n */\nexport const positiveBigDecimal = <A extends bigDecimal_.BigDecimal>(\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => bigDecimal_.isPositive(a), {\n      schemaId: PositiveBigDecimalSchemaId,\n      title: \"positiveBigDecimal\",\n      description: `a positive BigDecimal`,\n      ...annotations\n    })\n  )\n\n/**\n * @category BigDecimal constructors\n * @since 3.10.0\n */\nexport const PositiveBigDecimalFromSelf: filter<Schema<bigDecimal_.BigDecimal>> = BigDecimalFromSelf.pipe(\n  positiveBigDecimal({ identifier: \"PositiveBigDecimalFromSelf\" })\n)\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const NonNegativeBigDecimalSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/NonNegativeBigDecimal\"\n)\n\n/**\n * @category BigDecimal filters\n * @since 3.10.0\n */\nexport const nonNegativeBigDecimal = <A extends bigDecimal_.BigDecimal>(\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a.value >= 0n, {\n      schemaId: NonNegativeBigDecimalSchemaId,\n      title: \"nonNegativeBigDecimal\",\n      description: `a non-negative BigDecimal`,\n      ...annotations\n    })\n  )\n\n/**\n * @category BigDecimal constructors\n * @since 3.10.0\n */\nexport const NonNegativeBigDecimalFromSelf: filter<Schema<bigDecimal_.BigDecimal>> = BigDecimalFromSelf.pipe(\n  nonNegativeBigDecimal({ identifier: \"NonNegativeBigDecimalFromSelf\" })\n)\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const NegativeBigDecimalSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/NegativeBigDecimal\"\n)\n\n/**\n * @category BigDecimal filters\n * @since 3.10.0\n */\nexport const negativeBigDecimal = <A extends bigDecimal_.BigDecimal>(\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => bigDecimal_.isNegative(a), {\n      schemaId: NegativeBigDecimalSchemaId,\n      title: \"negativeBigDecimal\",\n      description: `a negative BigDecimal`,\n      ...annotations\n    })\n  )\n\n/**\n * @category BigDecimal constructors\n * @since 3.10.0\n */\nexport const NegativeBigDecimalFromSelf: filter<Schema<bigDecimal_.BigDecimal>> = BigDecimalFromSelf.pipe(\n  negativeBigDecimal({ identifier: \"NegativeBigDecimalFromSelf\" })\n)\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const NonPositiveBigDecimalSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/NonPositiveBigDecimal\"\n)\n\n/**\n * @category BigDecimal filters\n * @since 3.10.0\n */\nexport const nonPositiveBigDecimal = <A extends bigDecimal_.BigDecimal>(\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a.value <= 0n, {\n      schemaId: NonPositiveBigDecimalSchemaId,\n      title: \"nonPositiveBigDecimal\",\n      description: `a non-positive BigDecimal`,\n      ...annotations\n    })\n  )\n\n/**\n * @category BigDecimal constructors\n * @since 3.10.0\n */\nexport const NonPositiveBigDecimalFromSelf: filter<Schema<bigDecimal_.BigDecimal>> = BigDecimalFromSelf.pipe(\n  nonPositiveBigDecimal({ identifier: \"NonPositiveBigDecimalFromSelf\" })\n)\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const BetweenBigDecimalSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/BetweenBigDecimal\")\n\n/**\n * @category BigDecimal filters\n * @since 3.10.0\n */\nexport const betweenBigDecimal = <A extends bigDecimal_.BigDecimal>(\n  minimum: bigDecimal_.BigDecimal,\n  maximum: bigDecimal_.BigDecimal,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> => {\n  const formattedMinimum = bigDecimal_.format(minimum)\n  const formattedMaximum = bigDecimal_.format(maximum)\n  return self.pipe(\n    filter((a) => bigDecimal_.between(a, { minimum, maximum }), {\n      schemaId: BetweenBigDecimalSchemaId,\n      [BetweenBigDecimalSchemaId]: { maximum, minimum },\n      title: `betweenBigDecimal(${formattedMinimum}, ${formattedMaximum})`,\n      description: `a BigDecimal between ${formattedMinimum} and ${formattedMaximum}`,\n      ...annotations\n    })\n  )\n}\n\n/**\n * Clamps a `BigDecimal` between a minimum and a maximum value.\n *\n * @category BigDecimal transformations\n * @since 3.10.0\n */\nexport const clampBigDecimal =\n  (minimum: bigDecimal_.BigDecimal, maximum: bigDecimal_.BigDecimal) =>\n  <A extends bigDecimal_.BigDecimal, I, R>(self: Schema<A, I, R>): transform<Schema<A, I, R>, filter<Schema<A>>> =>\n    transform(\n      self,\n      self.pipe(typeSchema, betweenBigDecimal(minimum, maximum)),\n      { strict: false, decode: (self) => bigDecimal_.clamp(self, { minimum, maximum }), encode: identity }\n    )\n\nconst chunkArbitrary =\n  <A>(item: LazyArbitrary<A>, ctx: ArbitraryGenerationContext): LazyArbitrary<chunk_.Chunk<A>> => (fc) => {\n    const items = fc.array(item(fc))\n    return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map(chunk_.fromIterable)\n  }\n\nconst chunkPretty = <A>(item: pretty_.Pretty<A>): pretty_.Pretty<chunk_.Chunk<A>> => (c) =>\n  `Chunk(${chunk_.toReadonlyArray(c).map(item).join(\", \")})`\n\nconst chunkParse = <A, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<A>, R>\n): ParseResult.DeclarationDecodeUnknown<chunk_.Chunk<A>, R> =>\n(u, options, ast) =>\n  chunk_.isChunk(u) ?\n    chunk_.isEmpty(u) ?\n      ParseResult.succeed(chunk_.empty())\n      : toComposite(decodeUnknown(chunk_.toReadonlyArray(u), options), chunk_.fromIterable, ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface ChunkFromSelf<Value extends Schema.Any> extends\n  AnnotableClass<\n    ChunkFromSelf<Value>,\n    chunk_.Chunk<Schema.Type<Value>>,\n    chunk_.Chunk<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Chunk\n * @since 3.10.0\n */\nexport const ChunkFromSelf = <Value extends Schema.Any>(value: Value): ChunkFromSelf<Value> => {\n  return declare(\n    [value],\n    {\n      decode: (item) => chunkParse(ParseResult.decodeUnknown(Array$(item))),\n      encode: (item) => chunkParse(ParseResult.encodeUnknown(Array$(item)))\n    },\n    {\n      description: `Chunk<${format(value)}>`,\n      pretty: chunkPretty,\n      arbitrary: chunkArbitrary,\n      equivalence: chunk_.getEquivalence\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Chunk<Value extends Schema.Any> extends\n  AnnotableClass<\n    Chunk<Value>,\n    chunk_.Chunk<Schema.Type<Value>>,\n    ReadonlyArray<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Chunk transformations\n * @since 3.10.0\n */\nexport const Chunk = <Value extends Schema.Any>(value: Value): Chunk<Value> => {\n  const value_ = asSchema(value)\n  return transform(\n    Array$(value_),\n    ChunkFromSelf(typeSchema(value_)),\n    {\n      strict: true,\n      decode: (as) => as.length === 0 ? chunk_.empty() : chunk_.fromIterable(as),\n      encode: chunk_.toReadonlyArray\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface NonEmptyChunkFromSelf<Value extends Schema.Any> extends\n  AnnotableClass<\n    NonEmptyChunkFromSelf<Value>,\n    chunk_.NonEmptyChunk<Schema.Type<Value>>,\n    chunk_.NonEmptyChunk<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\nconst nonEmptyChunkArbitrary = <A>(item: LazyArbitrary<A>): LazyArbitrary<chunk_.NonEmptyChunk<A>> => (fc) =>\n  fastCheck_.array(item(fc), { minLength: 1 }).map((as) => chunk_.unsafeFromNonEmptyArray(as as any))\n\nconst nonEmptyChunkPretty = <A>(item: pretty_.Pretty<A>): pretty_.Pretty<chunk_.NonEmptyChunk<A>> => (c) =>\n  `NonEmptyChunk(${chunk_.toReadonlyArray(c).map(item).join(\", \")})`\n\nconst nonEmptyChunkParse = <A, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<array_.NonEmptyReadonlyArray<A>, R>\n): ParseResult.DeclarationDecodeUnknown<chunk_.NonEmptyChunk<A>, R> =>\n(u, options, ast) =>\n  chunk_.isChunk(u) && chunk_.isNonEmpty(u)\n    ? toComposite(decodeUnknown(chunk_.toReadonlyArray(u), options), chunk_.unsafeFromNonEmptyArray, ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category Chunk\n * @since 3.10.0\n */\nexport const NonEmptyChunkFromSelf = <Value extends Schema.Any>(value: Value): NonEmptyChunkFromSelf<Value> => {\n  return declare(\n    [value],\n    {\n      decode: (item) => nonEmptyChunkParse(ParseResult.decodeUnknown(NonEmptyArray(item))),\n      encode: (item) => nonEmptyChunkParse(ParseResult.encodeUnknown(NonEmptyArray(item)))\n    },\n    {\n      description: `NonEmptyChunk<${format(value)}>`,\n      pretty: nonEmptyChunkPretty,\n      arbitrary: nonEmptyChunkArbitrary,\n      equivalence: chunk_.getEquivalence\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface NonEmptyChunk<Value extends Schema.Any> extends\n  AnnotableClass<\n    NonEmptyChunk<Value>,\n    chunk_.NonEmptyChunk<Schema.Type<Value>>,\n    array_.NonEmptyReadonlyArray<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Chunk transformations\n * @since 3.10.0\n */\nexport const NonEmptyChunk = <Value extends Schema.Any>(value: Value): NonEmptyChunk<Value> => {\n  const value_ = asSchema(value)\n  return transform(\n    NonEmptyArray(value_),\n    NonEmptyChunkFromSelf(typeSchema(value_)),\n    { strict: true, decode: chunk_.unsafeFromNonEmptyArray, encode: chunk_.toReadonlyArray }\n  )\n}\n\nconst toData = <A extends Readonly<Record<string, any>> | ReadonlyArray<any>>(a: A): A =>\n  Array.isArray(a) ? data_.array(a) : data_.struct(a)\n\nconst dataArbitrary = <A extends Readonly<Record<string, any>> | ReadonlyArray<any>>(\n  item: LazyArbitrary<A>\n): LazyArbitrary<A> =>\n(fc) => item(fc).map(toData)\n\nconst dataPretty = <A extends Readonly<Record<string, any>> | ReadonlyArray<any>>(\n  item: pretty_.Pretty<A>\n): pretty_.Pretty<A> =>\n(d) => `Data(${item(d)})`\n\nconst dataParse = <R, A extends Readonly<Record<string, any>> | ReadonlyArray<any>>(\n  decodeUnknown: ParseResult.DecodeUnknown<A, R>\n): ParseResult.DeclarationDecodeUnknown<A, R> =>\n(u, options, ast) =>\n  Equal.isEqual(u) ?\n    toComposite(decodeUnknown(u, options), toData, ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category Data transformations\n * @since 3.10.0\n */\nexport const DataFromSelf = <\n  R,\n  I extends Readonly<Record<string, any>> | ReadonlyArray<any>,\n  A extends Readonly<Record<string, any>> | ReadonlyArray<any>\n>(\n  item: Schema<A, I, R>\n): SchemaClass<A, I, R> =>\n  declare(\n    [item],\n    {\n      decode: (item) => dataParse(ParseResult.decodeUnknown(item)),\n      encode: (item) => dataParse(ParseResult.encodeUnknown(item))\n    },\n    {\n      description: `Data<${format(item)}>`,\n      pretty: dataPretty,\n      arbitrary: dataArbitrary\n    }\n  )\n\n/**\n * @category Data transformations\n * @since 3.10.0\n */\nexport const Data = <\n  R,\n  I extends Readonly<Record<string, any>> | ReadonlyArray<any>,\n  A extends Readonly<Record<string, any>> | ReadonlyArray<any>\n>(\n  item: Schema<A, I, R>\n): SchemaClass<A, I, R> =>\n  transform(\n    item,\n    DataFromSelf(typeSchema(item)),\n    { strict: false, decode: toData, encode: (a) => Array.isArray(a) ? Array.from(a) : Object.assign({}, a) }\n  )\n\ntype MissingSelfGeneric<Usage extends string, Params extends string = \"\"> =\n  `Missing \\`Self\\` generic - use \\`class Self extends ${Usage}<Self>()(${Params}{ ... })\\``\n\ntype RequiredKeys<T> = {\n  [K in keyof T]-?: {} extends Pick<T, K> ? never : K\n}[keyof T]\n\ntype ClassAnnotations<Self, A> =\n  | Annotations.Schema<Self>\n  | readonly [\n    Annotations.Schema<Self> | undefined,\n    Annotations.Schema<Self>?,\n    Annotations.Schema<A>?\n  ]\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Class<Self, Fields extends Struct.Fields, I, R, C, Inherited, Proto>\n  extends Schema<Self, Simplify<I>, R>\n{\n  new(\n    props: RequiredKeys<C> extends never ? void | Simplify<C> : Simplify<C>,\n    options?: MakeOptions\n  ): Struct.Type<Fields> & Inherited & Proto\n\n  /** @since 3.10.0 */\n  readonly ast: AST.Transformation\n\n  make<Args extends Array<any>, X>(this: { new(...args: Args): X }, ...args: Args): X\n\n  annotations(annotations: Annotations.Schema<Self>): SchemaClass<Self, Simplify<I>, R>\n\n  readonly fields: { readonly [K in keyof Fields]: Fields[K] }\n\n  readonly identifier: string\n\n  /**\n   * @example\n   * ```ts\n   * import { Schema } from \"effect\"\n   *\n   * class MyClass extends Schema.Class<MyClass>(\"MyClass\")({\n   *  myField: Schema.String\n   * }) {\n   *  myMethod() {\n   *    return this.myField + \"my\"\n   *  }\n   * }\n   *\n   * class NextClass extends MyClass.extend<NextClass>(\"NextClass\")({\n   *  nextField: Schema.Number\n   * }) {\n   *  nextMethod() {\n   *    return this.myMethod() + this.myField + this.nextField\n   *  }\n   * }\n   * ```\n   */\n  extend<Extended = never>(identifier: string): <NewFields extends Struct.Fields>(\n    fields: NewFields | HasFields<NewFields>,\n    annotations?: ClassAnnotations<Extended, Struct.Type<Fields & NewFields>>\n  ) => [Extended] extends [never] ? MissingSelfGeneric<\"Base.extend\">\n    : Class<\n      Extended,\n      Fields & NewFields,\n      I & Struct.Encoded<NewFields>,\n      R | Struct.Context<NewFields>,\n      C & Struct.Constructor<NewFields>,\n      Self,\n      Proto\n    >\n\n  /**\n   * @example\n   * ```ts\n   * import { Effect, Schema } from \"effect\"\n   *\n   * class MyClass extends Schema.Class<MyClass>(\"MyClass\")({\n   *   myField: Schema.String\n   * }) {\n   *   myMethod() {\n   *     return this.myField + \"my\"\n   *   }\n   * }\n   *\n   * class NextClass extends MyClass.transformOrFail<NextClass>(\"NextClass\")({\n   *   nextField: Schema.Number\n   * }, {\n   *   decode: (i) =>\n   *     Effect.succeed({\n   *       myField: i.myField,\n   *       nextField: i.myField.length\n   *     }),\n   *   encode: (a) => Effect.succeed({ myField: a.myField })\n   * }) {\n   *   nextMethod() {\n   *     return this.myMethod() + this.myField + this.nextField\n   *   }\n   * }\n   * ```\n   */\n  transformOrFail<Transformed = never>(identifier: string): <\n    NewFields extends Struct.Fields,\n    R2,\n    R3\n  >(\n    fields: NewFields,\n    options: {\n      readonly decode: (\n        input: Simplify<Struct.Type<Fields>>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<Simplify<Struct.Type<Fields & NewFields>>, ParseResult.ParseIssue, R2>\n      readonly encode: (\n        input: Simplify<Struct.Type<Fields & NewFields>>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<Struct.Type<Fields>, ParseResult.ParseIssue, R3>\n    },\n    annotations?: ClassAnnotations<Transformed, Struct.Type<Fields & NewFields>>\n  ) => [Transformed] extends [never] ? MissingSelfGeneric<\"Base.transformOrFail\">\n    : Class<\n      Transformed,\n      Fields & NewFields,\n      I,\n      R | Struct.Context<NewFields> | R2 | R3,\n      C & Struct.Constructor<NewFields>,\n      Self,\n      Proto\n    >\n\n  /**\n   * @example\n   * ```ts\n   * import { Effect, Schema } from \"effect\"\n   *\n   * class MyClass extends Schema.Class<MyClass>(\"MyClass\")({\n   *   myField: Schema.String\n   * }) {\n   *   myMethod() {\n   *     return this.myField + \"my\"\n   *   }\n   * }\n   *\n   * class NextClass extends MyClass.transformOrFailFrom<NextClass>(\"NextClass\")({\n   *   nextField: Schema.Number\n   * }, {\n   *   decode: (i) =>\n   *     Effect.succeed({\n   *       myField: i.myField,\n   *       nextField: i.myField.length\n   *     }),\n   *   encode: (a) => Effect.succeed({ myField: a.myField })\n   * }) {\n   *   nextMethod() {\n   *     return this.myMethod() + this.myField + this.nextField\n   *   }\n   * }\n   * ```\n   */\n  transformOrFailFrom<Transformed = never>(identifier: string): <\n    NewFields extends Struct.Fields,\n    R2,\n    R3\n  >(\n    fields: NewFields,\n    options: {\n      readonly decode: (\n        input: Simplify<I>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<Simplify<I & Struct.Encoded<NewFields>>, ParseResult.ParseIssue, R2>\n      readonly encode: (\n        input: Simplify<I & Struct.Encoded<NewFields>>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<I, ParseResult.ParseIssue, R3>\n    },\n    annotations?: ClassAnnotations<Transformed, Struct.Type<Fields & NewFields>>\n  ) => [Transformed] extends [never] ? MissingSelfGeneric<\"Base.transformOrFailFrom\">\n    : Class<\n      Transformed,\n      Fields & NewFields,\n      I,\n      R | Struct.Context<NewFields> | R2 | R3,\n      C & Struct.Constructor<NewFields>,\n      Self,\n      Proto\n    >\n}\n\ntype HasFields<Fields extends Struct.Fields> = Struct<Fields> | {\n  readonly [RefineSchemaId]: HasFields<Fields>\n}\n\nconst isField = (u: unknown) => isSchema(u) || isPropertySignature(u)\n\nconst isFields = <Fields extends Struct.Fields>(fields: object): fields is Fields =>\n  util_.ownKeys(fields).every((key) => isField((fields as any)[key]))\n\nconst getFields = <Fields extends Struct.Fields>(hasFields: HasFields<Fields>): Fields =>\n  \"fields\" in hasFields ? hasFields.fields : getFields(hasFields[RefineSchemaId])\n\nconst getSchemaFromFieldsOr = <Fields extends Struct.Fields>(fieldsOr: Fields | HasFields<Fields>): Schema.Any =>\n  isFields(fieldsOr) ? Struct(fieldsOr) : isSchema(fieldsOr) ? fieldsOr : Struct(getFields(fieldsOr))\n\nconst getFieldsFromFieldsOr = <Fields extends Struct.Fields>(fieldsOr: Fields | HasFields<Fields>): Fields =>\n  isFields(fieldsOr) ? fieldsOr : getFields(fieldsOr)\n\n/**\n * @example\n * ```ts\n * import { Schema } from \"effect\"\n *\n * class MyClass extends Schema.Class<MyClass>(\"MyClass\")({\n *  someField: Schema.String\n * }) {\n *  someMethod() {\n *    return this.someField + \"bar\"\n *  }\n * }\n * ```\n *\n * @category classes\n * @since 3.10.0\n */\nexport const Class = <Self = never>(identifier: string) =>\n<Fields extends Struct.Fields>(\n  fieldsOr: Fields | HasFields<Fields>,\n  annotations?: ClassAnnotations<Self, Struct.Type<Fields>>\n): [Self] extends [never] ? MissingSelfGeneric<\"Class\">\n  : Class<\n    Self,\n    Fields,\n    Struct.Encoded<Fields>,\n    Struct.Context<Fields>,\n    Struct.Constructor<Fields>,\n    {},\n    {}\n  > =>\n  makeClass({\n    kind: \"Class\",\n    identifier,\n    schema: getSchemaFromFieldsOr(fieldsOr),\n    fields: getFieldsFromFieldsOr(fieldsOr),\n    Base: data_.Class,\n    annotations\n  })\n\n/** @internal */\nexport const getClassTag = <Tag extends string>(tag: Tag) =>\n  withConstructorDefault(propertySignature(Literal(tag)), () => tag)\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface TaggedClass<Self, Tag extends string, Fields extends Struct.Fields> extends\n  Class<\n    Self,\n    Fields,\n    Struct.Encoded<Fields>,\n    Struct.Context<Fields>,\n    Struct.Constructor<Omit<Fields, \"_tag\">>,\n    {},\n    {}\n  >\n{\n  readonly _tag: Tag\n}\n\n/**\n * @example\n * ```ts\n * import { Schema } from \"effect\"\n *\n * class MyClass extends Schema.TaggedClass<MyClass>(\"MyClass\")(\"MyClass\", {\n *  a: Schema.String\n * }) {}\n * ```\n *\n * @category classes\n * @since 3.10.0\n */\nexport const TaggedClass = <Self = never>(identifier?: string) =>\n<Tag extends string, Fields extends Struct.Fields>(\n  tag: Tag,\n  fieldsOr: Fields | HasFields<Fields>,\n  annotations?: ClassAnnotations<Self, Struct.Type<Fields>>\n): [Self] extends [never] ? MissingSelfGeneric<\"TaggedClass\", `\"Tag\", `>\n  : TaggedClass<Self, Tag, { readonly _tag: tag<Tag> } & Fields> =>\n{\n  const fields = getFieldsFromFieldsOr(fieldsOr)\n  const schema = getSchemaFromFieldsOr(fieldsOr)\n  const newFields = { _tag: getClassTag(tag) }\n  const taggedFields = extendFields(newFields, fields)\n  return class TaggedClass extends makeClass({\n    kind: \"TaggedClass\",\n    identifier: identifier ?? tag,\n    schema: extend(schema, Struct(newFields)),\n    fields: taggedFields,\n    Base: data_.Class,\n    annotations\n  }) {\n    static _tag = tag\n  } as any\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface TaggedErrorClass<Self, Tag extends string, Fields extends Struct.Fields> extends\n  Class<\n    Self,\n    Fields,\n    Struct.Encoded<Fields>,\n    Struct.Context<Fields>,\n    Struct.Constructor<Omit<Fields, \"_tag\">>,\n    {},\n    cause_.YieldableError\n  >\n{\n  readonly _tag: Tag\n}\n\n/**\n * @example\n * ```ts\n * import { Schema } from \"effect\"\n *\n * class MyError extends Schema.TaggedError<MyError>(\"MyError\")(\n *   \"MyError\",\n *   {\n *     module: Schema.String,\n *     method: Schema.String,\n *     description: Schema.String\n *   }\n * ) {\n *   get message(): string {\n *     return `${this.module}.${this.method}: ${this.description}`\n *   }\n * }\n * ```\n * @category classes\n * @since 3.10.0\n */\nexport const TaggedError = <Self = never>(identifier?: string) =>\n<Tag extends string, Fields extends Struct.Fields>(\n  tag: Tag,\n  fieldsOr: Fields | HasFields<Fields>,\n  annotations?: ClassAnnotations<Self, Struct.Type<Fields>>\n): [Self] extends [never] ? MissingSelfGeneric<\"TaggedError\", `\"Tag\", `>\n  : TaggedErrorClass<\n    Self,\n    Tag,\n    { readonly _tag: tag<Tag> } & Fields\n  > =>\n{\n  class Base extends data_.Error {}\n  ;(Base.prototype as any).name = tag\n  const fields = getFieldsFromFieldsOr(fieldsOr)\n  const schema = getSchemaFromFieldsOr(fieldsOr)\n  const newFields = { _tag: getClassTag(tag) }\n  const taggedFields = extendFields(newFields, fields)\n  return class TaggedErrorClass extends makeClass({\n    kind: \"TaggedError\",\n    identifier: identifier ?? tag,\n    schema: extend(schema, Struct(newFields)),\n    fields: taggedFields,\n    Base,\n    annotations,\n    disableToString: true\n  }) {\n    static _tag = tag\n    get message(): string {\n      return `{ ${\n        util_.ownKeys(fields).map((p: any) => `${util_.formatPropertyKey(p)}: ${util_.formatUnknown(this[p])}`)\n          .join(\", \")\n      } }`\n    }\n  } as any\n}\n\nconst extendFields = (a: Struct.Fields, b: Struct.Fields): Struct.Fields => {\n  const out = { ...a }\n  for (const key of util_.ownKeys(b)) {\n    if (key in a) {\n      throw new Error(errors_.getASTDuplicatePropertySignatureErrorMessage(key))\n    }\n    out[key] = b[key]\n  }\n  return out\n}\n\ntype MakeOptions = boolean | {\n  readonly disableValidation?: boolean\n}\n\nconst getDisableValidationMakeOption = (options: MakeOptions | undefined): boolean =>\n  Predicate.isBoolean(options) ? options : options?.disableValidation ?? false\n\nconst astCache = globalValue(\"effect/Schema/astCache\", () => new WeakMap<any, AST.AST>())\n\nconst getClassAnnotations = <Self, A>(\n  annotations: ClassAnnotations<Self, A> | undefined\n): [Annotations.Schema<Self>?, Annotations.Schema<Self>?, Annotations.Schema<A>?] => {\n  if (annotations === undefined) {\n    return []\n  } else if (Array.isArray(annotations)) {\n    return annotations as any\n  } else {\n    return [annotations] as any\n  }\n}\n\nconst makeClass = <Fields extends Struct.Fields>(\n  { Base, annotations, disableToString, fields, identifier, kind, schema }: {\n    kind: \"Class\" | \"TaggedClass\" | \"TaggedError\" | \"TaggedRequest\"\n    identifier: string\n    schema: Schema.Any\n    fields: Fields\n    Base: new(...args: ReadonlyArray<any>) => any\n    annotations?: ClassAnnotations<any, any> | undefined\n    disableToString?: boolean | undefined\n  }\n): any => {\n  const classSymbol = Symbol.for(`effect/Schema/${kind}/${identifier}`)\n\n  const [typeAnnotations, transformationAnnotations, encodedAnnotations] = getClassAnnotations(annotations)\n\n  const typeSchema_ = typeSchema(schema)\n\n  const declarationSurrogate = typeSchema_.annotations({\n    identifier,\n    ...typeAnnotations\n  })\n\n  const typeSide = typeSchema_.annotations({\n    [AST.AutoTitleAnnotationId]: `${identifier} (Type side)`,\n    ...typeAnnotations\n  })\n\n  const constructorSchema = schema.annotations({\n    [AST.AutoTitleAnnotationId]: `${identifier} (Constructor)`,\n    ...typeAnnotations\n  })\n\n  const encodedSide = schema.annotations({\n    [AST.AutoTitleAnnotationId]: `${identifier} (Encoded side)`,\n    ...encodedAnnotations\n  })\n\n  const transformationSurrogate = schema.annotations({\n    [AST.JSONIdentifierAnnotationId]: identifier,\n    ...encodedAnnotations,\n    ...typeAnnotations,\n    ...transformationAnnotations\n  })\n\n  const fallbackInstanceOf = (u: unknown) => Predicate.hasProperty(u, classSymbol) && ParseResult.is(typeSide)(u)\n\n  const klass = class extends Base {\n    constructor(\n      props: { [x: string | symbol]: unknown } = {},\n      options: MakeOptions = false\n    ) {\n      props = { ...props }\n      if (kind !== \"Class\") {\n        delete props[\"_tag\"]\n      }\n      props = lazilyMergeDefaults(fields, props)\n      if (!getDisableValidationMakeOption(options)) {\n        props = ParseResult.validateSync(constructorSchema)(props)\n      }\n      super(props, true)\n    }\n\n    // ----------------\n    // Schema interface\n    // ----------------\n\n    static [TypeId] = variance\n\n    static get ast(): AST.AST {\n      let out = astCache.get(this)\n      if (out) {\n        return out\n      }\n\n      const declaration: Schema.Any = declare(\n        [typeSide],\n        {\n          decode: () => (input, _, ast) =>\n            input instanceof this || fallbackInstanceOf(input)\n              ? ParseResult.succeed(input)\n              : ParseResult.fail(new ParseResult.Type(ast, input)),\n          encode: () => (input, options) =>\n            input instanceof this\n              ? ParseResult.succeed(input)\n              : ParseResult.map(\n                ParseResult.encodeUnknown(typeSide)(input, options),\n                (props) => new this(props, true)\n              )\n        },\n        {\n          identifier,\n          pretty: (pretty) => (self: any) => `${identifier}(${pretty(self)})`,\n          // @ts-expect-error\n          arbitrary: (arb) => (fc) => arb(fc).map((props) => new this(props)),\n          equivalence: identity,\n          [AST.SurrogateAnnotationId]: declarationSurrogate.ast,\n          ...typeAnnotations\n        }\n      )\n\n      out = transform(\n        encodedSide,\n        declaration,\n        { strict: true, decode: (input) => new this(input, true), encode: identity }\n      ).annotations({\n        [AST.SurrogateAnnotationId]: transformationSurrogate.ast,\n        ...transformationAnnotations\n      }).ast\n\n      astCache.set(this, out)\n\n      return out\n    }\n\n    static pipe() {\n      return pipeArguments(this, arguments)\n    }\n\n    static annotations(annotations: Annotations.Schema<any>) {\n      return make(this.ast).annotations(annotations)\n    }\n\n    static toString() {\n      return `(${String(encodedSide)} <-> ${identifier})`\n    }\n\n    // ----------------\n    // Class interface\n    // ----------------\n\n    static make(...args: Array<any>) {\n      return new this(...args)\n    }\n\n    static fields = { ...fields }\n\n    static identifier = identifier\n\n    static extend<Extended, NewFields extends Struct.Fields>(identifier: string) {\n      return (\n        newFieldsOr: NewFields | HasFields<NewFields>,\n        annotations?: ClassAnnotations<Extended, Struct.Type<Fields & NewFields>>\n      ) => {\n        const newFields = getFieldsFromFieldsOr(newFieldsOr)\n        const newSchema = getSchemaFromFieldsOr(newFieldsOr)\n        const extendedFields = extendFields(fields, newFields)\n        return makeClass({\n          kind,\n          identifier,\n          schema: extend(schema, newSchema),\n          fields: extendedFields,\n          Base: this,\n          annotations\n        })\n      }\n    }\n\n    static transformOrFail<Transformed, NewFields extends Struct.Fields>(identifier: string) {\n      return (\n        newFieldsOr: NewFields,\n        options: any,\n        annotations?: ClassAnnotations<Transformed, Struct.Type<Fields & NewFields>>\n      ) => {\n        const transformedFields: Struct.Fields = extendFields(fields, newFieldsOr)\n        return makeClass({\n          kind,\n          identifier,\n          schema: transformOrFail(\n            schema,\n            typeSchema(Struct(transformedFields)),\n            options\n          ),\n          fields: transformedFields,\n          Base: this,\n          annotations\n        })\n      }\n    }\n\n    static transformOrFailFrom<Transformed, NewFields extends Struct.Fields>(identifier: string) {\n      return (\n        newFields: NewFields,\n        options: any,\n        annotations?: ClassAnnotations<Transformed, Struct.Type<Fields & NewFields>>\n      ) => {\n        const transformedFields: Struct.Fields = extendFields(fields, newFields)\n        return makeClass({\n          kind,\n          identifier,\n          schema: transformOrFail(\n            encodedSchema(schema),\n            Struct(transformedFields),\n            options\n          ),\n          fields: transformedFields,\n          Base: this,\n          annotations\n        })\n      }\n    }\n\n    // ----------------\n    // other\n    // ----------------\n\n    get [classSymbol]() {\n      return classSymbol\n    }\n  }\n  if (disableToString !== true) {\n    Object.defineProperty(klass.prototype, \"toString\", {\n      value() {\n        return `${identifier}({ ${\n          util_.ownKeys(fields).map((p: any) => `${util_.formatPropertyKey(p)}: ${util_.formatUnknown(this[p])}`)\n            .join(\", \")\n        } })`\n      },\n      configurable: true\n    })\n  }\n  return klass\n}\n\n/**\n * @category FiberId\n * @since 3.10.0\n */\nexport type FiberIdEncoded =\n  | {\n    readonly _tag: \"Composite\"\n    readonly left: FiberIdEncoded\n    readonly right: FiberIdEncoded\n  }\n  | {\n    readonly _tag: \"None\"\n  }\n  | {\n    readonly _tag: \"Runtime\"\n    readonly id: number\n    readonly startTimeMillis: number\n  }\n\nconst FiberIdNoneEncoded = Struct({\n  _tag: Literal(\"None\")\n}).annotations({ identifier: \"FiberIdNoneEncoded\" })\n\nconst FiberIdRuntimeEncoded = Struct({\n  _tag: Literal(\"Runtime\"),\n  id: Int,\n  startTimeMillis: Int\n}).annotations({ identifier: \"FiberIdRuntimeEncoded\" })\n\nconst FiberIdCompositeEncoded = Struct({\n  _tag: Literal(\"Composite\"),\n  left: suspend(() => FiberIdEncoded),\n  right: suspend(() => FiberIdEncoded)\n}).annotations({ identifier: \"FiberIdCompositeEncoded\" })\n\nconst FiberIdEncoded: Schema<FiberIdEncoded> = Union(\n  FiberIdNoneEncoded,\n  FiberIdRuntimeEncoded,\n  FiberIdCompositeEncoded\n).annotations({ identifier: \"FiberIdEncoded\" })\n\nconst fiberIdArbitrary: LazyArbitrary<fiberId_.FiberId> = (fc) =>\n  fc.letrec((tie) => ({\n    None: fc.record({ _tag: fc.constant(\"None\" as const) }),\n    Runtime: fc.record({ _tag: fc.constant(\"Runtime\" as const), id: fc.integer(), startTimeMillis: fc.integer() }),\n    Composite: fc.record({ _tag: fc.constant(\"Composite\" as const), left: tie(\"FiberId\"), right: tie(\"FiberId\") }),\n    FiberId: fc.oneof(tie(\"None\"), tie(\"Runtime\"), tie(\"Composite\")) as any as fastCheck_.Arbitrary<fiberId_.FiberId>\n  })).FiberId.map(fiberIdDecode)\n\nconst fiberIdPretty: pretty_.Pretty<fiberId_.FiberId> = (fiberId) => {\n  switch (fiberId._tag) {\n    case \"None\":\n      return \"FiberId.none\"\n    case \"Runtime\":\n      return `FiberId.runtime(${fiberId.id}, ${fiberId.startTimeMillis})`\n    case \"Composite\":\n      return `FiberId.composite(${fiberIdPretty(fiberId.right)}, ${fiberIdPretty(fiberId.left)})`\n  }\n}\n\n/**\n * @category FiberId constructors\n * @since 3.10.0\n */\nexport class FiberIdFromSelf extends declare(\n  fiberId_.isFiberId,\n  {\n    identifier: \"FiberIdFromSelf\",\n    pretty: () => fiberIdPretty,\n    arbitrary: () => fiberIdArbitrary\n  }\n) {}\n\nconst fiberIdDecode = (input: FiberIdEncoded): fiberId_.FiberId => {\n  switch (input._tag) {\n    case \"None\":\n      return fiberId_.none\n    case \"Runtime\":\n      return fiberId_.runtime(input.id, input.startTimeMillis)\n    case \"Composite\":\n      return fiberId_.composite(fiberIdDecode(input.left), fiberIdDecode(input.right))\n  }\n}\n\nconst fiberIdEncode = (input: fiberId_.FiberId): FiberIdEncoded => {\n  switch (input._tag) {\n    case \"None\":\n      return { _tag: \"None\" }\n    case \"Runtime\":\n      return { _tag: \"Runtime\", id: input.id, startTimeMillis: input.startTimeMillis }\n    case \"Composite\":\n      return {\n        _tag: \"Composite\",\n        left: fiberIdEncode(input.left),\n        right: fiberIdEncode(input.right)\n      }\n  }\n}\n\n/**\n * @category FiberId transformations\n * @since 3.10.0\n */\nexport class FiberId extends transform(\n  FiberIdEncoded,\n  FiberIdFromSelf,\n  { strict: true, decode: fiberIdDecode, encode: fiberIdEncode }\n).annotations({ identifier: \"FiberId\" }) {}\n\n/**\n * @category Cause utils\n * @since 3.10.0\n */\nexport type CauseEncoded<E, D> =\n  | {\n    readonly _tag: \"Empty\"\n  }\n  | {\n    readonly _tag: \"Fail\"\n    readonly error: E\n  }\n  | {\n    readonly _tag: \"Die\"\n    readonly defect: D\n  }\n  | {\n    readonly _tag: \"Interrupt\"\n    readonly fiberId: FiberIdEncoded\n  }\n  | {\n    readonly _tag: \"Sequential\"\n    readonly left: CauseEncoded<E, D>\n    readonly right: CauseEncoded<E, D>\n  }\n  | {\n    readonly _tag: \"Parallel\"\n    readonly left: CauseEncoded<E, D>\n    readonly right: CauseEncoded<E, D>\n  }\n\nconst causeDieEncoded = <D, DI, R>(defect: Schema<D, DI, R>) =>\n  Struct({\n    _tag: Literal(\"Die\"),\n    defect\n  })\n\nconst CauseEmptyEncoded = Struct({\n  _tag: Literal(\"Empty\")\n})\n\nconst causeFailEncoded = <E, EI, R>(error: Schema<E, EI, R>) =>\n  Struct({\n    _tag: Literal(\"Fail\"),\n    error\n  })\n\nconst CauseInterruptEncoded = Struct({\n  _tag: Literal(\"Interrupt\"),\n  fiberId: FiberIdEncoded\n})\n\nconst causeParallelEncoded = <E, EI, D, DI, R>(causeEncoded: Schema<CauseEncoded<E, D>, CauseEncoded<EI, DI>, R>) =>\n  Struct({\n    _tag: Literal(\"Parallel\"),\n    left: causeEncoded,\n    right: causeEncoded\n  })\n\nconst causeSequentialEncoded = <E, EI, D, DI, R>(causeEncoded: Schema<CauseEncoded<E, D>, CauseEncoded<EI, DI>, R>) =>\n  Struct({\n    _tag: Literal(\"Sequential\"),\n    left: causeEncoded,\n    right: causeEncoded\n  })\n\nconst causeEncoded = <E, EI, D, DI, R1, R2>(\n  error: Schema<E, EI, R1>,\n  defect: Schema<D, DI, R2>\n): Schema<CauseEncoded<E, D>, CauseEncoded<EI, DI>, R1 | R2> => {\n  const recur = suspend(() => out)\n  const out: Schema<CauseEncoded<E, D>, CauseEncoded<EI, DI>, R1 | R2> = Union(\n    CauseEmptyEncoded,\n    causeFailEncoded(error),\n    causeDieEncoded(defect),\n    CauseInterruptEncoded,\n    causeSequentialEncoded(recur),\n    causeParallelEncoded(recur)\n  ).annotations({ title: `CauseEncoded<${format(error)}>` })\n  return out\n}\n\nconst causeArbitrary = <E>(\n  error: LazyArbitrary<E>,\n  defect: LazyArbitrary<unknown>\n): LazyArbitrary<cause_.Cause<E>> =>\n(fc) =>\n  fc.letrec((tie) => ({\n    Empty: fc.record({ _tag: fc.constant(\"Empty\" as const) }),\n    Fail: fc.record({ _tag: fc.constant(\"Fail\" as const), error: error(fc) }),\n    Die: fc.record({ _tag: fc.constant(\"Die\" as const), defect: defect(fc) }),\n    Interrupt: fc.record({ _tag: fc.constant(\"Interrupt\" as const), fiberId: fiberIdArbitrary(fc) }),\n    Sequential: fc.record({ _tag: fc.constant(\"Sequential\" as const), left: tie(\"Cause\"), right: tie(\"Cause\") }),\n    Parallel: fc.record({ _tag: fc.constant(\"Parallel\" as const), left: tie(\"Cause\"), right: tie(\"Cause\") }),\n    Cause: fc.oneof(\n      tie(\"Empty\"),\n      tie(\"Fail\"),\n      tie(\"Die\"),\n      tie(\"Interrupt\"),\n      tie(\"Sequential\"),\n      tie(\"Parallel\")\n    ) as any as fastCheck_.Arbitrary<cause_.Cause<E>>\n  })).Cause.map(causeDecode)\n\nconst causePretty = <E>(error: pretty_.Pretty<E>): pretty_.Pretty<cause_.Cause<E>> => (cause) => {\n  const f = (cause: cause_.Cause<E>): string => {\n    switch (cause._tag) {\n      case \"Empty\":\n        return \"Cause.empty\"\n      case \"Fail\":\n        return `Cause.fail(${error(cause.error)})`\n      case \"Die\":\n        return `Cause.die(${cause_.pretty(cause)})`\n      case \"Interrupt\":\n        return `Cause.interrupt(${fiberIdPretty(cause.fiberId)})`\n      case \"Sequential\":\n        return `Cause.sequential(${f(cause.left)}, ${f(cause.right)})`\n      case \"Parallel\":\n        return `Cause.parallel(${f(cause.left)}, ${f(cause.right)})`\n    }\n  }\n  return f(cause)\n}\n\nconst causeParse = <A, D, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<CauseEncoded<A, D>, R>\n): ParseResult.DeclarationDecodeUnknown<cause_.Cause<A>, R> =>\n(u, options, ast) =>\n  cause_.isCause(u) ?\n    toComposite(decodeUnknown(causeEncode(u), options), causeDecode, ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface CauseFromSelf<E extends Schema.All, D extends Schema.All> extends\n  AnnotableClass<\n    CauseFromSelf<E, D>,\n    cause_.Cause<Schema.Type<E>>,\n    cause_.Cause<Schema.Encoded<E>>,\n    Schema.Context<E> | Schema.Context<D>\n  >\n{}\n\n/**\n * @category Cause transformations\n * @since 3.10.0\n */\nexport const CauseFromSelf = <E extends Schema.All, D extends Schema.All>({ defect, error }: {\n  readonly error: E\n  readonly defect: D\n}): CauseFromSelf<E, D> => {\n  return declare(\n    [error, defect],\n    {\n      decode: (error, defect) => causeParse(ParseResult.decodeUnknown(causeEncoded(error, defect))),\n      encode: (error, defect) => causeParse(ParseResult.encodeUnknown(causeEncoded(error, defect)))\n    },\n    {\n      title: `Cause<${error.ast}>`,\n      pretty: causePretty,\n      arbitrary: causeArbitrary\n    }\n  )\n}\n\nfunction causeDecode<E>(cause: CauseEncoded<E, unknown>): cause_.Cause<E> {\n  switch (cause._tag) {\n    case \"Empty\":\n      return cause_.empty\n    case \"Fail\":\n      return cause_.fail(cause.error)\n    case \"Die\":\n      return cause_.die(cause.defect)\n    case \"Interrupt\":\n      return cause_.interrupt(fiberIdDecode(cause.fiberId))\n    case \"Sequential\":\n      return cause_.sequential(causeDecode(cause.left), causeDecode(cause.right))\n    case \"Parallel\":\n      return cause_.parallel(causeDecode(cause.left), causeDecode(cause.right))\n  }\n}\n\nfunction causeEncode<E>(cause: cause_.Cause<E>): CauseEncoded<E, unknown> {\n  switch (cause._tag) {\n    case \"Empty\":\n      return { _tag: \"Empty\" }\n    case \"Fail\":\n      return { _tag: \"Fail\", error: cause.error }\n    case \"Die\":\n      return { _tag: \"Die\", defect: cause.defect }\n    case \"Interrupt\":\n      return { _tag: \"Interrupt\", fiberId: cause.fiberId }\n    case \"Sequential\":\n      return {\n        _tag: \"Sequential\",\n        left: causeEncode(cause.left),\n        right: causeEncode(cause.right)\n      }\n    case \"Parallel\":\n      return {\n        _tag: \"Parallel\",\n        left: causeEncode(cause.left),\n        right: causeEncode(cause.right)\n      }\n  }\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Cause<E extends Schema.All, D extends Schema.All> extends\n  AnnotableClass<\n    Cause<E, D>,\n    cause_.Cause<Schema.Type<E>>,\n    CauseEncoded<Schema.Encoded<E>, Schema.Encoded<D>>,\n    Schema.Context<E> | Schema.Context<D>\n  >\n{}\n\n/**\n * @category Cause transformations\n * @since 3.10.0\n */\nexport const Cause = <E extends Schema.All, D extends Schema.All>({ defect, error }: {\n  readonly error: E\n  readonly defect: D\n}): Cause<E, D> => {\n  const error_ = asSchema(error)\n  const defect_ = asSchema(defect)\n  return transform(\n    causeEncoded(error_, defect_),\n    CauseFromSelf({ error: typeSchema(error_), defect: Unknown }),\n    { strict: false, decode: causeDecode, encode: causeEncode }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Defect extends transform<typeof Unknown, typeof Unknown> {}\n\n/**\n * Defines a schema for handling JavaScript errors (`Error` instances) and other types of defects.\n * It decodes objects into Error instances if they match the expected structure (i.e., have a `message` and optionally a `name` and `stack`),\n * or converts other values to their string representations.\n *\n * When encoding, it converts `Error` instances back into plain objects containing only the error's name and message,\n * or other values into their string forms.\n *\n * This is useful for serializing and deserializing errors across network boundaries where error objects do not natively serialize.\n *\n * @category defect\n * @since 3.10.0\n */\nexport const Defect: Defect = transform(\n  Unknown,\n  Unknown,\n  {\n    strict: true,\n    decode: (u) => {\n      if (Predicate.isObject(u) && \"message\" in u && typeof u.message === \"string\") {\n        const err = new Error(u.message, { cause: u })\n        if (\"name\" in u && typeof u.name === \"string\") {\n          err.name = u.name\n        }\n        err.stack = \"stack\" in u && typeof u.stack === \"string\" ? u.stack : \"\"\n        return err\n      }\n      return String(u)\n    },\n    encode: (defect) => {\n      if (defect instanceof Error) {\n        return {\n          name: defect.name,\n          message: defect.message\n          // no stack because of security reasons\n        }\n      }\n      return String(defect)\n    }\n  }\n).annotations({ identifier: \"Defect\" })\n\n/**\n * @category Exit utils\n * @since 3.10.0\n */\nexport type ExitEncoded<A, E, D> =\n  | {\n    readonly _tag: \"Failure\"\n    readonly cause: CauseEncoded<E, D>\n  }\n  | {\n    readonly _tag: \"Success\"\n    readonly value: A\n  }\n\nconst exitFailureEncoded = <E, EI, ER, D, DI, DR>(\n  error: Schema<E, EI, ER>,\n  defect: Schema<D, DI, DR>\n) =>\n  Struct({\n    _tag: Literal(\"Failure\"),\n    cause: causeEncoded(error, defect)\n  })\n\nconst exitSuccessEncoded = <A, I, R>(\n  value: Schema<A, I, R>\n) =>\n  Struct({\n    _tag: Literal(\"Success\"),\n    value\n  })\n\nconst exitEncoded = <A, I, R, E, EI, ER, D, DI, DR>(\n  value: Schema<A, I, R>,\n  error: Schema<E, EI, ER>,\n  defect: Schema<D, DI, DR>\n): Schema<ExitEncoded<A, E, D>, ExitEncoded<I, EI, DI>, R | ER | DR> =>\n  Union(\n    exitFailureEncoded(error, defect),\n    exitSuccessEncoded(value)\n  ).annotations({\n    title: `ExitEncoded<${format(value)}, ${format(error)}, ${format(defect)}>`\n  })\n\nconst exitDecode = <A, E>(input: ExitEncoded<A, E, unknown>): exit_.Exit<A, E> => {\n  switch (input._tag) {\n    case \"Failure\":\n      return exit_.failCause(causeDecode(input.cause))\n    case \"Success\":\n      return exit_.succeed(input.value)\n  }\n}\n\nconst exitArbitrary = <A, E>(\n  value: LazyArbitrary<A>,\n  error: LazyArbitrary<E>,\n  defect: LazyArbitrary<unknown>\n): LazyArbitrary<exit_.Exit<A, E>> =>\n(fc) =>\n  fc.oneof(\n    fc.record({ _tag: fc.constant(\"Failure\" as const), cause: causeArbitrary(error, defect)(fc) }),\n    fc.record({ _tag: fc.constant(\"Success\" as const), value: value(fc) })\n  ).map(exitDecode)\n\nconst exitPretty =\n  <A, E>(value: pretty_.Pretty<A>, error: pretty_.Pretty<E>): pretty_.Pretty<exit_.Exit<A, E>> => (exit) =>\n    exit._tag === \"Failure\"\n      ? `Exit.failCause(${causePretty(error)(exit.cause)})`\n      : `Exit.succeed(${value(exit.value)})`\n\nconst exitParse = <A, R, E, ER>(\n  decodeUnknownValue: ParseResult.DecodeUnknown<A, R>,\n  decodeUnknownCause: ParseResult.DecodeUnknown<cause_.Cause<E>, ER>\n): ParseResult.DeclarationDecodeUnknown<exit_.Exit<A, E>, ER | R> =>\n(u, options, ast) =>\n  exit_.isExit(u) ?\n    exit_.match(u, {\n      onFailure: (cause) => toComposite(decodeUnknownCause(cause, options), exit_.failCause, ast, u),\n      onSuccess: (value) => toComposite(decodeUnknownValue(value, options), exit_.succeed, ast, u)\n    })\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface ExitFromSelf<A extends Schema.All, E extends Schema.All, D extends Schema.All> extends\n  AnnotableClass<\n    ExitFromSelf<A, E, D>,\n    exit_.Exit<Schema.Type<A>, Schema.Type<E>>,\n    exit_.Exit<Schema.Encoded<A>, Schema.Encoded<E>>,\n    Schema.Context<A> | Schema.Context<E> | Schema.Context<D>\n  >\n{}\n\n/**\n * @category Exit transformations\n * @since 3.10.0\n */\nexport const ExitFromSelf = <A extends Schema.All, E extends Schema.All, D extends Schema.All>(\n  { defect, failure, success }: {\n    readonly failure: E\n    readonly success: A\n    readonly defect: D\n  }\n): ExitFromSelf<A, E, D> =>\n  declare(\n    [success, failure, defect],\n    {\n      decode: (success, failure, defect) =>\n        exitParse(\n          ParseResult.decodeUnknown(success),\n          ParseResult.decodeUnknown(CauseFromSelf({ error: failure, defect }))\n        ),\n      encode: (success, failure, defect) =>\n        exitParse(\n          ParseResult.encodeUnknown(success),\n          ParseResult.encodeUnknown(CauseFromSelf({ error: failure, defect }))\n        )\n    },\n    {\n      title: `Exit<${success.ast}, ${failure.ast}>`,\n      pretty: exitPretty,\n      arbitrary: exitArbitrary\n    }\n  )\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Exit<A extends Schema.All, E extends Schema.All, D extends Schema.All> extends\n  AnnotableClass<\n    Exit<A, E, D>,\n    exit_.Exit<Schema.Type<A>, Schema.Type<E>>,\n    ExitEncoded<Schema.Encoded<A>, Schema.Encoded<E>, Schema.Encoded<D>>,\n    Schema.Context<A> | Schema.Context<E> | Schema.Context<D>\n  >\n{}\n\n/**\n * @category Exit transformations\n * @since 3.10.0\n */\nexport const Exit = <A extends Schema.All, E extends Schema.All, D extends Schema.All>(\n  { defect, failure, success }: {\n    readonly failure: E\n    readonly success: A\n    readonly defect: D\n  }\n): Exit<A, E, D> => {\n  const success_ = asSchema(success)\n  const failure_ = asSchema(failure)\n  const defect_ = asSchema(defect)\n  return transform(\n    exitEncoded(success_, failure_, defect_),\n    ExitFromSelf({ failure: typeSchema(failure_), success: typeSchema(success_), defect: Unknown }),\n    {\n      strict: false,\n      decode: exitDecode,\n      encode: (exit) =>\n        exit._tag === \"Failure\"\n          ? { _tag: \"Failure\", cause: exit.cause } as const\n          : { _tag: \"Success\", value: exit.value } as const\n    }\n  )\n}\n\nconst hashSetArbitrary =\n  <A>(item: LazyArbitrary<A>, ctx: ArbitraryGenerationContext): LazyArbitrary<hashSet_.HashSet<A>> => (fc) => {\n    const items = fc.array(item(fc))\n    return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map(\n      hashSet_.fromIterable\n    )\n  }\n\nconst hashSetPretty = <A>(item: pretty_.Pretty<A>): pretty_.Pretty<hashSet_.HashSet<A>> => (set) =>\n  `HashSet(${Array.from(set).map((a) => item(a)).join(\", \")})`\n\nconst hashSetEquivalence = <A>(\n  item: Equivalence.Equivalence<A>\n): Equivalence.Equivalence<hashSet_.HashSet<A>> => {\n  const arrayEquivalence = array_.getEquivalence(item)\n  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)))\n}\n\nconst hashSetParse = <A, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<A>, R>\n): ParseResult.DeclarationDecodeUnknown<hashSet_.HashSet<A>, R> =>\n(u, options, ast) =>\n  hashSet_.isHashSet(u) ?\n    toComposite(decodeUnknown(Array.from(u), options), hashSet_.fromIterable, ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface HashSetFromSelf<Value extends Schema.Any> extends\n  AnnotableClass<\n    HashSetFromSelf<Value>,\n    hashSet_.HashSet<Schema.Type<Value>>,\n    hashSet_.HashSet<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category HashSet transformations\n * @since 3.10.0\n */\nexport const HashSetFromSelf = <Value extends Schema.Any>(\n  value: Value\n): HashSetFromSelf<Value> => {\n  return declare(\n    [value],\n    {\n      decode: (item) => hashSetParse(ParseResult.decodeUnknown(Array$(item))),\n      encode: (item) => hashSetParse(ParseResult.encodeUnknown(Array$(item)))\n    },\n    {\n      description: `HashSet<${format(value)}>`,\n      pretty: hashSetPretty,\n      arbitrary: hashSetArbitrary,\n      equivalence: hashSetEquivalence\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface HashSet<Value extends Schema.Any> extends\n  AnnotableClass<\n    HashSet<Value>,\n    hashSet_.HashSet<Schema.Type<Value>>,\n    ReadonlyArray<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category HashSet transformations\n * @since 3.10.0\n */\nexport const HashSet = <Value extends Schema.Any>(value: Value): HashSet<Value> => {\n  const value_ = asSchema(value)\n  return transform(\n    Array$(value_),\n    HashSetFromSelf(typeSchema(value_)),\n    { strict: true, decode: (as) => hashSet_.fromIterable(as), encode: (set) => Array.from(set) }\n  )\n}\n\nconst hashMapArbitrary = <K, V>(\n  key: LazyArbitrary<K>,\n  value: LazyArbitrary<V>,\n  ctx: ArbitraryGenerationContext\n): LazyArbitrary<hashMap_.HashMap<K, V>> =>\n(fc) => {\n  const items = fc.array(fc.tuple(key(fc), value(fc)))\n  return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map(hashMap_.fromIterable)\n}\n\nconst hashMapPretty = <K, V>(\n  key: pretty_.Pretty<K>,\n  value: pretty_.Pretty<V>\n): pretty_.Pretty<hashMap_.HashMap<K, V>> =>\n(map) =>\n  `HashMap([${\n    Array.from(map)\n      .map(([k, v]) => `[${key(k)}, ${value(v)}]`)\n      .join(\", \")\n  }])`\n\nconst hashMapEquivalence = <K, V>(\n  key: Equivalence.Equivalence<K>,\n  value: Equivalence.Equivalence<V>\n): Equivalence.Equivalence<hashMap_.HashMap<K, V>> => {\n  const arrayEquivalence = array_.getEquivalence(\n    Equivalence.make<[K, V]>(([ka, va], [kb, vb]) => key(ka, kb) && value(va, vb))\n  )\n  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)))\n}\n\nconst hashMapParse = <R, K, V>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<readonly [K, V]>, R>\n): ParseResult.DeclarationDecodeUnknown<hashMap_.HashMap<K, V>, R> =>\n(u, options, ast) =>\n  hashMap_.isHashMap(u) ?\n    toComposite(decodeUnknown(Array.from(u), options), hashMap_.fromIterable, ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface HashMapFromSelf<K extends Schema.Any, V extends Schema.Any> extends\n  AnnotableClass<\n    HashMapFromSelf<K, V>,\n    hashMap_.HashMap<Schema.Type<K>, Schema.Type<V>>,\n    hashMap_.HashMap<Schema.Encoded<K>, Schema.Encoded<V>>,\n    Schema.Context<K> | Schema.Context<V>\n  >\n{}\n\n/**\n * @category HashMap transformations\n * @since 3.10.0\n */\nexport const HashMapFromSelf = <K extends Schema.Any, V extends Schema.Any>({ key, value }: {\n  readonly key: K\n  readonly value: V\n}): HashMapFromSelf<K, V> => {\n  return declare(\n    [key, value],\n    {\n      decode: (key, value) => hashMapParse(ParseResult.decodeUnknown(Array$(Tuple(key, value)))),\n      encode: (key, value) => hashMapParse(ParseResult.encodeUnknown(Array$(Tuple(key, value))))\n    },\n    {\n      description: `HashMap<${format(key)}, ${format(value)}>`,\n      pretty: hashMapPretty,\n      arbitrary: hashMapArbitrary,\n      equivalence: hashMapEquivalence\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface HashMap<K extends Schema.Any, V extends Schema.Any> extends\n  AnnotableClass<\n    HashMap<K, V>,\n    hashMap_.HashMap<Schema.Type<K>, Schema.Type<V>>,\n    ReadonlyArray<readonly [Schema.Encoded<K>, Schema.Encoded<V>]>,\n    Schema.Context<K> | Schema.Context<V>\n  >\n{}\n\n/**\n * @category HashMap transformations\n * @since 3.10.0\n */\nexport const HashMap = <K extends Schema.Any, V extends Schema.Any>({ key, value }: {\n  readonly key: K\n  readonly value: V\n}): HashMap<K, V> => {\n  const key_ = asSchema(key)\n  const value_ = asSchema(value)\n  return transform(\n    Array$(Tuple(key_, value_)),\n    HashMapFromSelf({ key: typeSchema(key_), value: typeSchema(value_) }),\n    { strict: true, decode: (as) => hashMap_.fromIterable(as), encode: (map) => Array.from(map) }\n  )\n}\n\nconst listArbitrary =\n  <A>(item: LazyArbitrary<A>, ctx: ArbitraryGenerationContext): LazyArbitrary<list_.List<A>> => (fc) => {\n    const items = fc.array(item(fc))\n    return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map(list_.fromIterable)\n  }\n\nconst listPretty = <A>(item: pretty_.Pretty<A>): pretty_.Pretty<list_.List<A>> => (set) =>\n  `List(${Array.from(set).map((a) => item(a)).join(\", \")})`\n\nconst listEquivalence = <A>(\n  item: Equivalence.Equivalence<A>\n): Equivalence.Equivalence<list_.List<A>> => {\n  const arrayEquivalence = array_.getEquivalence(item)\n  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)))\n}\n\nconst listParse = <A, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<A>, R>\n): ParseResult.DeclarationDecodeUnknown<list_.List<A>, R> =>\n(u, options, ast) =>\n  list_.isList(u) ?\n    toComposite(decodeUnknown(Array.from(u), options), list_.fromIterable, ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface ListFromSelf<Value extends Schema.Any> extends\n  AnnotableClass<\n    ListFromSelf<Value>,\n    list_.List<Schema.Type<Value>>,\n    list_.List<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category List transformations\n * @since 3.10.0\n */\nexport const ListFromSelf = <Value extends Schema.Any>(\n  value: Value\n): ListFromSelf<Value> => {\n  return declare(\n    [value],\n    {\n      decode: (item) => listParse(ParseResult.decodeUnknown(Array$(item))),\n      encode: (item) => listParse(ParseResult.encodeUnknown(Array$(item)))\n    },\n    {\n      description: `List<${format(value)}>`,\n      pretty: listPretty,\n      arbitrary: listArbitrary,\n      equivalence: listEquivalence\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface List<Value extends Schema.Any> extends\n  AnnotableClass<\n    List<Value>,\n    list_.List<Schema.Type<Value>>,\n    ReadonlyArray<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category List transformations\n * @since 3.10.0\n */\nexport const List = <Value extends Schema.Any>(value: Value): List<Value> => {\n  const value_ = asSchema(value)\n  return transform(\n    Array$(value_),\n    ListFromSelf(typeSchema(value_)),\n    { strict: true, decode: (as) => list_.fromIterable(as), encode: (set) => Array.from(set) }\n  )\n}\n\nconst sortedSetArbitrary = <A>(\n  item: LazyArbitrary<A>,\n  ord: Order.Order<A>,\n  ctx: ArbitraryGenerationContext\n): LazyArbitrary<sortedSet_.SortedSet<A>> =>\n(fc) => {\n  const items = fc.array(item(fc))\n  return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map((as) =>\n    sortedSet_.fromIterable(as, ord)\n  )\n}\n\nconst sortedSetPretty = <A>(item: pretty_.Pretty<A>): pretty_.Pretty<sortedSet_.SortedSet<A>> => (set) =>\n  `new SortedSet([${Array.from(sortedSet_.values(set)).map((a) => item(a)).join(\", \")}])`\n\nconst sortedSetParse = <A, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<A>, R>,\n  ord: Order.Order<A>\n): ParseResult.DeclarationDecodeUnknown<sortedSet_.SortedSet<A>, R> =>\n(u, options, ast) =>\n  sortedSet_.isSortedSet(u) ?\n    toComposite(\n      decodeUnknown(Array.from(sortedSet_.values(u)), options),\n      (as): sortedSet_.SortedSet<A> => sortedSet_.fromIterable(as, ord),\n      ast,\n      u\n    )\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface SortedSetFromSelf<Value extends Schema.Any> extends\n  AnnotableClass<\n    SortedSetFromSelf<Value>,\n    sortedSet_.SortedSet<Schema.Type<Value>>,\n    sortedSet_.SortedSet<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category SortedSet transformations\n * @since 3.10.0\n */\nexport const SortedSetFromSelf = <Value extends Schema.Any>(\n  value: Value,\n  ordA: Order.Order<Schema.Type<Value>>,\n  ordI: Order.Order<Schema.Encoded<Value>>\n): SortedSetFromSelf<Value> => {\n  return declare(\n    [value],\n    {\n      decode: (item) => sortedSetParse(ParseResult.decodeUnknown(Array$(item)), ordA),\n      encode: (item) => sortedSetParse(ParseResult.encodeUnknown(Array$(item)), ordI)\n    },\n    {\n      description: `SortedSet<${format(value)}>`,\n      pretty: sortedSetPretty,\n      arbitrary: (arb, ctx) => sortedSetArbitrary(arb, ordA, ctx),\n      equivalence: () => sortedSet_.getEquivalence<Schema.Type<Value>>()\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface SortedSet<Value extends Schema.Any> extends\n  AnnotableClass<\n    SortedSet<Value>,\n    sortedSet_.SortedSet<Schema.Type<Value>>,\n    ReadonlyArray<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category SortedSet transformations\n * @since 3.10.0\n */\nexport const SortedSet = <Value extends Schema.Any>(\n  value: Value,\n  ordA: Order.Order<Schema.Type<Value>>\n): SortedSet<Value> => {\n  const value_ = asSchema(value)\n  const to = typeSchema(value_)\n  return transform(\n    Array$(value_),\n    SortedSetFromSelf<typeof to>(to, ordA, ordA),\n    {\n      strict: true,\n      decode: (as) => sortedSet_.fromIterable(as, ordA),\n      encode: (set) => Array.from(sortedSet_.values(set))\n    }\n  )\n}\n\n/**\n * Converts an arbitrary value to a `boolean` by testing whether it is truthy.\n * Uses `!!val` to coerce the value to a `boolean`.\n *\n * @see https://developer.mozilla.org/docs/Glossary/Truthy\n * @category boolean constructors\n * @since 3.10.0\n */\nexport class BooleanFromUnknown extends transform(\n  Unknown,\n  Boolean$,\n  { strict: true, decode: Predicate.isTruthy, encode: identity }\n).annotations({ identifier: \"BooleanFromUnknown\" }) {}\n\n/**\n * Converts an `string` value into its corresponding `boolean`\n * (\"true\" as `true` and \"false\" as `false`).\n *\n * @category boolean transformations\n * @since 3.11.0\n */\nexport class BooleanFromString extends transform(\n  Literal(\"true\", \"false\"),\n  Boolean$,\n  { strict: true, decode: (value) => value === \"true\", encode: (value) => value ? \"true\" : \"false\" }\n).annotations({ identifier: \"BooleanFromString\" }) {}\n\n/**\n * @category Config validations\n * @since 3.10.0\n */\nexport const Config = <A, I extends string>(name: string, schema: Schema<A, I>): config_.Config<A> => {\n  const decodeUnknownEither = ParseResult.decodeUnknownEither(schema)\n  return config_.string(name).pipe(\n    config_.mapOrFail((s) =>\n      decodeUnknownEither(s).pipe(\n        either_.mapLeft((error) => configError_.InvalidData([], ParseResult.TreeFormatter.formatIssueSync(error)))\n      )\n    )\n  )\n}\n\n// ---------------------------------------------\n// Serializable\n// ---------------------------------------------\n\n/**\n * @since 3.10.0\n * @category symbol\n */\nexport const symbolSerializable: unique symbol = Symbol.for(\n  \"effect/Schema/Serializable/symbol\"\n)\n\n/**\n * The `Serializable` trait allows objects to define their own schema for\n * serialization.\n *\n * @since 3.10.0\n * @category model\n */\nexport interface Serializable<A, I, R> {\n  readonly [symbolSerializable]: Schema<A, I, R>\n}\n\n/**\n * @since 3.10.0\n * @category model\n */\nexport declare namespace Serializable {\n  /**\n   * @since 3.10.0\n   */\n  export type Type<T> = T extends Serializable<infer A, infer _I, infer _R> ? A : never\n  /**\n   * @since 3.10.0\n   */\n  export type Encoded<T> = T extends Serializable<infer _A, infer I, infer _R> ? I : never\n  /**\n   * @since 3.10.0\n   */\n  export type Context<T> = T extends Serializable<infer _A, infer _I, infer R> ? R : never\n  /**\n   * @since 3.10.0\n   */\n  export type Any = Serializable<any, any, unknown>\n  /**\n   * @since 3.10.0\n   */\n  export type All =\n    | Any\n    | Serializable<any, never, unknown>\n    | Serializable<never, any, unknown>\n    | Serializable<never, never, unknown>\n}\n\n/**\n * @since 3.10.0\n */\nexport const asSerializable = <S extends Serializable.All>(\n  serializable: S\n): Serializable<Serializable.Type<S>, Serializable.Encoded<S>, Serializable.Context<S>> => serializable as any\n\n/**\n * @since 3.10.0\n * @category accessor\n */\nexport const serializableSchema = <A, I, R>(self: Serializable<A, I, R>): Schema<A, I, R> => self[symbolSerializable]\n\n/**\n * @since 3.10.0\n * @category encoding\n */\nexport const serialize = <A, I, R>(self: Serializable<A, I, R>): Effect.Effect<I, ParseResult.ParseError, R> =>\n  encodeUnknown(self[symbolSerializable])(self)\n\n/**\n * @since 3.10.0\n * @category decoding\n */\nexport const deserialize: {\n  /**\n   * @since 3.10.0\n   * @category decoding\n   */\n  (value: unknown): <A, I, R>(self: Serializable<A, I, R>) => Effect.Effect<A, ParseResult.ParseError, R>\n  /**\n   * @since 3.10.0\n   * @category decoding\n   */\n  <A, I, R>(self: Serializable<A, I, R>, value: unknown): Effect.Effect<A, ParseResult.ParseError, R>\n} = dual(\n  2,\n  <A, I, R>(self: Serializable<A, I, R>, value: unknown): Effect.Effect<A, ParseResult.ParseError, R> =>\n    decodeUnknown(self[symbolSerializable])(value)\n)\n\n/**\n * @since 3.10.0\n * @category symbol\n */\nexport const symbolWithResult: unique symbol = Symbol.for(\n  \"effect/Schema/Serializable/symbolResult\"\n)\n\n/**\n * The `WithResult` trait is designed to encapsulate the outcome of an\n * operation, distinguishing between success and failure cases. Each case is\n * associated with a schema that defines the structure and types of the success\n * or failure data.\n *\n * @since 3.10.0\n * @category model\n */\nexport interface WithResult<Success, SuccessEncoded, Failure, FailureEncoded, ResultR> {\n  readonly [symbolWithResult]: {\n    readonly success: Schema<Success, SuccessEncoded, ResultR>\n    readonly failure: Schema<Failure, FailureEncoded, ResultR>\n  }\n}\n\n/**\n * @since 3.10.0\n * @category model\n */\nexport declare namespace WithResult {\n  /**\n   * @since 3.10.0\n   */\n  export type Success<T> = T extends WithResult<infer _A, infer _I, infer _E, infer _EI, infer _R> ? _A : never\n  /**\n   * @since 3.10.0\n   */\n  export type SuccessEncoded<T> = T extends WithResult<infer _A, infer _I, infer _E, infer _EI, infer _R> ? _I : never\n  /**\n   * @since 3.10.0\n   */\n  export type Failure<T> = T extends WithResult<infer _A, infer _I, infer _E, infer _EI, infer _R> ? _E : never\n  /**\n   * @since 3.10.0\n   */\n  export type FailureEncoded<T> = T extends WithResult<infer _A, infer _I, infer _E, infer _EI, infer _R> ? _EI : never\n\n  /**\n   * @since 3.10.0\n   */\n  export type Context<T> = T extends WithResult<infer _SA, infer _SI, infer _FA, infer _FI, infer R> ? R : never\n  /**\n   * @since 3.10.0\n   */\n  export type Any = WithResult<any, any, any, any, unknown>\n  /**\n   * @since 3.10.0\n   */\n  export type All =\n    | Any\n    | WithResult<any, any, never, never, unknown>\n}\n\n/**\n * @since 3.10.0\n */\nexport const asWithResult = <WR extends WithResult.All>(\n  withExit: WR\n): WithResult<\n  WithResult.Success<WR>,\n  WithResult.SuccessEncoded<WR>,\n  WithResult.Failure<WR>,\n  WithResult.FailureEncoded<WR>,\n  WithResult.Context<WR>\n> => withExit as any\n\n/**\n * @since 3.10.0\n * @category accessor\n */\nexport const failureSchema = <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>): Schema<FA, FI, R> =>\n  self[symbolWithResult].failure\n\n/**\n * @since 3.10.0\n * @category accessor\n */\nexport const successSchema = <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>): Schema<SA, SI, R> =>\n  self[symbolWithResult].success\n\nconst exitSchemaCache = globalValue(\n  \"effect/Schema/Serializable/exitSchemaCache\",\n  () => new WeakMap<object, Schema<any, any, any>>()\n)\n\n/**\n * @since 3.10.0\n * @category accessor\n */\nexport const exitSchema = <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>): Schema<\n  exit_.Exit<SA, FA>,\n  ExitEncoded<SI, FI, unknown>,\n  R\n> => {\n  const proto = Object.getPrototypeOf(self)\n  if (!(symbolWithResult in proto)) {\n    return Exit({\n      failure: failureSchema(self),\n      success: successSchema(self),\n      defect: Defect\n    })\n  }\n  let schema = exitSchemaCache.get(proto)\n  if (schema === undefined) {\n    schema = Exit({\n      failure: failureSchema(self),\n      success: successSchema(self),\n      defect: Defect\n    })\n    exitSchemaCache.set(proto, schema)\n  }\n  return schema\n}\n\n/**\n * @since 3.10.0\n * @category encoding\n */\nexport const serializeFailure: {\n  /**\n   * @since 3.10.0\n   * @category encoding\n   */\n  <FA>(value: FA): <SA, SI, FI, R>(\n    self: WithResult<SA, SI, FA, FI, R>\n  ) => Effect.Effect<FI, ParseResult.ParseError, R>\n  /**\n   * @since 3.10.0\n   * @category encoding\n   */\n  <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>, value: FA): Effect.Effect<FI, ParseResult.ParseError, R>\n} = dual(\n  2,\n  <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>, value: FA): Effect.Effect<FI, ParseResult.ParseError, R> =>\n    encode(self[symbolWithResult].failure)(value)\n)\n\n/**\n * @since 3.10.0\n * @category decoding\n */\nexport const deserializeFailure: {\n  /**\n   * @since 3.10.0\n   * @category decoding\n   */\n  (\n    value: unknown\n  ): <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>) => Effect.Effect<FA, ParseResult.ParseError, R>\n  /**\n   * @since 3.10.0\n   * @category decoding\n   */\n  <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>, value: unknown): Effect.Effect<FA, ParseResult.ParseError, R>\n} = dual(\n  2,\n  <SA, SI, FA, FI, R>(\n    self: WithResult<SA, SI, FA, FI, R>,\n    value: unknown\n  ): Effect.Effect<FA, ParseResult.ParseError, R> => decodeUnknown(self[symbolWithResult].failure)(value)\n)\n\n/**\n * @since 3.10.0\n * @category encoding\n */\nexport const serializeSuccess: {\n  /**\n   * @since 3.10.0\n   * @category encoding\n   */\n  <SA>(value: SA): <SI, FA, FI, R>(\n    self: WithResult<SA, SI, FA, FI, R>\n  ) => Effect.Effect<SI, ParseResult.ParseError, R>\n  /**\n   * @since 3.10.0\n   * @category encoding\n   */\n  <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>, value: SA): Effect.Effect<SI, ParseResult.ParseError, R>\n} = dual(\n  2,\n  <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>, value: SA): Effect.Effect<SI, ParseResult.ParseError, R> =>\n    encode(self[symbolWithResult].success)(value)\n)\n\n/**\n * @since 3.10.0\n * @category decoding\n */\nexport const deserializeSuccess: {\n  /**\n   * @since 3.10.0\n   * @category decoding\n   */\n  (value: unknown): <SA, SI, FA, FI, R>(\n    self: WithResult<SA, SI, FA, FI, R>\n  ) => Effect.Effect<SA, ParseResult.ParseError, R>\n  /**\n   * @since 3.10.0\n   * @category decoding\n   */\n  <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>, value: unknown): Effect.Effect<SA, ParseResult.ParseError, R>\n} = dual(\n  2,\n  <SA, SI, FA, FI, R>(\n    self: WithResult<SA, SI, FA, FI, R>,\n    value: unknown\n  ): Effect.Effect<SA, ParseResult.ParseError, R> => decodeUnknown(self[symbolWithResult].success)(value)\n)\n\n/**\n * @since 3.10.0\n * @category encoding\n */\nexport const serializeExit: {\n  /**\n   * @since 3.10.0\n   * @category encoding\n   */\n  <SA, FA>(value: exit_.Exit<SA, FA>): <SI, FI, R>(\n    self: WithResult<SA, SI, FA, FI, R>\n  ) => Effect.Effect<ExitEncoded<SI, FI, unknown>, ParseResult.ParseError, R>\n  /**\n   * @since 3.10.0\n   * @category encoding\n   */\n  <SA, SI, FA, FI, R>(\n    self: WithResult<SA, SI, FA, FI, R>,\n    value: exit_.Exit<SA, FA>\n  ): Effect.Effect<ExitEncoded<SI, FI, unknown>, ParseResult.ParseError, R>\n} = dual(2, <SA, SI, FA, FI, R>(\n  self: WithResult<SA, SI, FA, FI, R>,\n  value: exit_.Exit<SA, FA>\n): Effect.Effect<ExitEncoded<SI, FI, unknown>, ParseResult.ParseError, R> => encode(exitSchema(self))(value))\n\n/**\n * @since 3.10.0\n * @category decoding\n */\nexport const deserializeExit: {\n  /**\n   * @since 3.10.0\n   * @category decoding\n   */\n  (value: unknown): <SA, SI, FA, FI, R>(\n    self: WithResult<SA, SI, FA, FI, R>\n  ) => Effect.Effect<exit_.Exit<SA, FA>, ParseResult.ParseError, R>\n  /**\n   * @since 3.10.0\n   * @category decoding\n   */\n  <SA, SI, FA, FI, R>(\n    self: WithResult<SA, SI, FA, FI, R>,\n    value: unknown\n  ): Effect.Effect<exit_.Exit<SA, FA>, ParseResult.ParseError, R>\n} = dual(2, <SA, SI, FA, FI, R>(\n  self: WithResult<SA, SI, FA, FI, R>,\n  value: unknown\n): Effect.Effect<exit_.Exit<SA, FA>, ParseResult.ParseError, R> => decodeUnknown(exitSchema(self))(value))\n\n// ---------------------------------------------\n// SerializableWithResult\n// ---------------------------------------------\n\n/**\n * The `SerializableWithResult` trait is specifically designed to model remote\n * procedures that require serialization of their input and output, managing\n * both successful and failed outcomes.\n *\n * This trait combines functionality from both the `Serializable` and `WithResult`\n * traits to handle data serialization and the bifurcation of operation results\n * into success or failure categories.\n *\n * @since 3.10.0\n * @category model\n */\nexport interface SerializableWithResult<\n  A,\n  I,\n  R,\n  Success,\n  SuccessEncoded,\n  Failure,\n  FailureEncoded,\n  ResultR\n> extends Serializable<A, I, R>, WithResult<Success, SuccessEncoded, Failure, FailureEncoded, ResultR> {}\n\n/**\n * @since 3.10.0\n * @category model\n */\nexport declare namespace SerializableWithResult {\n  /**\n   * @since 3.10.0\n   */\n  export type Context<P> = P extends\n    SerializableWithResult<infer _S, infer _SI, infer SR, infer _A, infer _AI, infer _E, infer _EI, infer RR> ? SR | RR\n    : never\n  /**\n   * @since 3.10.0\n   */\n  export type Any = SerializableWithResult<any, any, any, any, any, any, any, unknown>\n  /**\n   * @since 3.10.0\n   */\n  export type All =\n    | Any\n    | SerializableWithResult<any, any, any, any, any, never, never, unknown>\n}\n\n/**\n * @since 3.10.0\n */\nexport const asSerializableWithResult = <SWR extends SerializableWithResult.All>(\n  procedure: SWR\n): SerializableWithResult<\n  Serializable.Type<SWR>,\n  Serializable.Encoded<SWR>,\n  Serializable.Context<SWR>,\n  WithResult.Success<SWR>,\n  WithResult.SuccessEncoded<SWR>,\n  WithResult.Failure<SWR>,\n  WithResult.FailureEncoded<SWR>,\n  WithResult.Context<SWR>\n> => procedure as any\n\n/**\n * @since 3.10.0\n */\nexport interface TaggedRequest<\n  Tag extends string,\n  A,\n  I,\n  R,\n  SuccessType,\n  SuccessEncoded,\n  FailureType,\n  FailureEncoded,\n  ResultR\n> extends\n  Request.Request<SuccessType, FailureType>,\n  SerializableWithResult<\n    A,\n    I,\n    R,\n    SuccessType,\n    SuccessEncoded,\n    FailureType,\n    FailureEncoded,\n    ResultR\n  >\n{\n  readonly _tag: Tag\n}\n\n/**\n * @since 3.10.0\n */\nexport declare namespace TaggedRequest {\n  /**\n   * @since 3.10.0\n   */\n  export type Any = TaggedRequest<string, any, any, any, any, any, any, any, unknown>\n  /**\n   * @since 3.10.0\n   */\n  export type All =\n    | Any\n    | TaggedRequest<string, any, any, any, any, any, never, never, unknown>\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface TaggedRequestClass<\n  Self,\n  Tag extends string,\n  Payload extends Struct.Fields,\n  Success extends Schema.All,\n  Failure extends Schema.All\n> extends\n  Class<\n    Self,\n    Payload,\n    Struct.Encoded<Payload>,\n    Struct.Context<Payload>,\n    Struct.Constructor<Omit<Payload, \"_tag\">>,\n    TaggedRequest<\n      Tag,\n      Self,\n      Struct.Encoded<Payload>,\n      Struct.Context<Payload>,\n      Schema.Type<Success>,\n      Schema.Encoded<Success>,\n      Schema.Type<Failure>,\n      Schema.Encoded<Failure>,\n      Schema.Context<Success> | Schema.Context<Failure>\n    >,\n    {}\n  >\n{\n  readonly _tag: Tag\n  readonly success: Success\n  readonly failure: Failure\n}\n\n/**\n * @example\n * ```ts\n * import { Schema } from \"effect\"\n *\n * class MyRequest extends Schema.TaggedRequest<MyRequest>(\"MyRequest\")(\"MyRequest\", {\n *  failure: Schema.String,\n *  success: Schema.Number,\n *  payload: { id: Schema.String }\n * }) {}\n * ```\n *\n * @category classes\n * @since 3.10.0\n */\nexport const TaggedRequest =\n  <Self = never>(identifier?: string) =>\n  <Tag extends string, Payload extends Struct.Fields, Success extends Schema.All, Failure extends Schema.All>(\n    tag: Tag,\n    options: {\n      failure: Failure\n      success: Success\n      payload: Payload\n    },\n    annotations?: Annotations.Schema<Self>\n  ): [Self] extends [never] ? MissingSelfGeneric<\"TaggedRequest\", `\"Tag\", SuccessSchema, FailureSchema, `>\n    : TaggedRequestClass<\n      Self,\n      Tag,\n      { readonly _tag: tag<Tag> } & Payload,\n      Success,\n      Failure\n    > =>\n  {\n    const taggedFields = extendFields({ _tag: getClassTag(tag) }, options.payload)\n    return class TaggedRequestClass extends makeClass({\n      kind: \"TaggedRequest\",\n      identifier: identifier ?? tag,\n      schema: Struct(taggedFields),\n      fields: taggedFields,\n      Base: Request.Class<any, any, { readonly _tag: string }>,\n      annotations\n    }) {\n      static _tag = tag\n      static success = options.success\n      static failure = options.failure\n      get [symbolSerializable]() {\n        return this.constructor\n      }\n      get [symbolWithResult]() {\n        return {\n          failure: options.failure,\n          success: options.success\n        }\n      }\n    } as any\n  }\n\n// -------------------------------------------------------------------------------------------------\n// Equivalence compiler\n// -------------------------------------------------------------------------------------------------\n\n/**\n * Given a schema `Schema<A, I, R>`, returns an `Equivalence` instance for `A`.\n *\n * @category Equivalence\n * @since 3.10.0\n */\nexport const equivalence = <A, I, R>(schema: Schema<A, I, R>): Equivalence.Equivalence<A> => go(schema.ast, [])\n\nconst getEquivalenceAnnotation = AST.getAnnotation<AST.EquivalenceAnnotation<any, any>>(AST.EquivalenceAnnotationId)\n\nconst go = (ast: AST.AST, path: ReadonlyArray<PropertyKey>): Equivalence.Equivalence<any> => {\n  const hook = getEquivalenceAnnotation(ast)\n  if (option_.isSome(hook)) {\n    switch (ast._tag) {\n      case \"Declaration\":\n        return hook.value(...ast.typeParameters.map((tp) => go(tp, path)))\n      case \"Refinement\":\n        return hook.value(go(ast.from, path))\n      default:\n        return hook.value()\n    }\n  }\n  switch (ast._tag) {\n    case \"NeverKeyword\":\n      throw new Error(errors_.getEquivalenceUnsupportedErrorMessage(ast, path))\n    case \"Transformation\":\n      return go(ast.to, path)\n    case \"Declaration\":\n    case \"Literal\":\n    case \"StringKeyword\":\n    case \"TemplateLiteral\":\n    case \"UniqueSymbol\":\n    case \"SymbolKeyword\":\n    case \"UnknownKeyword\":\n    case \"AnyKeyword\":\n    case \"NumberKeyword\":\n    case \"BooleanKeyword\":\n    case \"BigIntKeyword\":\n    case \"UndefinedKeyword\":\n    case \"VoidKeyword\":\n    case \"Enums\":\n    case \"ObjectKeyword\":\n      return Equal.equals\n    case \"Refinement\":\n      return go(ast.from, path)\n    case \"Suspend\": {\n      const get = util_.memoizeThunk(() => go(ast.f(), path))\n      return (a, b) => get()(a, b)\n    }\n    case \"TupleType\": {\n      const elements = ast.elements.map((element, i) => go(element.type, path.concat(i)))\n      const rest = ast.rest.map((annotatedAST) => go(annotatedAST.type, path))\n      return Equivalence.make((a, b) => {\n        const len = a.length\n        if (len !== b.length) {\n          return false\n        }\n        // ---------------------------------------------\n        // handle elements\n        // ---------------------------------------------\n        let i = 0\n        for (; i < Math.min(len, ast.elements.length); i++) {\n          if (!elements[i](a[i], b[i])) {\n            return false\n          }\n        }\n        // ---------------------------------------------\n        // handle rest element\n        // ---------------------------------------------\n        if (array_.isNonEmptyReadonlyArray(rest)) {\n          const [head, ...tail] = rest\n          for (; i < len - tail.length; i++) {\n            if (!head(a[i], b[i])) {\n              return false\n            }\n          }\n          // ---------------------------------------------\n          // handle post rest elements\n          // ---------------------------------------------\n          for (let j = 0; j < tail.length; j++) {\n            i += j\n            if (!tail[j](a[i], b[i])) {\n              return false\n            }\n          }\n        }\n        return true\n      })\n    }\n    case \"TypeLiteral\": {\n      if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {\n        return Equal.equals\n      }\n      const propertySignatures = ast.propertySignatures.map((ps) => go(ps.type, path.concat(ps.name)))\n      const indexSignatures = ast.indexSignatures.map((is) => go(is.type, path))\n      return Equivalence.make((a, b) => {\n        const aStringKeys = Object.keys(a)\n        const aSymbolKeys = Object.getOwnPropertySymbols(a)\n        // ---------------------------------------------\n        // handle property signatures\n        // ---------------------------------------------\n        for (let i = 0; i < propertySignatures.length; i++) {\n          const ps = ast.propertySignatures[i]\n          const name = ps.name\n          const aHas = Object.prototype.hasOwnProperty.call(a, name)\n          const bHas = Object.prototype.hasOwnProperty.call(b, name)\n          if (ps.isOptional) {\n            if (aHas !== bHas) {\n              return false\n            }\n          }\n          if (aHas && bHas && !propertySignatures[i](a[name], b[name])) {\n            return false\n          }\n        }\n        // ---------------------------------------------\n        // handle index signatures\n        // ---------------------------------------------\n        let bSymbolKeys: Array<symbol> | undefined\n        let bStringKeys: Array<string> | undefined\n        for (let i = 0; i < indexSignatures.length; i++) {\n          const is = ast.indexSignatures[i]\n          const base = AST.getParameterBase(is.parameter)\n          const isSymbol = AST.isSymbolKeyword(base)\n          if (isSymbol) {\n            bSymbolKeys = bSymbolKeys || Object.getOwnPropertySymbols(b)\n            if (aSymbolKeys.length !== bSymbolKeys.length) {\n              return false\n            }\n          } else {\n            bStringKeys = bStringKeys || Object.keys(b)\n            if (aStringKeys.length !== bStringKeys.length) {\n              return false\n            }\n          }\n          const aKeys = isSymbol ? aSymbolKeys : aStringKeys\n          for (let j = 0; j < aKeys.length; j++) {\n            const key = aKeys[j]\n            if (\n              !Object.prototype.hasOwnProperty.call(b, key) || !indexSignatures[i](a[key], b[key])\n            ) {\n              return false\n            }\n          }\n        }\n        return true\n      })\n    }\n    case \"Union\": {\n      const searchTree = ParseResult.getSearchTree(ast.types, true)\n      const ownKeys = util_.ownKeys(searchTree.keys)\n      const len = ownKeys.length\n      return Equivalence.make((a, b) => {\n        let candidates: Array<AST.AST> = []\n        if (len > 0 && Predicate.isRecordOrArray(a)) {\n          for (let i = 0; i < len; i++) {\n            const name = ownKeys[i]\n            const buckets = searchTree.keys[name].buckets\n            if (Object.prototype.hasOwnProperty.call(a, name)) {\n              const literal = String(a[name])\n              if (Object.prototype.hasOwnProperty.call(buckets, literal)) {\n                candidates = candidates.concat(buckets[literal])\n              }\n            }\n          }\n        }\n        if (searchTree.otherwise.length > 0) {\n          candidates = candidates.concat(searchTree.otherwise)\n        }\n        const tuples = candidates.map((ast) => [go(ast, path), ParseResult.is({ ast } as any)] as const)\n        for (let i = 0; i < tuples.length; i++) {\n          const [equivalence, is] = tuples[i]\n          if (is(a) && is(b)) {\n            if (equivalence(a, b)) {\n              return true\n            }\n          }\n        }\n        return false\n      })\n    }\n  }\n}\n"],"names":["array_","bigDecimal_","bigInt_","boolean_","cause_","chunk_","config_","configError_","data_","dateTime","duration_","Effect","either_","Encoding","Equal","Equivalence","exit_","fastCheck_","fiberId_","dual","identity","globalValue","hashMap_","hashSet_","errors_","schemaId_","util_","list_","number_","option_","ParseResult","pipeArguments","Predicate","record_","redacted_","Request","AST","sortedSet_","string_","struct_","TypeId","Symbol","for","make","ast","SchemaClass","variance","Type","Encoded","Context","annotations","mergeSchemaAnnotations","pipe","arguments","toString","String","_A","_","_I","_R","builtInAnnotations","schemaId","SchemaIdAnnotationId","message","MessageAnnotationId","missingMessage","MissingMessageAnnotationId","identifier","IdentifierAnnotationId","title","TitleAnnotationId","description","DescriptionAnnotationId","examples","ExamplesAnnotationId","default","DefaultAnnotationId","documentation","DocumentationAnnotationId","jsonSchema","JSONSchemaAnnotationId","arbitrary","ArbitraryAnnotationId","pretty","PrettyAnnotationId","equivalence","EquivalenceAnnotationId","concurrency","ConcurrencyAnnotationId","batching","BatchingAnnotationId","parseIssueTitle","ParseIssueTitleAnnotationId","parseOptions","ParseOptionsAnnotationId","decodingFallback","DecodingFallbackAnnotationId","toASTAnnotations","out","key","id","asSchema","schema","format","encodedSchema","encodedAST","encodedBoundSchema","encodedBoundAST","typeSchema","typeAST","asserts","decodeOption","decodeSync","decodeUnknownOption","decodeUnknownSync","encodeOption","encodeSync","encodeUnknownOption","encodeUnknownSync","is","validateOption","validateSync","encodeUnknown","options","u","overrideOptions","mapError","parseError","encodeUnknownEither","mapLeft","encodeUnknownPromise","parser","runPromise","encode","encodeEither","encodePromise","decodeUnknown","decodeUnknownEither","decodeUnknownPromise","decode","decodeEither","decodePromise","validate","validateEither","validatePromise","isSchema","hasProperty","isObject","getDefaultLiteralAST","literals","isMembers","Union","mapMembers","literal","Literal","makeLiteralClass","LiteralClass","isNonEmptyReadonlyArray","Never","pickLiteral","_schema","UniqueSymbolFromSelf","symbol","UniqueSymbol","getDefaultEnumsAST","enums","Enums","Object","keys","filter","map","makeEnumsClass","EnumsClass","TemplateLiteral","head","tail","spans","h","ts","isLiteral","i","length","item","next","push","TemplateLiteralSpan","isNonEmptyArray","getTemplateLiteralParserCoercedElement","encoded","_tag","isString","s","transform","strict","compose","NumberFromString","members","hasCoercions","member","types","coerced","TemplateLiteralParser","params","encodedSchemas","elements","schemas","param","element","from","re","getTemplateLiteralCapturingRegExp","to","Tuple","AutoTitleAnnotationId","TemplateLiteralParserClass","transformOrFail","match","exec","succeed","slice","fail","source","JSON","stringify","tuple","join","declareConstructor","typeParameters","Declaration","tp","declarePrimitive","input","declare","Array","isArray","BrandSchemaId","fromBrand","constructor","self","makeBrandClass","Refinement","predicate","a","either","isLeft","some","left","v","none","InstanceOfSchemaId","instanceOf","name","Undefined","undefinedKeyword","Void","voidKeyword","Null","null","neverKeyword","Unknown","unknownKeyword","Any","anyKeyword","BigIntFromSelf","bigIntKeyword","SymbolFromSelf","symbolKeyword","String$","stringKeyword","Number$","numberKeyword","Boolean$","booleanKeyword","Object$","objectKeyword","Boolean","Number","getDefaultUnionAST","m","makeUnionClass","UnionClass","NullOr","UndefinedOr","NullishOr","keyof","ElementImpl","OptionalType","optionalElement","_Token","type","isOptional","getDefaultTupleTypeAST","rest","TupleType","el","makeTupleTypeClass","TupleTypeClass","args","makeArrayClass","value","ArrayClass","Array$","makeNonEmptyArrayClass","NonEmptyArrayClass","NonEmptyArray","ArrayEnsure","value_","ArrayEnsureClass","ensure","arr","NonEmptyArrayEnsure","NonEmptyArrayEnsureClass","formatPropertySignatureToken","PropertySignatureDeclaration","isReadonly","defaultValue","token","FromPropertySignature","fromKey","ToPropertySignature","formatPropertyKey","p","undefined","PropertySignatureTransformation","mergeSignatureAnnotations","PropertySignatureTypeId","isPropertySignature","PropertySignatureImpl","_TypeToken","_Key","_EncodedToken","_HasDefault","makePropertySignature","PropertySignatureWithFromImpl","propertySignature","withConstructorDefault","applyDefaultValue","o","onNone","onSome","pruneUndefined","pruned","Transformation","transformation","withDecodingDefault","withDefaults","defaults","decoding","optionalToRequired","flatMap","requiredToOptional","optionalToOptional","optionalPropertySignatureAST","isExact","exact","isNullable","nullable","asOption","as","asOptionEncode","onNoneEncoding","orElse","OptionFromSelf","isNotNull","isNotUndefined","optional","optionalWith","preserveMissingMessageAnnotation","whiteListAnnotations","getDefaultTypeLiteralAST","fields","records","ownKeys","pss","transformations","field","toAnnotations","PropertySignature","issFrom","issTo","r","indexSignatures","propertySignatures","record","forEach","ps","IndexSignature","parameter","TypeLiteral","TypeLiteralTransformation","iss","lazilyMergeDefaults","makeTypeLiteralClass","TypeLiteralClass","props","propsWithDefaults","getDisableValidationMakeOption","pick","Struct","omit","tag","TaggedStruct","makeRecordClass","RecordClass","Record","pluck","getPropertyKeyIndexedAccess","orUndefined","ak","BrandClass","brand","annotation","getBrandAnnotation","brands","BrandAnnotationId","partial","partialWith","required","mutable","intersectTypeLiterals","x","y","path","isTypeLiteral","findIndex","extendAST","concat","Error","getSchemaExtendErrorMessage","preserveRefinementAnnotations","blackListAnnotations","addRefinementToMembers","refinement","asts","intersectUnionMembers","getTypes","isUnion","xs","ys","isStringKeyword","isNumber","isNumberKeyword","isBoolean","isBooleanKeyword","isRefinement","Suspend","f","isTypeLiteralTransformation","propertySignatureTransformations","extend","that","suspend","RefineSchemaId","makeRefineClass","RefineClass","fromFilterPredicateReturnTypeItem","issue","Pointer","toFilterParseIssue","isSingle","issues","filterMap","Composite","filterEffect","filterReturnType","makeTransformationClass","TransformationClass","FinalTransformation","fromA","_options","_ast","toA","toI","transformLiteral","transformLiterals","pairs","attachPropertySignature","isSymbol","rename","mapping","TrimmedSchemaId","trimmed","trim","pattern","MaxLengthSchemaId","maxLength","MinLengthSchemaId","minLength","PatternSchemaId","regex","lastIndex","test","StartsWithSchemaId","startsWith","formatted","EndsWithSchemaId","endsWith","IncludesSchemaId","includes","searchString","LowercasedSchemaId","lowercased","toLowerCase","Lowercased","CapitalizedSchemaId","capitalized","toUpperCase","Capitalized","UncapitalizedSchemaId","uncapitalized","Uncapitalized","UppercasedSchemaId","uppercased","Uppercased","LengthSchemaId","Math","max","floor","min","Char","nonEmptyString","Lowercase","Uppercase","Capitalize","capitalize","Uncapitalize","uncapitalize","Trimmed","NonEmptyTrimmedString","Trim","split","separator","JsonString","getParseJsonTransformation","try","parse","reviver","catch","e","replacer","space","ParseJsonSchemaId","parseJson","schemaOrOptions","NonEmptyString","UUIDSchemaId","uuidRegexp","UUID","fc","uuid","ULIDSchemaId","ulidRegexp","ULID","ulid","URLFromSelf","URL","webUrl","url","URL$","str","FiniteSchemaId","finite","isFinite","GreaterThanSchemaId","greaterThan","exclusiveMinimum","GreaterThanOrEqualToSchemaId","greaterThanOrEqualTo","minimum","MultipleOfSchemaId","multipleOf","divisor","positiveDivisor","abs","remainder","IntSchemaId","int","isSafeInteger","LessThanSchemaId","lessThan","exclusiveMaximum","LessThanOrEqualToSchemaId","lessThanOrEqualTo","maximum","BetweenSchemaId","between","NonNaNSchemaId","nonNaN","isNaN","positive","negative","nonPositive","nonNegative","clamp","parseNumber","fromOption","n","Finite","Int","NonNaN","Positive","Negative","NonPositive","NonNegative","JsonNumberSchemaId","JsonNumber","Not","not","Symbol$","sym","GreaterThanBigIntSchemaId","GreaterThanBigintSchemaId","greaterThanBigInt","GreaterThanOrEqualToBigIntSchemaId","greaterThanOrEqualToBigInt","LessThanBigIntSchemaId","lessThanBigInt","LessThanOrEqualToBigIntSchemaId","lessThanOrEqualToBigInt","BetweenBigIntSchemaId","BetweenBigintSchemaId","betweenBigInt","positiveBigInt","negativeBigInt","nonNegativeBigInt","nonPositiveBigInt","clampBigInt","BigInt$","fromString","BigInt","PositiveBigIntFromSelf","PositiveBigInt","NegativeBigIntFromSelf","NegativeBigInt","NonPositiveBigIntFromSelf","NonPositiveBigInt","NonNegativeBigIntFromSelf","NonNegativeBigInt","BigIntFromNumber","fromNumber","b","toNumber","redactedArbitrary","toComposite","eff","onSuccess","actual","mapBoth","onFailure","redactedParse","isRedacted","RedactedFromSelf","getEquivalence","Redacted","DurationFromSelf","isDuration","oneof","constant","infinity","bigUint","nanos","micros","maxSafeNat","millis","seconds","minutes","hours","days","weeks","DurationFromNanos","duration","toNanos","val","DurationFromMillis","ms","toMillis","NonNegativeInt","HRTime","Duration","toHrTime","clampDuration","betweenDuration","LessThanDurationSchemaId","lessThanDuration","LessThanOrEqualToDurationSchemaId","lessThanOrEqualToDuration","GreaterThanDurationSchemaId","greaterThanDuration","GreaterThanOrEqualToDurationSchemaId","greaterThanOrEqualToDuration","BetweenDurationSchemaId","Uint8ArrayFromSelf","isUint8Array","u8arr","uint8Array","equals","Uint8","Uint8Array$","numbers","Uint8Array","makeUint8ArrayTransformation","decodeException","Uint8ArrayFromBase64","decodeBase64","encodeBase64","Uint8ArrayFromBase64Url","decodeBase64Url","encodeBase64Url","Uint8ArrayFromHex","decodeHex","encodeHex","makeEncodingTransformation","StringFromBase64","decodeBase64String","StringFromBase64Url","decodeBase64UrlString","StringFromHex","decodeHexString","StringFromUriComponent","decodeUriComponent","encodeUriComponent","encodeException","MinItemsSchemaId","minItems","getInvalidArgumentErrorMessage","StableFilterAnnotationId","MaxItemsSchemaId","maxItems","ItemsCountSchemaId","itemsCount","getNumberIndexedAccess","of","headNonEmpty","headOrElse","fallback","ValidDateSchemaId","validDate","getTime","noInvalidDate","LessThanDateSchemaId","lessThanDate","formatDate","LessThanOrEqualToDateSchemaId","lessThanOrEqualToDate","GreaterThanDateSchemaId","greaterThanDate","GreaterThanOrEqualToDateSchemaId","greaterThanOrEqualToDate","BetweenDateSchemaId","betweenDate","DateFromSelfSchemaId","DateFromSelf","isDate","date","Date","ValidDateFromSelf","DateFromString","d","Date$","DateFromNumber","DateTimeUtcFromSelf","isDateTime","isUtc","unsafeFromDate","decodeDateTime","unsafeMake","DateTimeUtcFromNumber","dt","toEpochMillis","DateTimeUtcFromDate","toDateUtc","DateTimeUtc","formatIso","timeZoneOffsetArbitrary","integer","zoneMakeOffset","TimeZoneOffsetFromSelf","isTimeZoneOffset","zone","TimeZoneOffset","tz","offset","timeZoneNamedArbitrary","constantFrom","Intl","supportedValuesOf","zoneUnsafeMakeNamed","TimeZoneNamedFromSelf","isTimeZoneNamed","TimeZoneNamed","TimeZoneFromSelf","TimeZone","zoneFromString","zoneToString","timeZoneArbitrary","DateTimeZonedFromSelf","isZoned","chain","timeZone","unsafeMakeZoned","DateTimeZoned","makeZonedFromString","formatIsoZoned","OptionNoneEncoded","optionSomeEncoded","optionEncoded","optionDecode","optionArbitrary","ctx","optionPretty","optionParse","isOption","isNone","makeNoneEncoded","makeSomeEncoded","Option","OptionFromNullOr","fromNullable","getOrNull","OptionFromNullishOr","getOrUndefined","OptionFromUndefinedOr","OptionFromNonEmptyTrimmedString","getOrElse","rightEncoded","right","leftEncoded","eitherEncoded","eitherDecode","eitherArbitrary","eitherPretty","onLeft","onRight","eitherParse","parseRight","decodeUnknownLeft","isEither","EitherFromSelf","makeLeftEncoded","makeRightEncoded","Either","right_","left_","EitherFromUnion","toright","toleft","fromRight","fromLeft","l","mapArbitrary","items","array","depthIdentifier","Map","readonlyMapPretty","entries","k","readonlyMapEquivalence","arrayEquivalence","ka","va","kb","vb","readonlyMapParse","isMap","mapFromSelf_","Key","Value","ReadonlyMapFromSelf","MapFromSelf","ReadonlyMap","key_","ReadonlyMapFromRecord","fromEntries","MapFromRecord","setArbitrary","Set","readonlySetPretty","set","values","readonlySetEquivalence","readonlySetParse","isSet","setFromSelf_","ReadonlySetFromSelf","SetFromSelf","ReadonlySet","bigDecimalPretty","normalize","bigDecimalArbitrary","bigInt","scale","BigDecimalFromSelf","isBigDecimal","BigDecimal","num","BigDecimalFromNumber","unsafeFromNumber","unsafeToNumber","GreaterThanBigDecimalSchemaId","greaterThanBigDecimal","GreaterThanOrEqualToBigDecimalSchemaId","greaterThanOrEqualToBigDecimal","LessThanBigDecimalSchemaId","lessThanBigDecimal","LessThanOrEqualToBigDecimalSchemaId","lessThanOrEqualToBigDecimal","PositiveBigDecimalSchemaId","positiveBigDecimal","isPositive","PositiveBigDecimalFromSelf","NonNegativeBigDecimalSchemaId","nonNegativeBigDecimal","NonNegativeBigDecimalFromSelf","NegativeBigDecimalSchemaId","negativeBigDecimal","isNegative","NegativeBigDecimalFromSelf","NonPositiveBigDecimalSchemaId","nonPositiveBigDecimal","NonPositiveBigDecimalFromSelf","BetweenBigDecimalSchemaId","betweenBigDecimal","formattedMinimum","formattedMaximum","clampBigDecimal","chunkArbitrary","fromIterable","chunkPretty","c","toReadonlyArray","chunkParse","isChunk","isEmpty","empty","ChunkFromSelf","Chunk","nonEmptyChunkArbitrary","unsafeFromNonEmptyArray","nonEmptyChunkPretty","nonEmptyChunkParse","isNonEmpty","NonEmptyChunkFromSelf","NonEmptyChunk","toData","struct","dataArbitrary","dataPretty","dataParse","isEqual","DataFromSelf","Data","assign","isField","isFields","every","getFields","hasFields","getSchemaFromFieldsOr","fieldsOr","getFieldsFromFieldsOr","Class","makeClass","kind","Base","getClassTag","TaggedClass","newFields","taggedFields","extendFields","TaggedError","prototype","TaggedErrorClass","disableToString","formatUnknown","getASTDuplicatePropertySignatureErrorMessage","disableValidation","astCache","WeakMap","getClassAnnotations","classSymbol","typeAnnotations","transformationAnnotations","encodedAnnotations","typeSchema_","declarationSurrogate","typeSide","constructorSchema","encodedSide","transformationSurrogate","JSONIdentifierAnnotationId","fallbackInstanceOf","klass","get","declaration","arb","SurrogateAnnotationId","newFieldsOr","newSchema","extendedFields","transformedFields","transformOrFailFrom","defineProperty","configurable","FiberIdNoneEncoded","FiberIdRuntimeEncoded","startTimeMillis","FiberIdCompositeEncoded","FiberIdEncoded","fiberIdArbitrary","letrec","tie","None","Runtime","FiberId","fiberIdDecode","fiberIdPretty","fiberId","FiberIdFromSelf","isFiberId","runtime","composite","fiberIdEncode","causeDieEncoded","defect","CauseEmptyEncoded","causeFailEncoded","error","CauseInterruptEncoded","causeParallelEncoded","causeEncoded","causeSequentialEncoded","recur","causeArbitrary","Empty","Fail","Die","Interrupt","Sequential","Parallel","Cause","causeDecode","causePretty","cause","causeParse","isCause","causeEncode","CauseFromSelf","die","interrupt","sequential","parallel","error_","defect_","Defect","err","stack","exitFailureEncoded","exitSuccessEncoded","exitEncoded","exitDecode","failCause","exitArbitrary","exitPretty","exit","exitParse","decodeUnknownValue","decodeUnknownCause","isExit","ExitFromSelf","failure","success","Exit","success_","failure_","hashSetArbitrary","hashSetPretty","hashSetEquivalence","hashSetParse","isHashSet","HashSetFromSelf","HashSet","hashMapArbitrary","hashMapPretty","hashMapEquivalence","hashMapParse","isHashMap","HashMapFromSelf","HashMap","listArbitrary","listPretty","listEquivalence","listParse","isList","ListFromSelf","List","sortedSetArbitrary","ord","sortedSetPretty","sortedSetParse","isSortedSet","SortedSetFromSelf","ordA","ordI","SortedSet","BooleanFromUnknown","isTruthy","BooleanFromString","Config","string","mapOrFail","InvalidData","TreeFormatter","formatIssueSync","symbolSerializable","asSerializable","serializable","serializableSchema","serialize","deserialize","symbolWithResult","asWithResult","withExit","failureSchema","successSchema","exitSchemaCache","exitSchema","proto","getPrototypeOf","serializeFailure","deserializeFailure","serializeSuccess","deserializeSuccess","serializeExit","deserializeExit","asSerializableWithResult","procedure","TaggedRequest","payload","TaggedRequestClass","go","getEquivalenceAnnotation","getAnnotation","hook","isSome","getEquivalenceUnsupportedErrorMessage","memoizeThunk","annotatedAST","len","j","aStringKeys","aSymbolKeys","getOwnPropertySymbols","aHas","hasOwnProperty","call","bHas","bSymbolKeys","bStringKeys","base","getParameterBase","isSymbolKeyword","aKeys","searchTree","getSearchTree","candidates","isRecordOrArray","buckets","otherwise","tuples"],"mappings":"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","ignoreList":[0],"debugId":null}}]
}