{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"core.js","sources":["file://D%3A/Desktop/project/Business-Directory/Business-Directory/frontend/node_modules/effect/src/internal/core.ts"],"sourcesContent":["import * as Arr from \"../Array.js\"\nimport type * as Cause from \"../Cause.js\"\nimport * as Chunk from \"../Chunk.js\"\nimport * as Context from \"../Context.js\"\nimport type * as Deferred from \"../Deferred.js\"\nimport type * as Differ from \"../Differ.js\"\nimport * as Duration from \"../Duration.js\"\nimport type * as Effect from \"../Effect.js\"\nimport * as Either from \"../Either.js\"\nimport * as Equal from \"../Equal.js\"\nimport type * as ExecutionStrategy from \"../ExecutionStrategy.js\"\nimport type * as Exit from \"../Exit.js\"\nimport type * as Fiber from \"../Fiber.js\"\nimport * as FiberId from \"../FiberId.js\"\nimport type * as FiberRef from \"../FiberRef.js\"\nimport type * as FiberStatus from \"../FiberStatus.js\"\nimport type { LazyArg } from \"../Function.js\"\nimport { dual, identity, pipe } from \"../Function.js\"\nimport { globalValue } from \"../GlobalValue.js\"\nimport * as Hash from \"../Hash.js\"\nimport * as HashMap from \"../HashMap.js\"\nimport type * as HashSet from \"../HashSet.js\"\nimport { format, NodeInspectSymbol, toJSON } from \"../Inspectable.js\"\nimport * as List from \"../List.js\"\nimport type * as LogLevel from \"../LogLevel.js\"\nimport type * as LogSpan from \"../LogSpan.js\"\nimport type * as MetricLabel from \"../MetricLabel.js\"\nimport * as MutableRef from \"../MutableRef.js\"\nimport * as Option from \"../Option.js\"\nimport { pipeArguments } from \"../Pipeable.js\"\nimport { hasProperty, isObject, isPromiseLike, type Predicate, type Refinement } from \"../Predicate.js\"\nimport type * as Request from \"../Request.js\"\nimport type * as BlockedRequests from \"../RequestBlock.js\"\nimport type * as RequestResolver from \"../RequestResolver.js\"\nimport type * as RuntimeFlags from \"../RuntimeFlags.js\"\nimport * as RuntimeFlagsPatch from \"../RuntimeFlagsPatch.js\"\nimport type * as Scope from \"../Scope.js\"\nimport type * as Tracer from \"../Tracer.js\"\nimport type { NoInfer, NotFunction } from \"../Types.js\"\nimport { internalCall, YieldWrap } from \"../Utils.js\"\nimport * as _blockedRequests from \"./blockedRequests.js\"\nimport * as internalCause from \"./cause.js\"\nimport * as deferred from \"./deferred.js\"\nimport * as internalDiffer from \"./differ.js\"\nimport { CommitPrototype, effectVariance, StructuralCommitPrototype } from \"./effectable.js\"\nimport { getBugErrorMessage } from \"./errors.js\"\nimport type * as FiberRuntime from \"./fiberRuntime.js\"\nimport type * as fiberScope from \"./fiberScope.js\"\nimport * as DeferredOpCodes from \"./opCodes/deferred.js\"\nimport * as OpCodes from \"./opCodes/effect.js\"\nimport * as _runtimeFlags from \"./runtimeFlags.js\"\nimport { SingleShotGen } from \"./singleShotGen.js\"\n\n// -----------------------------------------------------------------------------\n// Effect\n// -----------------------------------------------------------------------------\n\n/** @internal */\nconst EffectErrorSymbolKey = \"effect/EffectError\"\n\n/** @internal */\nexport const EffectErrorTypeId = Symbol.for(EffectErrorSymbolKey)\n\n/** @internal */\nexport type EffectErrorTypeId = typeof EffectErrorTypeId\n\n/** @internal */\nexport interface EffectError<out E> {\n  readonly [EffectErrorTypeId]: EffectErrorTypeId\n  readonly _tag: \"EffectError\"\n  readonly cause: Cause.Cause<E>\n}\n\n/** @internal */\nexport const isEffectError = (u: unknown): u is EffectError<unknown> => hasProperty(u, EffectErrorTypeId)\n\n/** @internal */\nexport const makeEffectError = <E>(cause: Cause.Cause<E>): EffectError<E> => ({\n  [EffectErrorTypeId]: EffectErrorTypeId,\n  _tag: \"EffectError\",\n  cause\n})\n\n/**\n * @internal\n */\nexport const blocked = <A, E>(\n  blockedRequests: BlockedRequests.RequestBlock,\n  _continue: Effect.Effect<A, E>\n): Effect.Blocked<A, E> => {\n  const effect = new EffectPrimitive(\"Blocked\") as any\n  effect.effect_instruction_i0 = blockedRequests\n  effect.effect_instruction_i1 = _continue\n  return effect\n}\n\n/**\n * @internal\n */\nexport const runRequestBlock = (\n  blockedRequests: BlockedRequests.RequestBlock\n): Effect.Effect<void> => {\n  const effect = new EffectPrimitive(\"RunBlocked\") as any\n  effect.effect_instruction_i0 = blockedRequests\n  return effect\n}\n\n/** @internal */\nexport const EffectTypeId: Effect.EffectTypeId = Symbol.for(\"effect/Effect\") as Effect.EffectTypeId\n\n/** @internal */\nexport type Primitive =\n  | Async\n  | Commit\n  | Failure\n  | OnFailure\n  | OnSuccess\n  | OnStep\n  | OnSuccessAndFailure\n  | Success\n  | Sync\n  | UpdateRuntimeFlags\n  | While\n  | FromIterator\n  | WithRuntime\n  | Yield\n  | OpTag\n  | Blocked\n  | RunBlocked\n  | Either.Either<any, any>\n  | Option.Option<any>\n\n/** @internal */\nexport type Continuation =\n  | OnSuccess\n  | OnStep\n  | OnSuccessAndFailure\n  | OnFailure\n  | While\n  | FromIterator\n  | RevertFlags\n\n/** @internal */\nexport class RevertFlags {\n  readonly _op = OpCodes.OP_REVERT_FLAGS\n  constructor(\n    readonly patch: RuntimeFlagsPatch.RuntimeFlagsPatch,\n    readonly op: Primitive & { _op: OpCodes.OP_UPDATE_RUNTIME_FLAGS }\n  ) {\n  }\n}\n\nclass EffectPrimitive {\n  public effect_instruction_i0 = undefined\n  public effect_instruction_i1 = undefined\n  public effect_instruction_i2 = undefined\n  public trace = undefined;\n  [EffectTypeId] = effectVariance\n  constructor(readonly _op: Primitive[\"_op\"]) {}\n  [Equal.symbol](this: {}, that: unknown) {\n    return this === that\n  }\n  [Hash.symbol](this: {}) {\n    return Hash.cached(this, Hash.random(this))\n  }\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n  toJSON() {\n    return {\n      _id: \"Effect\",\n      _op: this._op,\n      effect_instruction_i0: toJSON(this.effect_instruction_i0),\n      effect_instruction_i1: toJSON(this.effect_instruction_i1),\n      effect_instruction_i2: toJSON(this.effect_instruction_i2)\n    }\n  }\n  toString() {\n    return format(this.toJSON())\n  }\n  [NodeInspectSymbol]() {\n    return this.toJSON()\n  }\n  [Symbol.iterator]() {\n    return new SingleShotGen(new YieldWrap(this))\n  }\n}\n\n/** @internal */\nclass EffectPrimitiveFailure {\n  public effect_instruction_i0 = undefined\n  public effect_instruction_i1 = undefined\n  public effect_instruction_i2 = undefined\n  public trace = undefined;\n  [EffectTypeId] = effectVariance\n  constructor(readonly _op: Primitive[\"_op\"]) {\n    // @ts-expect-error\n    this._tag = _op\n  }\n  [Equal.symbol](this: {}, that: unknown) {\n    return exitIsExit(that) && that._op === \"Failure\" &&\n      // @ts-expect-error\n      Equal.equals(this.effect_instruction_i0, that.effect_instruction_i0)\n  }\n  [Hash.symbol](this: {}) {\n    return pipe(\n      // @ts-expect-error\n      Hash.string(this._tag),\n      // @ts-expect-error\n      Hash.combine(Hash.hash(this.effect_instruction_i0)),\n      Hash.cached(this)\n    )\n  }\n  get cause() {\n    return this.effect_instruction_i0\n  }\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n  toJSON() {\n    return {\n      _id: \"Exit\",\n      _tag: this._op,\n      cause: (this.cause as any).toJSON()\n    }\n  }\n  toString() {\n    return format(this.toJSON())\n  }\n  [NodeInspectSymbol]() {\n    return this.toJSON()\n  }\n  [Symbol.iterator]() {\n    return new SingleShotGen(new YieldWrap(this))\n  }\n}\n\n/** @internal */\nclass EffectPrimitiveSuccess {\n  public effect_instruction_i0 = undefined\n  public effect_instruction_i1 = undefined\n  public effect_instruction_i2 = undefined\n  public trace = undefined;\n  [EffectTypeId] = effectVariance\n  constructor(readonly _op: Primitive[\"_op\"]) {\n    // @ts-expect-error\n    this._tag = _op\n  }\n  [Equal.symbol](this: {}, that: unknown) {\n    return exitIsExit(that) && that._op === \"Success\" &&\n      // @ts-expect-error\n      Equal.equals(this.effect_instruction_i0, that.effect_instruction_i0)\n  }\n  [Hash.symbol](this: {}) {\n    return pipe(\n      // @ts-expect-error\n      Hash.string(this._tag),\n      // @ts-expect-error\n      Hash.combine(Hash.hash(this.effect_instruction_i0)),\n      Hash.cached(this)\n    )\n  }\n  get value() {\n    return this.effect_instruction_i0\n  }\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n  toJSON() {\n    return {\n      _id: \"Exit\",\n      _tag: this._op,\n      value: toJSON(this.value)\n    }\n  }\n  toString() {\n    return format(this.toJSON())\n  }\n  [NodeInspectSymbol]() {\n    return this.toJSON()\n  }\n  [Symbol.iterator]() {\n    return new SingleShotGen(new YieldWrap(this))\n  }\n}\n\n/** @internal */\nexport type Op<Tag extends string, Body = {}> = Effect.Effect<never> & Body & {\n  readonly _op: Tag\n}\n\n/** @internal */\nexport interface Async extends\n  Op<OpCodes.OP_ASYNC, {\n    effect_instruction_i0(resume: (effect: Primitive) => void): void\n    readonly effect_instruction_i1: FiberId.FiberId\n  }>\n{}\n\n/** @internal */\nexport interface Blocked<out E = any, out A = any> extends\n  Op<\"Blocked\", {\n    readonly effect_instruction_i0: BlockedRequests.RequestBlock\n    readonly effect_instruction_i1: Effect.Effect<A, E>\n  }>\n{}\n\n/** @internal */\nexport interface RunBlocked extends\n  Op<\"RunBlocked\", {\n    readonly effect_instruction_i0: BlockedRequests.RequestBlock\n  }>\n{}\n\n/** @internal */\nexport interface Failure extends\n  Op<OpCodes.OP_FAILURE, {\n    readonly effect_instruction_i0: Cause.Cause<unknown>\n  }>\n{}\n\n/** @internal */\nexport interface OpTag extends Op<OpCodes.OP_TAG, {}> {}\n\n/** @internal */\nexport interface Commit extends\n  Op<OpCodes.OP_COMMIT, {\n    commit(): Effect.Effect<unknown, unknown, unknown>\n  }>\n{}\n\n/** @internal */\nexport interface OnFailure extends\n  Op<OpCodes.OP_ON_FAILURE, {\n    readonly effect_instruction_i0: Primitive\n    effect_instruction_i1(a: Cause.Cause<unknown>): Primitive\n  }>\n{}\n\n/** @internal */\nexport interface OnSuccess extends\n  Op<OpCodes.OP_ON_SUCCESS, {\n    readonly effect_instruction_i0: Primitive\n    effect_instruction_i1(a: unknown): Primitive\n  }>\n{}\n\n/** @internal */\nexport interface OnStep extends Op<\"OnStep\", { readonly effect_instruction_i0: Primitive }> {}\n\n/** @internal */\nexport interface OnSuccessAndFailure extends\n  Op<OpCodes.OP_ON_SUCCESS_AND_FAILURE, {\n    readonly effect_instruction_i0: Primitive\n    effect_instruction_i1(a: Cause.Cause<unknown>): Primitive\n    effect_instruction_i2(a: unknown): Primitive\n  }>\n{}\n\n/** @internal */\nexport interface Success extends\n  Op<OpCodes.OP_SUCCESS, {\n    readonly effect_instruction_i0: unknown\n  }>\n{}\n\n/** @internal */\nexport interface Sync extends\n  Op<OpCodes.OP_SYNC, {\n    effect_instruction_i0(): unknown\n  }>\n{}\n\n/** @internal */\nexport interface UpdateRuntimeFlags extends\n  Op<OpCodes.OP_UPDATE_RUNTIME_FLAGS, {\n    readonly effect_instruction_i0: RuntimeFlagsPatch.RuntimeFlagsPatch\n    readonly effect_instruction_i1?: (oldRuntimeFlags: RuntimeFlags.RuntimeFlags) => Primitive\n  }>\n{}\n\n/** @internal */\nexport interface While extends\n  Op<OpCodes.OP_WHILE, {\n    effect_instruction_i0(): boolean\n    effect_instruction_i1(): Primitive\n    effect_instruction_i2(a: unknown): void\n  }>\n{}\n\n/** @internal */\nexport interface FromIterator extends\n  Op<OpCodes.OP_ITERATOR, {\n    effect_instruction_i0: Iterator<YieldWrap<Primitive>, any>\n  }>\n{}\n\n/** @internal */\nexport interface WithRuntime extends\n  Op<OpCodes.OP_WITH_RUNTIME, {\n    effect_instruction_i0(fiber: FiberRuntime.FiberRuntime<unknown, unknown>, status: FiberStatus.Running): Primitive\n  }>\n{}\n\n/** @internal */\nexport interface Yield extends Op<OpCodes.OP_YIELD> {}\n\n/** @internal */\nexport const isEffect = (u: unknown): u is Effect.Effect<unknown, unknown, unknown> => hasProperty(u, EffectTypeId)\n\n/* @internal */\nexport const withFiberRuntime = <A, E = never, R = never>(\n  withRuntime: (fiber: FiberRuntime.FiberRuntime<A, E>, status: FiberStatus.Running) => Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R> => {\n  const effect = new EffectPrimitive(OpCodes.OP_WITH_RUNTIME) as any\n  effect.effect_instruction_i0 = withRuntime\n  return effect\n}\n\n/* @internal */\nexport const acquireUseRelease: {\n  <A2, E2, R2, A, X, R3>(\n    use: (a: A) => Effect.Effect<A2, E2, R2>,\n    release: (a: A, exit: Exit.Exit<A2, E2>) => Effect.Effect<X, never, R3>\n  ): <E, R>(acquire: Effect.Effect<A, E, R>) => Effect.Effect<A2, E2 | E, R2 | R3 | R>\n  <A, E, R, A2, E2, R2, X, R3>(\n    acquire: Effect.Effect<A, E, R>,\n    use: (a: A) => Effect.Effect<A2, E2, R2>,\n    release: (a: A, exit: Exit.Exit<A2, E2>) => Effect.Effect<X, never, R3>\n  ): Effect.Effect<A2, E | E2, R | R2 | R3>\n} = dual(3, <A, E, R, A2, E2, R2, X, R3>(\n  acquire: Effect.Effect<A, E, R>,\n  use: (a: A) => Effect.Effect<A2, E2, R2>,\n  release: (a: A, exit: Exit.Exit<A2, E2>) => Effect.Effect<X, never, R3>\n): Effect.Effect<A2, E | E2, R | R2 | R3> =>\n  uninterruptibleMask((restore) =>\n    flatMap(\n      acquire,\n      (a) =>\n        flatMap(exit(suspend(() => restore(use(a)))), (exit): Effect.Effect<A2, E | E2, R | R2 | R3> => {\n          return suspend(() => release(a, exit)).pipe(\n            matchCauseEffect({\n              onFailure: (cause) => {\n                switch (exit._tag) {\n                  case OpCodes.OP_FAILURE:\n                    return failCause(internalCause.sequential(exit.effect_instruction_i0, cause))\n                  case OpCodes.OP_SUCCESS:\n                    return failCause(cause)\n                }\n              },\n              onSuccess: () => exit\n            })\n          )\n        })\n    )\n  ))\n\n/* @internal */\nexport const as: {\n  <B>(value: B): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E, R>\n  <A, E, R, B>(self: Effect.Effect<A, E, R>, value: B): Effect.Effect<B, E, R>\n} = dual(\n  2,\n  <A, E, R, B>(self: Effect.Effect<A, E, R>, value: B): Effect.Effect<B, E, R> => flatMap(self, () => succeed(value))\n)\n\n/* @internal */\nexport const asVoid = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<void, E, R> => as(self, void 0)\n\n/* @internal */\nexport const custom: {\n  <X, A, E, R>(i0: X, body: (this: { effect_instruction_i0: X }) => Effect.Effect<A, E, R>): Effect.Effect<A, E, R>\n  <X, Y, A, E, R>(\n    i0: X,\n    i1: Y,\n    body: (this: { effect_instruction_i0: X; effect_instruction_i1: Y }) => Effect.Effect<A, E, R>\n  ): Effect.Effect<A, E, R>\n  <X, Y, Z, A, E, R>(\n    i0: X,\n    i1: Y,\n    i2: Z,\n    body: (\n      this: { effect_instruction_i0: X; effect_instruction_i1: Y; effect_instruction_i2: Z }\n    ) => Effect.Effect<A, E, R>\n  ): Effect.Effect<A, E, R>\n} = function() {\n  const wrapper = new EffectPrimitive(OpCodes.OP_COMMIT) as any\n  switch (arguments.length) {\n    case 2: {\n      wrapper.effect_instruction_i0 = arguments[0]\n      wrapper.commit = arguments[1]\n      break\n    }\n    case 3: {\n      wrapper.effect_instruction_i0 = arguments[0]\n      wrapper.effect_instruction_i1 = arguments[1]\n      wrapper.commit = arguments[2]\n      break\n    }\n    case 4: {\n      wrapper.effect_instruction_i0 = arguments[0]\n      wrapper.effect_instruction_i1 = arguments[1]\n      wrapper.effect_instruction_i2 = arguments[2]\n      wrapper.commit = arguments[3]\n      break\n    }\n    default: {\n      throw new Error(getBugErrorMessage(\"you're not supposed to end up here\"))\n    }\n  }\n  return wrapper\n}\n\n/* @internal */\nexport const unsafeAsync = <A, E = never, R = never>(\n  register: (\n    callback: (_: Effect.Effect<A, E, R>) => void\n  ) => void | Effect.Effect<void, never, R>,\n  blockingOn: FiberId.FiberId = FiberId.none\n): Effect.Effect<A, E, R> => {\n  const effect = new EffectPrimitive(OpCodes.OP_ASYNC) as any\n  let cancelerRef: Effect.Effect<void, never, R> | void = undefined\n  effect.effect_instruction_i0 = (resume: (_: Effect.Effect<A, E, R>) => void) => {\n    cancelerRef = register(resume)\n  }\n  effect.effect_instruction_i1 = blockingOn\n  return onInterrupt(effect, (_) => isEffect(cancelerRef) ? cancelerRef : void_)\n}\n\n/* @internal */\nexport const asyncInterrupt = <A, E = never, R = never>(\n  register: (\n    callback: (_: Effect.Effect<A, E, R>) => void\n  ) => void | Effect.Effect<void, never, R>,\n  blockingOn: FiberId.FiberId = FiberId.none\n): Effect.Effect<A, E, R> => suspend(() => unsafeAsync(register, blockingOn))\n\nconst async_ = <A, E = never, R = never>(\n  resume: (\n    callback: (_: Effect.Effect<A, E, R>) => void,\n    signal: AbortSignal\n  ) => void | Effect.Effect<void, never, R>,\n  blockingOn: FiberId.FiberId = FiberId.none\n): Effect.Effect<A, E, R> => {\n  return custom(resume, function() {\n    let backingResume: ((_: Effect.Effect<A, E, R>) => void) | undefined = undefined\n    let pendingEffect: Effect.Effect<A, E, R> | undefined = undefined\n    function proxyResume(effect: Effect.Effect<A, E, R>) {\n      if (backingResume) {\n        backingResume(effect)\n      } else if (pendingEffect === undefined) {\n        pendingEffect = effect\n      }\n    }\n    const effect = new EffectPrimitive(OpCodes.OP_ASYNC) as any\n    effect.effect_instruction_i0 = (resume: (_: Effect.Effect<A, E, R>) => void) => {\n      backingResume = resume\n      if (pendingEffect) {\n        resume(pendingEffect)\n      }\n    }\n    effect.effect_instruction_i1 = blockingOn\n    let cancelerRef: Effect.Effect<void, never, R> | void = undefined\n    let controllerRef: AbortController | void = undefined\n    if (this.effect_instruction_i0.length !== 1) {\n      controllerRef = new AbortController()\n      cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume, controllerRef!.signal))\n    } else {\n      cancelerRef = internalCall(() => (this.effect_instruction_i0 as any)(proxyResume))\n    }\n    return (cancelerRef || controllerRef) ?\n      onInterrupt(effect, (_) => {\n        if (controllerRef) {\n          controllerRef.abort()\n        }\n        return cancelerRef ?? void_\n      }) :\n      effect\n  })\n}\nexport {\n  /** @internal */\n  async_ as async\n}\n\n/* @internal */\nexport const catchAllCause = dual<\n  <E, A2, E2, R2>(\n    f: (cause: Cause.Cause<E>) => Effect.Effect<A2, E2, R2>\n  ) => <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A, E2, R2 | R>,\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    f: (cause: Cause.Cause<E>) => Effect.Effect<A2, E2, R2>\n  ) => Effect.Effect<A2 | A, E2, R2 | R>\n>(2, (self, f) => {\n  const effect = new EffectPrimitive(OpCodes.OP_ON_FAILURE) as any\n  effect.effect_instruction_i0 = self\n  effect.effect_instruction_i1 = f\n  return effect\n})\n\n/* @internal */\nexport const catchAll: {\n  <E, A2, E2, R2>(\n    f: (e: E) => Effect.Effect<A2, E2, R2>\n  ): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A, E2, R2 | R>\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    f: (e: E) => Effect.Effect<A2, E2, R2>\n  ): Effect.Effect<A2 | A, E2, R2 | R>\n} = dual(\n  2,\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    f: (e: E) => Effect.Effect<A2, E2, R2>\n  ): Effect.Effect<A2 | A, E2, R2 | R> => matchEffect(self, { onFailure: f, onSuccess: succeed })\n)\n\n/* @internal */\nexport const catchIf: {\n  <E, EB extends E, A2, E2, R2>(\n    refinement: Refinement<NoInfer<E>, EB>,\n    f: (e: EB) => Effect.Effect<A2, E2, R2>\n  ): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A, E2 | Exclude<E, EB>, R2 | R>\n  <E, A2, E2, R2>(\n    predicate: Predicate<NoInfer<E>>,\n    f: (e: NoInfer<E>) => Effect.Effect<A2, E2, R2>\n  ): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A, E | E2, R2 | R>\n  <A, E, R, EB extends E, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    refinement: Refinement<E, EB>,\n    f: (e: EB) => Effect.Effect<A2, E2, R2>\n  ): Effect.Effect<A2 | A, E2 | Exclude<E, EB>, R2 | R>\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    predicate: Predicate<E>,\n    f: (e: E) => Effect.Effect<A2, E2, R2>\n  ): Effect.Effect<A | A2, E | E2, R | R2>\n} = dual(3, <A, E, R, A2, E2, R2>(\n  self: Effect.Effect<A, E, R>,\n  predicate: Predicate<E>,\n  f: (e: E) => Effect.Effect<A2, E2, R2>\n): Effect.Effect<A | A2, E | E2, R | R2> =>\n  catchAllCause(self, (cause): Effect.Effect<A | A2, E | E2, R | R2> => {\n    const either = internalCause.failureOrCause(cause)\n    switch (either._tag) {\n      case \"Left\":\n        return predicate(either.left) ? f(either.left) : failCause(cause)\n      case \"Right\":\n        return failCause(either.right)\n    }\n  }))\n\n/* @internal */\nexport const catchSome = dual<\n  <E, A2, E2, R2>(\n    pf: (e: NoInfer<E>) => Option.Option<Effect.Effect<A2, E2, R2>>\n  ) => <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A, E | E2, R2 | R>,\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    pf: (e: NoInfer<E>) => Option.Option<Effect.Effect<A2, E2, R2>>\n  ) => Effect.Effect<A2 | A, E | E2, R2 | R>\n>(2, <A, E, R, A2, E2, R2>(\n  self: Effect.Effect<A, E, R>,\n  pf: (e: NoInfer<E>) => Option.Option<Effect.Effect<A2, E2, R2>>\n) =>\n  catchAllCause(self, (cause): Effect.Effect<A2 | A, E | E2, R2 | R> => {\n    const either = internalCause.failureOrCause(cause)\n    switch (either._tag) {\n      case \"Left\":\n        return pipe(pf(either.left), Option.getOrElse(() => failCause(cause)))\n      case \"Right\":\n        return failCause(either.right)\n    }\n  }))\n\n/* @internal */\nexport const checkInterruptible = <A, E, R>(\n  f: (isInterruptible: boolean) => Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R> => withFiberRuntime((_, status) => f(_runtimeFlags.interruption(status.runtimeFlags)))\n\nconst spanSymbol = Symbol.for(\"effect/SpanAnnotation\")\nconst originalSymbol = Symbol.for(\"effect/OriginalAnnotation\")\n\n/* @internal */\nexport const originalInstance = <E>(obj: E): E => {\n  if (hasProperty(obj, originalSymbol)) {\n    // @ts-expect-error\n    return obj[originalSymbol]\n  }\n  return obj\n}\n\n/* @internal */\nexport const capture = <E>(obj: E & object, span: Option.Option<Tracer.Span>): E => {\n  if (Option.isSome(span)) {\n    return new Proxy(obj, {\n      has(target, p) {\n        return p === spanSymbol || p === originalSymbol || p in target\n      },\n      get(target, p) {\n        if (p === spanSymbol) {\n          return span.value\n        }\n        if (p === originalSymbol) {\n          return obj\n        }\n        // @ts-expect-error\n        return target[p]\n      }\n    })\n  }\n  return obj\n}\n\n/* @internal */\nexport const die = (defect: unknown): Effect.Effect<never> =>\n  isObject(defect) && !(spanSymbol in defect) ?\n    withFiberRuntime((fiber) => failCause(internalCause.die(capture(defect, currentSpanFromFiber(fiber)))))\n    : failCause(internalCause.die(defect))\n\n/* @internal */\nexport const dieMessage = (message: string): Effect.Effect<never> =>\n  failCauseSync(() => internalCause.die(new RuntimeException(message)))\n\n/* @internal */\nexport const dieSync = (evaluate: LazyArg<unknown>): Effect.Effect<never> => flatMap(sync(evaluate), die)\n\n/* @internal */\nexport const either = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<Either.Either<A, E>, never, R> =>\n  matchEffect(self, {\n    onFailure: (e) => succeed(Either.left(e)),\n    onSuccess: (a) => succeed(Either.right(a))\n  })\n\n/* @internal */\nexport const exit = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<Exit.Exit<A, E>, never, R> =>\n  matchCause(self, {\n    onFailure: exitFailCause,\n    onSuccess: exitSucceed\n  })\n\n/* @internal */\nexport const fail = <E>(error: E): Effect.Effect<never, E> =>\n  isObject(error) && !(spanSymbol in error) ?\n    withFiberRuntime((fiber) => failCause(internalCause.fail(capture(error, currentSpanFromFiber(fiber)))))\n    : failCause(internalCause.fail(error))\n\n/* @internal */\nexport const failSync = <E>(evaluate: LazyArg<E>): Effect.Effect<never, E> => flatMap(sync(evaluate), fail)\n\n/* @internal */\nexport const failCause = <E>(cause: Cause.Cause<E>): Effect.Effect<never, E> => {\n  const effect = new EffectPrimitiveFailure(OpCodes.OP_FAILURE) as any\n  effect.effect_instruction_i0 = cause\n  return effect\n}\n\n/* @internal */\nexport const failCauseSync = <E>(\n  evaluate: LazyArg<Cause.Cause<E>>\n): Effect.Effect<never, E> => flatMap(sync(evaluate), failCause)\n\n/* @internal */\nexport const fiberId: Effect.Effect<FiberId.FiberId> = withFiberRuntime((state) => succeed(state.id()))\n\n/* @internal */\nexport const fiberIdWith = <A, E, R>(\n  f: (descriptor: FiberId.Runtime) => Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R> => withFiberRuntime((state) => f(state.id()))\n\n/* @internal */\nexport const flatMap = dual<\n  <A, B, E1, R1>(\n    f: (a: A) => Effect.Effect<B, E1, R1>\n  ) => <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E1 | E, R1 | R>,\n  <A, E, R, B, E1, R1>(\n    self: Effect.Effect<A, E, R>,\n    f: (a: A) => Effect.Effect<B, E1, R1>\n  ) => Effect.Effect<B, E | E1, R | R1>\n>(\n  2,\n  (self, f) => {\n    const effect = new EffectPrimitive(OpCodes.OP_ON_SUCCESS) as any\n    effect.effect_instruction_i0 = self\n    effect.effect_instruction_i1 = f\n    return effect\n  }\n)\n\n/* @internal */\nexport const andThen: {\n  <A, X>(\n    f: (a: NoInfer<A>) => X\n  ): <E, R>(\n    self: Effect.Effect<A, E, R>\n  ) => [X] extends [Effect.Effect<infer A1, infer E1, infer R1>] ? Effect.Effect<A1, E | E1, R | R1>\n    : [X] extends [PromiseLike<infer A1>] ? Effect.Effect<A1, E | Cause.UnknownException, R>\n    : Effect.Effect<X, E, R>\n  <X>(\n    f: NotFunction<X>\n  ): <A, E, R>(\n    self: Effect.Effect<A, E, R>\n  ) => [X] extends [Effect.Effect<infer A1, infer E1, infer R1>] ? Effect.Effect<A1, E | E1, R | R1>\n    : [X] extends [PromiseLike<infer A1>] ? Effect.Effect<A1, E | Cause.UnknownException, R>\n    : Effect.Effect<X, E, R>\n  <A, E, R, X>(\n    self: Effect.Effect<A, E, R>,\n    f: (a: NoInfer<A>) => X\n  ): [X] extends [Effect.Effect<infer A1, infer E1, infer R1>] ? Effect.Effect<A1, E | E1, R | R1>\n    : [X] extends [PromiseLike<infer A1>] ? Effect.Effect<A1, E | Cause.UnknownException, R>\n    : Effect.Effect<X, E, R>\n  <A, E, R, X>(\n    self: Effect.Effect<A, E, R>,\n    f: NotFunction<X>\n  ): [X] extends [Effect.Effect<infer A1, infer E1, infer R1>] ? Effect.Effect<A1, E | E1, R | R1>\n    : [X] extends [PromiseLike<infer A1>] ? Effect.Effect<A1, E | Cause.UnknownException, R>\n    : Effect.Effect<X, E, R>\n} = dual(2, (self, f) =>\n  flatMap(self, (a) => {\n    const b = typeof f === \"function\" ? (f as any)(a) : f\n    if (isEffect(b)) {\n      return b\n    } else if (isPromiseLike(b)) {\n      return unsafeAsync<any, Cause.UnknownException>((resume) => {\n        b.then((a) => resume(succeed(a)), (e) => resume(fail(new UnknownException(e))))\n      })\n    }\n    return succeed(b)\n  }))\n\n/* @internal */\nexport const step = <A, E, R>(\n  self: Effect.Effect<A, E, R>\n): Effect.Effect<Exit.Exit<A, E> | Effect.Blocked<A, E>, never, R> => {\n  const effect = new EffectPrimitive(\"OnStep\") as any\n  effect.effect_instruction_i0 = self\n  return effect\n}\n\n/* @internal */\nexport const flatten = <A, E1, R1, E, R>(\n  self: Effect.Effect<Effect.Effect<A, E1, R1>, E, R>\n): Effect.Effect<A, E | E1, R | R1> => flatMap(self, identity)\n\n/* @internal */\nexport const flip = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<E, A, R> =>\n  matchEffect(self, { onFailure: succeed, onSuccess: fail })\n\n/* @internal */\nexport const matchCause: {\n  <E, A2, A, A3>(\n    options: {\n      readonly onFailure: (cause: Cause.Cause<E>) => A2\n      readonly onSuccess: (a: A) => A3\n    }\n  ): <R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A3, never, R>\n  <A, E, R, A2, A3>(\n    self: Effect.Effect<A, E, R>,\n    options: {\n      readonly onFailure: (cause: Cause.Cause<E>) => A2\n      readonly onSuccess: (a: A) => A3\n    }\n  ): Effect.Effect<A2 | A3, never, R>\n} = dual(2, <A, E, R, A2, A3>(\n  self: Effect.Effect<A, E, R>,\n  options: {\n    readonly onFailure: (cause: Cause.Cause<E>) => A2\n    readonly onSuccess: (a: A) => A3\n  }\n): Effect.Effect<A2 | A3, never, R> =>\n  matchCauseEffect(self, {\n    onFailure: (cause) => succeed(options.onFailure(cause)),\n    onSuccess: (a) => succeed(options.onSuccess(a))\n  }))\n\n/* @internal */\nexport const matchCauseEffect: {\n  <E, A2, E2, R2, A, A3, E3, R3>(\n    options: {\n      readonly onFailure: (cause: Cause.Cause<E>) => Effect.Effect<A2, E2, R2>\n      readonly onSuccess: (a: A) => Effect.Effect<A3, E3, R3>\n    }\n  ): <R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A3, E2 | E3, R2 | R3 | R>\n  <A, E, R, A2, E2, R2, A3, E3, R3>(\n    self: Effect.Effect<A, E, R>,\n    options: {\n      readonly onFailure: (cause: Cause.Cause<E>) => Effect.Effect<A2, E2, R2>\n      readonly onSuccess: (a: A) => Effect.Effect<A3, E3, R3>\n    }\n  ): Effect.Effect<A2 | A3, E2 | E3, R2 | R3 | R>\n} = dual(2, <A, E, R, A2, E2, R2, A3, E3, R3>(\n  self: Effect.Effect<A, E, R>,\n  options: {\n    readonly onFailure: (cause: Cause.Cause<E>) => Effect.Effect<A2, E2, R2>\n    readonly onSuccess: (a: A) => Effect.Effect<A3, E3, R3>\n  }\n): Effect.Effect<A2 | A3, E2 | E3, R2 | R3 | R> => {\n  const effect = new EffectPrimitive(OpCodes.OP_ON_SUCCESS_AND_FAILURE) as any\n  effect.effect_instruction_i0 = self\n  effect.effect_instruction_i1 = options.onFailure\n  effect.effect_instruction_i2 = options.onSuccess\n  return effect\n})\n\n/* @internal */\nexport const matchEffect: {\n  <E, A2, E2, R2, A, A3, E3, R3>(\n    options: {\n      readonly onFailure: (e: E) => Effect.Effect<A2, E2, R2>\n      readonly onSuccess: (a: A) => Effect.Effect<A3, E3, R3>\n    }\n  ): <R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A3, E2 | E3, R2 | R3 | R>\n  <A, E, R, A2, E2, R2, A3, E3, R3>(\n    self: Effect.Effect<A, E, R>,\n    options: {\n      readonly onFailure: (e: E) => Effect.Effect<A2, E2, R2>\n      readonly onSuccess: (a: A) => Effect.Effect<A3, E3, R3>\n    }\n  ): Effect.Effect<A2 | A3, E2 | E3, R2 | R3 | R>\n} = dual(2, <A, E, R, A2, E2, R2, A3, E3, R3>(\n  self: Effect.Effect<A, E, R>,\n  options: {\n    readonly onFailure: (e: E) => Effect.Effect<A2, E2, R2>\n    readonly onSuccess: (a: A) => Effect.Effect<A3, E3, R3>\n  }\n): Effect.Effect<A2 | A3, E2 | E3, R2 | R3 | R> =>\n  matchCauseEffect(self, {\n    onFailure: (cause) => {\n      const defects = internalCause.defects(cause)\n      if (defects.length > 0) {\n        return failCause(internalCause.electFailures(cause))\n      }\n      const failures = internalCause.failures(cause)\n      if (failures.length > 0) {\n        return options.onFailure(Chunk.unsafeHead(failures))\n      }\n      return failCause(cause as Cause.Cause<never>)\n    },\n    onSuccess: options.onSuccess\n  }))\n\n/* @internal */\nexport const forEachSequential: {\n  <A, B, E, R>(f: (a: A, i: number) => Effect.Effect<B, E, R>): (self: Iterable<A>) => Effect.Effect<Array<B>, E, R>\n  <A, B, E, R>(self: Iterable<A>, f: (a: A, i: number) => Effect.Effect<B, E, R>): Effect.Effect<Array<B>, E, R>\n} = dual(\n  2,\n  <A, B, E, R>(self: Iterable<A>, f: (a: A, i: number) => Effect.Effect<B, E, R>): Effect.Effect<Array<B>, E, R> =>\n    suspend(() => {\n      const arr = Arr.fromIterable(self)\n      const ret = Arr.allocate<B>(arr.length)\n      let i = 0\n      return as(\n        whileLoop({\n          while: () => i < arr.length,\n          body: () => f(arr[i], i),\n          step: (b) => {\n            ret[i++] = b\n          }\n        }),\n        ret as Array<B>\n      )\n    })\n)\n\n/* @internal */\nexport const forEachSequentialDiscard: {\n  <A, B, E, R>(f: (a: A, i: number) => Effect.Effect<B, E, R>): (self: Iterable<A>) => Effect.Effect<void, E, R>\n  <A, B, E, R>(self: Iterable<A>, f: (a: A, i: number) => Effect.Effect<B, E, R>): Effect.Effect<void, E, R>\n} = dual(\n  2,\n  <A, B, E, R>(self: Iterable<A>, f: (a: A, i: number) => Effect.Effect<B, E, R>): Effect.Effect<void, E, R> =>\n    suspend(() => {\n      const arr = Arr.fromIterable(self)\n      let i = 0\n      return whileLoop({\n        while: () => i < arr.length,\n        body: () => f(arr[i], i),\n        step: () => {\n          i++\n        }\n      })\n    })\n)\n\n/* @internal */\nexport const if_ = dual<\n  <A1, E1, R1, A2, E2, R2>(\n    options: {\n      readonly onTrue: LazyArg<Effect.Effect<A1, E1, R1>>\n      readonly onFalse: LazyArg<Effect.Effect<A2, E2, R2>>\n    }\n  ) => <E = never, R = never>(\n    self: Effect.Effect<boolean, E, R> | boolean\n  ) => Effect.Effect<A1 | A2, E | E1 | E2, R | R1 | R2>,\n  <A1, E1, R1, A2, E2, R2, E = never, R = never>(\n    self: Effect.Effect<boolean, E, R> | boolean,\n    options: {\n      readonly onTrue: LazyArg<Effect.Effect<A1, E1, R1>>\n      readonly onFalse: LazyArg<Effect.Effect<A2, E2, R2>>\n    }\n  ) => Effect.Effect<A1 | A2, E1 | E2 | E, R1 | R2 | R>\n>(\n  (args) => typeof args[0] === \"boolean\" || isEffect(args[0]),\n  <A1, E1, R1, A2, E2, R2, E = never, R = never>(\n    self: Effect.Effect<boolean, E, R> | boolean,\n    options: {\n      readonly onTrue: LazyArg<Effect.Effect<A1, E1, R1>>\n      readonly onFalse: LazyArg<Effect.Effect<A2, E2, R2>>\n    }\n  ): Effect.Effect<A1 | A2, E1 | E2 | E, R1 | R2 | R> =>\n    isEffect(self)\n      ? flatMap(self, (b): Effect.Effect<A1 | A2, E1 | E2, R1 | R2> => (b ? options.onTrue() : options.onFalse()))\n      : self\n      ? options.onTrue()\n      : options.onFalse()\n)\n\n/* @internal */\nexport const interrupt: Effect.Effect<never> = flatMap(fiberId, (fiberId) => interruptWith(fiberId))\n\n/* @internal */\nexport const interruptWith = (fiberId: FiberId.FiberId): Effect.Effect<never> =>\n  failCause(internalCause.interrupt(fiberId))\n\n/* @internal */\nexport const interruptible = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<A, E, R> => {\n  const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS) as any\n  effect.effect_instruction_i0 = RuntimeFlagsPatch.enable(_runtimeFlags.Interruption)\n  effect.effect_instruction_i1 = () => self\n  return effect\n}\n\n/* @internal */\nexport const interruptibleMask = <A, E, R>(\n  f: (restore: <AX, EX, RX>(effect: Effect.Effect<AX, EX, RX>) => Effect.Effect<AX, EX, RX>) => Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R> =>\n  custom(f, function() {\n    const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS) as any\n    effect.effect_instruction_i0 = RuntimeFlagsPatch.enable(_runtimeFlags.Interruption)\n    effect.effect_instruction_i1 = (oldFlags: RuntimeFlags.RuntimeFlags) =>\n      _runtimeFlags.interruption(oldFlags)\n        ? internalCall(() => this.effect_instruction_i0(interruptible))\n        : internalCall(() => this.effect_instruction_i0(uninterruptible))\n    return effect\n  })\n\n/* @internal */\nexport const intoDeferred: {\n  <A, E>(deferred: Deferred.Deferred<A, E>): <R>(self: Effect.Effect<A, E, R>) => Effect.Effect<boolean, never, R>\n  <A, E, R>(self: Effect.Effect<A, E, R>, deferred: Deferred.Deferred<A, E>): Effect.Effect<boolean, never, R>\n} = dual(\n  2,\n  <A, E, R>(self: Effect.Effect<A, E, R>, deferred: Deferred.Deferred<A, E>): Effect.Effect<boolean, never, R> =>\n    uninterruptibleMask((restore) =>\n      flatMap(\n        exit(restore(self)),\n        (exit) => deferredDone(deferred, exit)\n      )\n    )\n)\n\n/* @internal */\nexport const map: {\n  <A, B>(f: (a: A) => B): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E, R>\n  <A, E, R, B>(self: Effect.Effect<A, E, R>, f: (a: A) => B): Effect.Effect<B, E, R>\n} = dual(\n  2,\n  <A, E, R, B>(self: Effect.Effect<A, E, R>, f: (a: A) => B): Effect.Effect<B, E, R> =>\n    flatMap(self, (a) => sync(() => f(a)))\n)\n\n/* @internal */\nexport const mapBoth: {\n  <E, E2, A, A2>(\n    options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2 }\n  ): <R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2, E2, R>\n  <A, E, R, E2, A2>(\n    self: Effect.Effect<A, E, R>,\n    options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2 }\n  ): Effect.Effect<A2, E2, R>\n} = dual(2, <A, E, R, E2, A2>(\n  self: Effect.Effect<A, E, R>,\n  options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2 }\n): Effect.Effect<A2, E2, R> =>\n  matchEffect(self, {\n    onFailure: (e) => failSync(() => options.onFailure(e)),\n    onSuccess: (a) => sync(() => options.onSuccess(a))\n  }))\n\n/* @internal */\nexport const mapError: {\n  <E, E2>(f: (e: E) => E2): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E2, R>\n  <A, E, R, E2>(self: Effect.Effect<A, E, R>, f: (e: E) => E2): Effect.Effect<A, E2, R>\n} = dual(\n  2,\n  <A, E, R, E2>(self: Effect.Effect<A, E, R>, f: (e: E) => E2): Effect.Effect<A, E2, R> =>\n    matchCauseEffect(self, {\n      onFailure: (cause) => {\n        const either = internalCause.failureOrCause(cause)\n        switch (either._tag) {\n          case \"Left\": {\n            return failSync(() => f(either.left))\n          }\n          case \"Right\": {\n            return failCause(either.right)\n          }\n        }\n      },\n      onSuccess: succeed\n    })\n)\n\n/* @internal */\nexport const onError: {\n  <E, X, R2>(\n    cleanup: (cause: Cause.Cause<E>) => Effect.Effect<X, never, R2>\n  ): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R2 | R>\n  <A, E, R, X, R2>(\n    self: Effect.Effect<A, E, R>,\n    cleanup: (cause: Cause.Cause<E>) => Effect.Effect<X, never, R2>\n  ): Effect.Effect<A, E, R2 | R>\n} = dual(2, <A, E, R, X, R2>(\n  self: Effect.Effect<A, E, R>,\n  cleanup: (cause: Cause.Cause<E>) => Effect.Effect<X, never, R2>\n): Effect.Effect<A, E, R2 | R> =>\n  onExit(self, (exit) => exitIsSuccess(exit) ? void_ : cleanup(exit.effect_instruction_i0)))\n\n/* @internal */\nexport const onExit: {\n  <A, E, X, R2>(\n    cleanup: (exit: Exit.Exit<A, E>) => Effect.Effect<X, never, R2>\n  ): <R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R2 | R>\n  <A, E, R, X, R2>(\n    self: Effect.Effect<A, E, R>,\n    cleanup: (exit: Exit.Exit<A, E>) => Effect.Effect<X, never, R2>\n  ): Effect.Effect<A, E, R2 | R>\n} = dual(2, <A, E, R, X, R2>(\n  self: Effect.Effect<A, E, R>,\n  cleanup: (exit: Exit.Exit<A, E>) => Effect.Effect<X, never, R2>\n): Effect.Effect<A, E, R2 | R> =>\n  uninterruptibleMask((restore) =>\n    matchCauseEffect(restore(self), {\n      onFailure: (cause1) => {\n        const result = exitFailCause(cause1)\n        return matchCauseEffect(cleanup(result), {\n          onFailure: (cause2) => exitFailCause(internalCause.sequential(cause1, cause2)),\n          onSuccess: () => result\n        })\n      },\n      onSuccess: (success) => {\n        const result = exitSucceed(success)\n        return zipRight(cleanup(result), result)\n      }\n    })\n  ))\n\n/* @internal */\nexport const onInterrupt: {\n  <X, R2>(\n    cleanup: (interruptors: HashSet.HashSet<FiberId.FiberId>) => Effect.Effect<X, never, R2>\n  ): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R2 | R>\n  <A, E, R, X, R2>(\n    self: Effect.Effect<A, E, R>,\n    cleanup: (interruptors: HashSet.HashSet<FiberId.FiberId>) => Effect.Effect<X, never, R2>\n  ): Effect.Effect<A, E, R2 | R>\n} = dual(2, <A, E, R, X, R2>(\n  self: Effect.Effect<A, E, R>,\n  cleanup: (interruptors: HashSet.HashSet<FiberId.FiberId>) => Effect.Effect<X, never, R2>\n): Effect.Effect<A, E, R2 | R> =>\n  onExit(\n    self,\n    exitMatch({\n      onFailure: (cause) =>\n        internalCause.isInterruptedOnly(cause)\n          ? asVoid(cleanup(internalCause.interruptors(cause)))\n          : void_,\n      onSuccess: () => void_\n    })\n  ))\n\n/* @internal */\nexport const orElse: {\n  <A2, E2, R2>(\n    that: LazyArg<Effect.Effect<A2, E2, R2>>\n  ): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A, E2, R2 | R>\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    that: LazyArg<Effect.Effect<A2, E2, R2>>\n  ): Effect.Effect<A2 | A, E2, R2 | R>\n} = dual(\n  2,\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    that: LazyArg<Effect.Effect<A2, E2, R2>>\n  ): Effect.Effect<A2 | A, E2, R2 | R> => attemptOrElse(self, that, succeed)\n)\n\n/* @internal */\nexport const orDie = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<A, never, R> => orDieWith(self, identity)\n\n/* @internal */\nexport const orDieWith: {\n  <E>(f: (error: E) => unknown): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, never, R>\n  <A, E, R>(self: Effect.Effect<A, E, R>, f: (error: E) => unknown): Effect.Effect<A, never, R>\n} = dual(\n  2,\n  <A, E, R>(self: Effect.Effect<A, E, R>, f: (error: E) => unknown): Effect.Effect<A, never, R> =>\n    matchEffect(self, {\n      onFailure: (e) => die(f(e)),\n      onSuccess: succeed\n    })\n)\n\n/* @internal */\nexport const partitionMap: <A, A1, A2>(\n  elements: Iterable<A>,\n  f: (a: A) => Either.Either<A2, A1>\n) => [left: Array<A1>, right: Array<A2>] = Arr.partitionMap\n/* @internal */\nexport const runtimeFlags: Effect.Effect<RuntimeFlags.RuntimeFlags> = withFiberRuntime((_, status) =>\n  succeed(status.runtimeFlags)\n)\n\n/* @internal */\nexport const succeed = <A>(value: A): Effect.Effect<A> => {\n  const effect = new EffectPrimitiveSuccess(OpCodes.OP_SUCCESS) as any\n  effect.effect_instruction_i0 = value\n  return effect\n}\n\n/* @internal */\nexport const suspend = <A, E, R>(evaluate: LazyArg<Effect.Effect<A, E, R>>): Effect.Effect<A, E, R> => {\n  const effect = new EffectPrimitive(OpCodes.OP_COMMIT) as any\n  effect.commit = evaluate\n  return effect\n}\n\n/* @internal */\nexport const sync = <A>(thunk: LazyArg<A>): Effect.Effect<A> => {\n  const effect = new EffectPrimitive(OpCodes.OP_SYNC) as any\n  effect.effect_instruction_i0 = thunk\n  return effect\n}\n\n/* @internal */\nexport const tap = dual<\n  {\n    <A, X>(\n      f: (a: NoInfer<A>) => X\n    ): <E, R>(\n      self: Effect.Effect<A, E, R>\n    ) => [X] extends [Effect.Effect<infer _A1, infer E1, infer R1>] ? Effect.Effect<A, E | E1, R | R1>\n      : [X] extends [PromiseLike<infer _A1>] ? Effect.Effect<A, E | Cause.UnknownException, R>\n      : Effect.Effect<A, E, R>\n    <A, X, E1, R1>(\n      f: (a: NoInfer<A>) => Effect.Effect<X, E1, R1>,\n      options: { onlyEffect: true }\n    ): <E, R>(\n      self: Effect.Effect<A, E, R>\n    ) => Effect.Effect<A, E | E1, R | R1>\n    <X>(\n      f: NotFunction<X>\n    ): <A, E, R>(\n      self: Effect.Effect<A, E, R>\n    ) => [X] extends [Effect.Effect<infer _A1, infer E1, infer R1>] ? Effect.Effect<A, E | E1, R | R1>\n      : [X] extends [PromiseLike<infer _A1>] ? Effect.Effect<A, E | Cause.UnknownException, R>\n      : Effect.Effect<A, E, R>\n    <X, E1, R1>(\n      f: Effect.Effect<X, E1, R1>,\n      options: { onlyEffect: true }\n    ): <A, E, R>(\n      self: Effect.Effect<A, E, R>\n    ) => Effect.Effect<A, E | E1, R | R1>\n  },\n  {\n    <A, E, R, X>(\n      self: Effect.Effect<A, E, R>,\n      f: (a: NoInfer<A>) => X\n    ): [X] extends [Effect.Effect<infer _A1, infer E1, infer R1>] ? Effect.Effect<A, E | E1, R | R1>\n      : [X] extends [PromiseLike<infer _A1>] ? Effect.Effect<A, E | Cause.UnknownException, R>\n      : Effect.Effect<A, E, R>\n    <A, E, R, X, E1, R1>(\n      self: Effect.Effect<A, E, R>,\n      f: (a: NoInfer<A>) => Effect.Effect<X, E1, R1>,\n      options: { onlyEffect: true }\n    ): Effect.Effect<A, E | E1, R | R1>\n    <A, E, R, X>(\n      self: Effect.Effect<A, E, R>,\n      f: NotFunction<X>\n    ): [X] extends [Effect.Effect<infer _A1, infer E1, infer R1>] ? Effect.Effect<A, E | E1, R | R1>\n      : [X] extends [PromiseLike<infer _A1>] ? Effect.Effect<A, E | Cause.UnknownException, R>\n      : Effect.Effect<A, E, R>\n    <A, E, R, X, E1, R1>(\n      self: Effect.Effect<A, E, R>,\n      f: Effect.Effect<X, E1, R1>,\n      options: { onlyEffect: true }\n    ): Effect.Effect<A, E | E1, R | R1>\n  }\n>(\n  (args) => args.length === 3 || args.length === 2 && !(isObject(args[1]) && \"onlyEffect\" in args[1]),\n  <A, E, R, X>(self: Effect.Effect<A, E, R>, f: X) =>\n    flatMap(self, (a) => {\n      const b = typeof f === \"function\" ? (f as any)(a) : f\n      if (isEffect(b)) {\n        return as(b, a)\n      } else if (isPromiseLike(b)) {\n        return unsafeAsync<any, Cause.UnknownException>((resume) => {\n          b.then((_) => resume(succeed(a)), (e) => resume(fail(new UnknownException(e))))\n        })\n      }\n      return succeed(a)\n    })\n)\n\n/* @internal */\nexport const transplant = <A, E, R>(\n  f: (grafter: <A2, E2, R2>(effect: Effect.Effect<A2, E2, R2>) => Effect.Effect<A2, E2, R2>) => Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R> =>\n  withFiberRuntime<A, E, R>((state) => {\n    const scopeOverride = state.getFiberRef(currentForkScopeOverride)\n    const scope = pipe(scopeOverride, Option.getOrElse(() => state.scope()))\n    return f(fiberRefLocally(currentForkScopeOverride, Option.some(scope)))\n  })\n\n/* @internal */\nexport const attemptOrElse: {\n  <A2, E2, R2, A, A3, E3, R3>(\n    that: LazyArg<Effect.Effect<A2, E2, R2>>,\n    onSuccess: (a: A) => Effect.Effect<A3, E3, R3>\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A3, E2 | E3, R | R2 | R3>\n  <A, E, R, A2, E2, R2, A3, E3, R3>(\n    self: Effect.Effect<A, E, R>,\n    that: LazyArg<Effect.Effect<A2, E2, R2>>,\n    onSuccess: (a: A) => Effect.Effect<A3, E3, R3>\n  ): Effect.Effect<A2 | A3, E2 | E3, R | R2 | R3>\n} = dual(3, <A, E, R, A2, E2, R2, A3, E3, R3>(\n  self: Effect.Effect<A, E, R>,\n  that: LazyArg<Effect.Effect<A2, E2, R2>>,\n  onSuccess: (a: A) => Effect.Effect<A3, E3, R3>\n): Effect.Effect<A2 | A3, E2 | E3, R | R2 | R3> =>\n  matchCauseEffect(self, {\n    onFailure: (cause) => {\n      const defects = internalCause.defects(cause)\n      if (defects.length > 0) {\n        return failCause(Option.getOrThrow(internalCause.keepDefectsAndElectFailures(cause)))\n      }\n      return that()\n    },\n    onSuccess\n  }))\n\n/* @internal */\nexport const uninterruptible: <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R> = <A, E, R>(\n  self: Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R> => {\n  const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS) as any\n  effect.effect_instruction_i0 = RuntimeFlagsPatch.disable(_runtimeFlags.Interruption)\n  effect.effect_instruction_i1 = () => self\n  return effect\n}\n\n/* @internal */\nexport const uninterruptibleMask = <A, E, R>(\n  f: (restore: <AX, EX, RX>(effect: Effect.Effect<AX, EX, RX>) => Effect.Effect<AX, EX, RX>) => Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R> =>\n  custom(f, function() {\n    const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS) as any\n    effect.effect_instruction_i0 = RuntimeFlagsPatch.disable(_runtimeFlags.Interruption)\n    effect.effect_instruction_i1 = (oldFlags: RuntimeFlags.RuntimeFlags) =>\n      _runtimeFlags.interruption(oldFlags)\n        ? internalCall(() => this.effect_instruction_i0(interruptible))\n        : internalCall(() => this.effect_instruction_i0(uninterruptible))\n    return effect\n  })\n\nconst void_: Effect.Effect<void> = succeed(void 0)\nexport {\n  /* @internal */\n  void_ as void\n}\n\n/* @internal */\nexport const updateRuntimeFlags = (patch: RuntimeFlagsPatch.RuntimeFlagsPatch): Effect.Effect<void> => {\n  const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS) as any\n  effect.effect_instruction_i0 = patch\n  effect.effect_instruction_i1 = void 0\n  return effect\n}\n\n/* @internal */\nexport const whenEffect: {\n  <E, R>(\n    condition: Effect.Effect<boolean, E, R>\n  ): <A, E2, R2>(\n    effect: Effect.Effect<A, E2, R2>\n  ) => Effect.Effect<Option.Option<A>, E | E2, R | R2>\n  <A, E2, R2, E, R>(\n    self: Effect.Effect<A, E2, R2>,\n    condition: Effect.Effect<boolean, E, R>\n  ): Effect.Effect<Option.Option<A>, E | E2, R | R2>\n} = dual(2, <A, E2, R2, E, R>(\n  self: Effect.Effect<A, E2, R2>,\n  condition: Effect.Effect<boolean, E, R>\n): Effect.Effect<Option.Option<A>, E | E2, R | R2> =>\n  flatMap(condition, (b) => {\n    if (b) {\n      return pipe(self, map(Option.some))\n    }\n    return succeed(Option.none())\n  }))\n\n/* @internal */\nexport const whileLoop = <A, E, R>(\n  options: {\n    readonly while: LazyArg<boolean>\n    readonly body: LazyArg<Effect.Effect<A, E, R>>\n    readonly step: (a: A) => void\n  }\n): Effect.Effect<void, E, R> => {\n  const effect = new EffectPrimitive(OpCodes.OP_WHILE) as any\n  effect.effect_instruction_i0 = options.while\n  effect.effect_instruction_i1 = options.body\n  effect.effect_instruction_i2 = options.step\n  return effect\n}\n\n/* @internal */\nexport const fromIterator = <Eff extends YieldWrap<Effect.Effect<any, any, any>>, AEff>(\n  iterator: LazyArg<Iterator<Eff, AEff, never>>\n): Effect.Effect<\n  AEff,\n  [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect.Effect<infer _A, infer E, infer _R>>] ? E : never,\n  [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect.Effect<infer _A, infer _E, infer R>>] ? R : never\n> =>\n  suspend(() => {\n    const effect = new EffectPrimitive(OpCodes.OP_ITERATOR) as any\n    effect.effect_instruction_i0 = iterator()\n    return effect\n  })\n\n/* @internal */\nexport const gen: typeof Effect.gen = function() {\n  const f = arguments.length === 1 ? arguments[0] : arguments[1].bind(arguments[0])\n  return fromIterator(() => f(pipe))\n}\n\n/* @internal */\nexport const withConcurrency = dual<\n  (concurrency: number | \"unbounded\") => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, concurrency: number | \"unbounded\") => Effect.Effect<A, E, R>\n>(2, (self, concurrency) => fiberRefLocally(self, currentConcurrency, concurrency))\n\n/* @internal */\nexport const withRequestBatching = dual<\n  (requestBatching: boolean) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, requestBatching: boolean) => Effect.Effect<A, E, R>\n>(2, (self, requestBatching) => fiberRefLocally(self, currentRequestBatching, requestBatching))\n\n/* @internal */\nexport const withRuntimeFlags = dual<\n  (update: RuntimeFlagsPatch.RuntimeFlagsPatch) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, update: RuntimeFlagsPatch.RuntimeFlagsPatch) => Effect.Effect<A, E, R>\n>(2, (self, update) => {\n  const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS) as any\n  effect.effect_instruction_i0 = update\n  effect.effect_instruction_i1 = () => self\n  return effect\n})\n\n/** @internal */\nexport const withTracerEnabled = dual<\n  (enabled: boolean) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(effect: Effect.Effect<A, E, R>, enabled: boolean) => Effect.Effect<A, E, R>\n>(2, (effect, enabled) =>\n  fiberRefLocally(\n    effect,\n    currentTracerEnabled,\n    enabled\n  ))\n\n/** @internal */\nexport const withTracerTiming = dual<\n  (enabled: boolean) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(effect: Effect.Effect<A, E, R>, enabled: boolean) => Effect.Effect<A, E, R>\n>(2, (effect, enabled) =>\n  fiberRefLocally(\n    effect,\n    currentTracerTimingEnabled,\n    enabled\n  ))\n\n/* @internal */\nexport const yieldNow = (options?: {\n  readonly priority?: number | undefined\n}): Effect.Effect<void> => {\n  const effect = new EffectPrimitive(OpCodes.OP_YIELD) as any\n  return typeof options?.priority !== \"undefined\" ?\n    withSchedulingPriority(effect, options.priority) :\n    effect\n}\n\n/* @internal */\nexport const zip = dual<\n  <A2, E2, R2>(\n    that: Effect.Effect<A2, E2, R2>\n  ) => <A, E, R>(\n    self: Effect.Effect<A, E, R>\n  ) => Effect.Effect<[A, A2], E | E2, R | R2>,\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    that: Effect.Effect<A2, E2, R2>\n  ) => Effect.Effect<[A, A2], E | E2, R | R2>\n>(2, <A, E, R, A2, E2, R2>(\n  self: Effect.Effect<A, E, R>,\n  that: Effect.Effect<A2, E2, R2>\n): Effect.Effect<[A, A2], E | E2, R | R2> => flatMap(self, (a) => map(that, (b) => [a, b])))\n\n/* @internal */\nexport const zipFlatten: {\n  <A2, E2, R2>(\n    that: Effect.Effect<A2, E2, R2>\n  ): <A extends ReadonlyArray<any>, E, R>(\n    self: Effect.Effect<A, E, R>\n  ) => Effect.Effect<[...A, A2], E | E2, R | R2>\n  <A extends ReadonlyArray<any>, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    that: Effect.Effect<A2, E2, R2>\n  ): Effect.Effect<[...A, A2], E | E2, R | R2>\n} = dual(2, <A extends ReadonlyArray<any>, E, R, A2, E2, R2>(\n  self: Effect.Effect<A, E, R>,\n  that: Effect.Effect<A2, E2, R2>\n): Effect.Effect<[...A, A2], E | E2, R | R2> => flatMap(self, (a) => map(that, (b) => [...a, b])))\n\n/* @internal */\nexport const zipLeft: {\n  <A2, E2, R2>(\n    that: Effect.Effect<A2, E2, R2>\n  ): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E | E2, R | R2>\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    that: Effect.Effect<A2, E2, R2>\n  ): Effect.Effect<A, E | E2, R | R2>\n} = dual(2, <A, E, R, A2, E2, R2>(\n  self: Effect.Effect<A, E, R>,\n  that: Effect.Effect<A2, E2, R2>\n): Effect.Effect<A, E | E2, R | R2> => flatMap(self, (a) => as(that, a)))\n\n/* @internal */\nexport const zipRight: {\n  <A2, E2, R2>(\n    that: Effect.Effect<A2, E2, R2>\n  ): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2, E | E2, R | R2>\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    that: Effect.Effect<A2, E2, R2>\n  ): Effect.Effect<A2, E | E2, R | R2>\n} = dual(2, <A, E, R, A2, E2, R2>(\n  self: Effect.Effect<A, E, R>,\n  that: Effect.Effect<A2, E2, R2>\n): Effect.Effect<A2, E | E2, R | R2> => flatMap(self, () => that))\n\n/* @internal */\nexport const zipWith: {\n  <A2, E2, R2, A, B>(\n    that: Effect.Effect<A2, E2, R2>,\n    f: (a: A, b: A2) => B\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E | E2, R | R2>\n  <A, E, R, A2, E2, R2, B>(\n    self: Effect.Effect<A, E, R>,\n    that: Effect.Effect<A2, E2, R2>,\n    f: (a: A, b: A2) => B\n  ): Effect.Effect<B, E | E2, R | R2>\n} = dual(3, <A, E, R, A2, E2, R2, B>(\n  self: Effect.Effect<A, E, R>,\n  that: Effect.Effect<A2, E2, R2>,\n  f: (a: A, b: A2) => B\n): Effect.Effect<B, E | E2, R | R2> => flatMap(self, (a) => map(that, (b) => f(a, b))))\n\n/* @internal */\nexport const never: Effect.Effect<never> = asyncInterrupt<never>(() => {\n  const interval = setInterval(() => {\n    //\n  }, 2 ** 31 - 1)\n  return sync(() => clearInterval(interval))\n})\n\n// -----------------------------------------------------------------------------\n// Fiber\n// -----------------------------------------------------------------------------\n\n/* @internal */\nexport const interruptFiber = <A, E>(self: Fiber.Fiber<A, E>): Effect.Effect<Exit.Exit<A, E>> =>\n  flatMap(fiberId, (fiberId) => pipe(self, interruptAsFiber(fiberId)))\n\n/* @internal */\nexport const interruptAsFiber = dual<\n  (fiberId: FiberId.FiberId) => <A, E>(self: Fiber.Fiber<A, E>) => Effect.Effect<Exit.Exit<A, E>>,\n  <A, E>(self: Fiber.Fiber<A, E>, fiberId: FiberId.FiberId) => Effect.Effect<Exit.Exit<A, E>>\n>(2, (self, fiberId) => flatMap(self.interruptAsFork(fiberId), () => self.await))\n\n// -----------------------------------------------------------------------------\n// LogLevel\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const logLevelAll: LogLevel.LogLevel = {\n  _tag: \"All\",\n  syslog: 0,\n  label: \"ALL\",\n  ordinal: Number.MIN_SAFE_INTEGER,\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const logLevelFatal: LogLevel.LogLevel = {\n  _tag: \"Fatal\",\n  syslog: 2,\n  label: \"FATAL\",\n  ordinal: 50000,\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const logLevelError: LogLevel.LogLevel = {\n  _tag: \"Error\",\n  syslog: 3,\n  label: \"ERROR\",\n  ordinal: 40000,\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const logLevelWarning: LogLevel.LogLevel = {\n  _tag: \"Warning\",\n  syslog: 4,\n  label: \"WARN\",\n  ordinal: 30000,\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const logLevelInfo: LogLevel.LogLevel = {\n  _tag: \"Info\",\n  syslog: 6,\n  label: \"INFO\",\n  ordinal: 20000,\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const logLevelDebug: LogLevel.LogLevel = {\n  _tag: \"Debug\",\n  syslog: 7,\n  label: \"DEBUG\",\n  ordinal: 10000,\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const logLevelTrace: LogLevel.LogLevel = {\n  _tag: \"Trace\",\n  syslog: 7,\n  label: \"TRACE\",\n  ordinal: 0,\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const logLevelNone: LogLevel.LogLevel = {\n  _tag: \"None\",\n  syslog: 7,\n  label: \"OFF\",\n  ordinal: Number.MAX_SAFE_INTEGER,\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const allLogLevels: ReadonlyArray<LogLevel.LogLevel> = [\n  logLevelAll,\n  logLevelTrace,\n  logLevelDebug,\n  logLevelInfo,\n  logLevelWarning,\n  logLevelError,\n  logLevelFatal,\n  logLevelNone\n]\n\n// -----------------------------------------------------------------------------\n// FiberRef\n// -----------------------------------------------------------------------------\n\n/** @internal */\nconst FiberRefSymbolKey = \"effect/FiberRef\"\n\n/** @internal */\nexport const FiberRefTypeId: FiberRef.FiberRefTypeId = Symbol.for(\n  FiberRefSymbolKey\n) as FiberRef.FiberRefTypeId\n\nconst fiberRefVariance = {\n  /* c8 ignore next */\n  _A: (_: any) => _\n}\n\n/* @internal */\nexport const fiberRefGet = <A>(self: FiberRef.FiberRef<A>): Effect.Effect<A> =>\n  withFiberRuntime((fiber) => exitSucceed(fiber.getFiberRef(self)))\n\n/* @internal */\nexport const fiberRefGetAndSet = dual<\n  <A>(value: A) => (self: FiberRef.FiberRef<A>) => Effect.Effect<A>,\n  <A>(self: FiberRef.FiberRef<A>, value: A) => Effect.Effect<A>\n>(2, (self, value) => fiberRefModify(self, (v) => [v, value] as const))\n\n/* @internal */\nexport const fiberRefGetAndUpdate = dual<\n  <A>(f: (a: A) => A) => (self: FiberRef.FiberRef<A>) => Effect.Effect<A>,\n  <A>(self: FiberRef.FiberRef<A>, f: (a: A) => A) => Effect.Effect<A>\n>(2, (self, f) => fiberRefModify(self, (v) => [v, f(v)] as const))\n\n/* @internal */\nexport const fiberRefGetAndUpdateSome = dual<\n  <A>(\n    pf: (a: A) => Option.Option<A>\n  ) => (self: FiberRef.FiberRef<A>) => Effect.Effect<A>,\n  <A>(\n    self: FiberRef.FiberRef<A>,\n    pf: (a: A) => Option.Option<A>\n  ) => Effect.Effect<A>\n>(2, (self, pf) => fiberRefModify(self, (v) => [v, Option.getOrElse(pf(v), () => v)] as const))\n\n/* @internal */\nexport const fiberRefGetWith = dual<\n  <B, E, R, A>(f: (a: A) => Effect.Effect<B, E, R>) => (self: FiberRef.FiberRef<A>) => Effect.Effect<B, E, R>,\n  <A, B, E, R>(self: FiberRef.FiberRef<A>, f: (a: A) => Effect.Effect<B, E, R>) => Effect.Effect<B, E, R>\n>(2, (self, f) => flatMap(fiberRefGet(self), f))\n\n/* @internal */\nexport const fiberRefSet = dual<\n  <A>(value: A) => (self: FiberRef.FiberRef<A>) => Effect.Effect<void>,\n  <A>(self: FiberRef.FiberRef<A>, value: A) => Effect.Effect<void>\n>(2, (self, value) => fiberRefModify(self, () => [void 0, value] as const))\n\n/* @internal */\nexport const fiberRefDelete = <A>(self: FiberRef.FiberRef<A>): Effect.Effect<void> =>\n  withFiberRuntime((state) => {\n    state.unsafeDeleteFiberRef(self)\n    return void_\n  })\n\n/* @internal */\nexport const fiberRefReset = <A>(self: FiberRef.FiberRef<A>): Effect.Effect<void> => fiberRefSet(self, self.initial)\n\n/* @internal */\nexport const fiberRefModify = dual<\n  <A, B>(f: (a: A) => readonly [B, A]) => (self: FiberRef.FiberRef<A>) => Effect.Effect<B>,\n  <A, B>(self: FiberRef.FiberRef<A>, f: (a: A) => readonly [B, A]) => Effect.Effect<B>\n>(2, <A, B>(\n  self: FiberRef.FiberRef<A>,\n  f: (a: A) => readonly [B, A]\n): Effect.Effect<B> =>\n  withFiberRuntime((state) => {\n    const [b, a] = f(state.getFiberRef(self) as A)\n    state.setFiberRef(self, a)\n    return succeed(b)\n  }))\n\n/* @internal */\nexport const fiberRefModifySome = <A, B>(\n  self: FiberRef.FiberRef<A>,\n  def: B,\n  f: (a: A) => Option.Option<readonly [B, A]>\n): Effect.Effect<B> => fiberRefModify(self, (v) => Option.getOrElse(f(v), () => [def, v] as const))\n\n/* @internal */\nexport const fiberRefUpdate = dual<\n  <A>(f: (a: A) => A) => (self: FiberRef.FiberRef<A>) => Effect.Effect<void>,\n  <A>(self: FiberRef.FiberRef<A>, f: (a: A) => A) => Effect.Effect<void>\n>(2, (self, f) => fiberRefModify(self, (v) => [void 0, f(v)] as const))\n\n/* @internal */\nexport const fiberRefUpdateSome = dual<\n  <A>(pf: (a: A) => Option.Option<A>) => (self: FiberRef.FiberRef<A>) => Effect.Effect<void>,\n  <A>(self: FiberRef.FiberRef<A>, pf: (a: A) => Option.Option<A>) => Effect.Effect<void>\n>(2, (self, pf) => fiberRefModify(self, (v) => [void 0, Option.getOrElse(pf(v), () => v)] as const))\n\n/* @internal */\nexport const fiberRefUpdateAndGet = dual<\n  <A>(f: (a: A) => A) => (self: FiberRef.FiberRef<A>) => Effect.Effect<A>,\n  <A>(self: FiberRef.FiberRef<A>, f: (a: A) => A) => Effect.Effect<A>\n>(2, (self, f) =>\n  fiberRefModify(self, (v) => {\n    const result = f(v)\n    return [result, result] as const\n  }))\n\n/* @internal */\nexport const fiberRefUpdateSomeAndGet = dual<\n  <A>(pf: (a: A) => Option.Option<A>) => (self: FiberRef.FiberRef<A>) => Effect.Effect<A>,\n  <A>(self: FiberRef.FiberRef<A>, pf: (a: A) => Option.Option<A>) => Effect.Effect<A>\n>(2, (self, pf) =>\n  fiberRefModify(self, (v) => {\n    const result = Option.getOrElse(pf(v), () => v)\n    return [result, result] as const\n  }))\n\n// circular\n/** @internal */\nconst RequestResolverSymbolKey = \"effect/RequestResolver\"\n\n/** @internal */\nexport const RequestResolverTypeId: RequestResolver.RequestResolverTypeId = Symbol.for(\n  RequestResolverSymbolKey\n) as RequestResolver.RequestResolverTypeId\n\nconst requestResolverVariance = {\n  /* c8 ignore next */\n  _A: (_: unknown) => _,\n  /* c8 ignore next */\n  _R: (_: never) => _\n}\n\n/** @internal */\nexport class RequestResolverImpl<in A, out R> implements RequestResolver.RequestResolver<A, R> {\n  readonly [RequestResolverTypeId] = requestResolverVariance\n  constructor(\n    readonly runAll: (\n      requests: Array<Array<Request.Entry<A>>>\n    ) => Effect.Effect<void, never, R>,\n    readonly target?: unknown\n  ) {\n  }\n  [Hash.symbol](): number {\n    return Hash.cached(this, this.target ? Hash.hash(this.target) : Hash.random(this))\n  }\n  [Equal.symbol](that: unknown): boolean {\n    return this.target ?\n      isRequestResolver(that) && Equal.equals(this.target, (that as RequestResolverImpl<any, any>).target) :\n      this === that\n  }\n  identified(...ids: Array<unknown>): RequestResolver.RequestResolver<A, R> {\n    return new RequestResolverImpl(this.runAll, Chunk.fromIterable(ids))\n  }\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const isRequestResolver = (u: unknown): u is RequestResolver.RequestResolver<unknown, unknown> =>\n  hasProperty(u, RequestResolverTypeId)\n\n// end\n\n/** @internal */\nexport const resolverLocally = dual<\n  <A>(\n    self: FiberRef.FiberRef<A>,\n    value: A\n  ) => <R, B extends Request.Request<any, any>>(\n    use: RequestResolver.RequestResolver<B, R>\n  ) => RequestResolver.RequestResolver<B, R>,\n  <R, B extends Request.Request<any, any>, A>(\n    use: RequestResolver.RequestResolver<B, R>,\n    self: FiberRef.FiberRef<A>,\n    value: A\n  ) => RequestResolver.RequestResolver<B, R>\n>(3, <R, B extends Request.Request<any, any>, A>(\n  use: RequestResolver.RequestResolver<B, R>,\n  self: FiberRef.FiberRef<A>,\n  value: A\n): RequestResolver.RequestResolver<B, R> =>\n  new RequestResolverImpl<B, R>(\n    (requests) =>\n      fiberRefLocally(\n        use.runAll(requests),\n        self,\n        value\n      ),\n    Chunk.make(\"Locally\", use, self, value)\n  ))\n\n/** @internal */\nexport const requestBlockLocally = <A>(\n  self: BlockedRequests.RequestBlock,\n  ref: FiberRef.FiberRef<A>,\n  value: A\n): BlockedRequests.RequestBlock => _blockedRequests.reduce(self, LocallyReducer(ref, value))\n\nconst LocallyReducer = <A>(\n  ref: FiberRef.FiberRef<A>,\n  value: A\n): BlockedRequests.RequestBlock.Reducer<BlockedRequests.RequestBlock> => ({\n  emptyCase: () => _blockedRequests.empty,\n  parCase: (left, right) => _blockedRequests.par(left, right),\n  seqCase: (left, right) => _blockedRequests.seq(left, right),\n  singleCase: (dataSource, blockedRequest) =>\n    _blockedRequests.single(\n      resolverLocally(dataSource, ref, value),\n      blockedRequest as any\n    )\n})\n\n/* @internal */\nexport const fiberRefLocally: {\n  <A>(self: FiberRef.FiberRef<A>, value: A): <B, E, R>(use: Effect.Effect<B, E, R>) => Effect.Effect<B, E, R>\n  <B, E, R, A>(use: Effect.Effect<B, E, R>, self: FiberRef.FiberRef<A>, value: A): Effect.Effect<B, E, R>\n} = dual(\n  3,\n  <B, E, R, A>(use: Effect.Effect<B, E, R>, self: FiberRef.FiberRef<A>, value: A): Effect.Effect<B, E, R> =>\n    acquireUseRelease(\n      zipLeft(fiberRefGet(self), fiberRefSet(self, value)),\n      () => use,\n      (oldValue) => fiberRefSet(self, oldValue)\n    )\n)\n\n/* @internal */\nexport const fiberRefLocallyWith = dual<\n  <A>(self: FiberRef.FiberRef<A>, f: (a: A) => A) => <B, E, R>(use: Effect.Effect<B, E, R>) => Effect.Effect<B, E, R>,\n  <B, E, R, A>(use: Effect.Effect<B, E, R>, self: FiberRef.FiberRef<A>, f: (a: A) => A) => Effect.Effect<B, E, R>\n>(3, (use, self, f) => fiberRefGetWith(self, (a) => fiberRefLocally(use, self, f(a))))\n\n/** @internal */\nexport const fiberRefUnsafeMake = <Value>(\n  initial: Value,\n  options?: {\n    readonly fork?: ((a: Value) => Value) | undefined\n    readonly join?: ((left: Value, right: Value) => Value) | undefined\n  }\n): FiberRef.FiberRef<Value> =>\n  fiberRefUnsafeMakePatch(initial, {\n    differ: internalDiffer.update(),\n    fork: options?.fork ?? identity,\n    join: options?.join\n  })\n\n/** @internal */\nexport const fiberRefUnsafeMakeHashSet = <A>(\n  initial: HashSet.HashSet<A>\n): FiberRef.FiberRef<HashSet.HashSet<A>> => {\n  const differ = internalDiffer.hashSet<A>()\n  return fiberRefUnsafeMakePatch(initial, {\n    differ,\n    fork: differ.empty\n  })\n}\n\n/** @internal */\nexport const fiberRefUnsafeMakeReadonlyArray = <A>(\n  initial: ReadonlyArray<A>\n): FiberRef.FiberRef<ReadonlyArray<A>> => {\n  const differ = internalDiffer.readonlyArray(internalDiffer.update<A>())\n  return fiberRefUnsafeMakePatch(initial, {\n    differ,\n    fork: differ.empty\n  })\n}\n\n/** @internal */\nexport const fiberRefUnsafeMakeContext = <A>(\n  initial: Context.Context<A>\n): FiberRef.FiberRef<Context.Context<A>> => {\n  const differ = internalDiffer.environment<A>()\n  return fiberRefUnsafeMakePatch(initial, {\n    differ,\n    fork: differ.empty\n  })\n}\n\n/** @internal */\nexport const fiberRefUnsafeMakePatch = <Value, Patch>(\n  initial: Value,\n  options: {\n    readonly differ: Differ.Differ<Value, Patch>\n    readonly fork: Patch\n    readonly join?: ((oldV: Value, newV: Value) => Value) | undefined\n  }\n): FiberRef.FiberRef<Value> => {\n  const _fiberRef = {\n    ...CommitPrototype,\n    [FiberRefTypeId]: fiberRefVariance,\n    initial,\n    commit() {\n      return fiberRefGet(this)\n    },\n    diff: (oldValue: Value, newValue: Value) => options.differ.diff(oldValue, newValue),\n    combine: (first: Patch, second: Patch) => options.differ.combine(first, second),\n    patch: (patch: Patch) => (oldValue: Value) => options.differ.patch(patch, oldValue),\n    fork: options.fork,\n    join: options.join ?? ((_, n) => n)\n  }\n  return _fiberRef\n}\n\n/** @internal */\nexport const fiberRefUnsafeMakeRuntimeFlags = (\n  initial: RuntimeFlags.RuntimeFlags\n): FiberRef.FiberRef<RuntimeFlags.RuntimeFlags> =>\n  fiberRefUnsafeMakePatch(initial, {\n    differ: _runtimeFlags.differ,\n    fork: _runtimeFlags.differ.empty\n  })\n\n/** @internal */\nexport const currentContext: FiberRef.FiberRef<Context.Context<never>> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentContext\"),\n  () => fiberRefUnsafeMakeContext(Context.empty())\n)\n\n/** @internal */\nexport const currentSchedulingPriority: FiberRef.FiberRef<number> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentSchedulingPriority\"),\n  () => fiberRefUnsafeMake(0)\n)\n\n/** @internal */\nexport const currentMaxOpsBeforeYield: FiberRef.FiberRef<number> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentMaxOpsBeforeYield\"),\n  () => fiberRefUnsafeMake(2048)\n)\n\n/** @internal */\nexport const currentLogAnnotations: FiberRef.FiberRef<HashMap.HashMap<string, unknown>> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentLogAnnotation\"),\n  () => fiberRefUnsafeMake(HashMap.empty())\n)\n\n/** @internal */\nexport const currentLogLevel: FiberRef.FiberRef<LogLevel.LogLevel> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentLogLevel\"),\n  () => fiberRefUnsafeMake<LogLevel.LogLevel>(logLevelInfo)\n)\n\n/** @internal */\nexport const currentLogSpan: FiberRef.FiberRef<List.List<LogSpan.LogSpan>> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentLogSpan\"),\n  () => fiberRefUnsafeMake(List.empty<LogSpan.LogSpan>())\n)\n\n/** @internal */\nexport const withSchedulingPriority = dual<\n  (priority: number) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, priority: number) => Effect.Effect<A, E, R>\n>(2, (self, scheduler) => fiberRefLocally(self, currentSchedulingPriority, scheduler))\n\n/** @internal */\nexport const withMaxOpsBeforeYield = dual<\n  (priority: number) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, priority: number) => Effect.Effect<A, E, R>\n>(2, (self, scheduler) => fiberRefLocally(self, currentMaxOpsBeforeYield, scheduler))\n\n/** @internal */\nexport const currentConcurrency: FiberRef.FiberRef<\"unbounded\" | number> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentConcurrency\"),\n  () => fiberRefUnsafeMake<\"unbounded\" | number>(\"unbounded\")\n)\n\n/**\n * @internal\n */\nexport const currentRequestBatching = globalValue(\n  Symbol.for(\"effect/FiberRef/currentRequestBatching\"),\n  () => fiberRefUnsafeMake(true)\n)\n\n/** @internal */\nexport const currentUnhandledErrorLogLevel: FiberRef.FiberRef<Option.Option<LogLevel.LogLevel>> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentUnhandledErrorLogLevel\"),\n  () => fiberRefUnsafeMake(Option.some<LogLevel.LogLevel>(logLevelDebug))\n)\n\n/** @internal */\nexport const withUnhandledErrorLogLevel = dual<\n  (level: Option.Option<LogLevel.LogLevel>) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, level: Option.Option<LogLevel.LogLevel>) => Effect.Effect<A, E, R>\n>(2, (self, level) => fiberRefLocally(self, currentUnhandledErrorLogLevel, level))\n\n/** @internal */\nexport const currentMetricLabels: FiberRef.FiberRef<ReadonlyArray<MetricLabel.MetricLabel>> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentMetricLabels\"),\n  () => fiberRefUnsafeMakeReadonlyArray(Arr.empty())\n)\n\n/* @internal */\nexport const metricLabels: Effect.Effect<ReadonlyArray<MetricLabel.MetricLabel>> = fiberRefGet(\n  currentMetricLabels\n)\n\n/** @internal */\nexport const currentForkScopeOverride: FiberRef.FiberRef<Option.Option<fiberScope.FiberScope>> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentForkScopeOverride\"),\n  () =>\n    fiberRefUnsafeMake(Option.none(), {\n      fork: () => Option.none() as Option.Option<fiberScope.FiberScope>,\n      join: (parent, _) => parent\n    })\n)\n\n/** @internal */\nexport const currentInterruptedCause: FiberRef.FiberRef<Cause.Cause<never>> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentInterruptedCause\"),\n  () =>\n    fiberRefUnsafeMake(internalCause.empty, {\n      fork: () => internalCause.empty,\n      join: (parent, _) => parent\n    })\n)\n\n/** @internal */\nexport const currentTracerEnabled: FiberRef.FiberRef<boolean> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentTracerEnabled\"),\n  () => fiberRefUnsafeMake(true)\n)\n\n/** @internal */\nexport const currentTracerTimingEnabled: FiberRef.FiberRef<boolean> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentTracerTiming\"),\n  () => fiberRefUnsafeMake(true)\n)\n\n/** @internal */\nexport const currentTracerSpanAnnotations: FiberRef.FiberRef<HashMap.HashMap<string, unknown>> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentTracerSpanAnnotations\"),\n  () => fiberRefUnsafeMake(HashMap.empty())\n)\n\n/** @internal */\nexport const currentTracerSpanLinks: FiberRef.FiberRef<Chunk.Chunk<Tracer.SpanLink>> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentTracerSpanLinks\"),\n  () => fiberRefUnsafeMake(Chunk.empty())\n)\n\n// -----------------------------------------------------------------------------\n// Scope\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const ScopeTypeId: Scope.ScopeTypeId = Symbol.for(\"effect/Scope\") as Scope.ScopeTypeId\n\n/** @internal */\nexport const CloseableScopeTypeId: Scope.CloseableScopeTypeId = Symbol.for(\n  \"effect/CloseableScope\"\n) as Scope.CloseableScopeTypeId\n\n/* @internal */\nexport const scopeAddFinalizer = (\n  self: Scope.Scope,\n  finalizer: Effect.Effect<unknown>\n): Effect.Effect<void> => self.addFinalizer(() => asVoid(finalizer))\n\n/* @internal */\nexport const scopeAddFinalizerExit = (\n  self: Scope.Scope,\n  finalizer: Scope.Scope.Finalizer\n): Effect.Effect<void> => self.addFinalizer(finalizer)\n\n/* @internal */\nexport const scopeClose = (\n  self: Scope.Scope.Closeable,\n  exit: Exit.Exit<unknown, unknown>\n): Effect.Effect<void> => self.close(exit)\n\n/* @internal */\nexport const scopeFork = (\n  self: Scope.Scope,\n  strategy: ExecutionStrategy.ExecutionStrategy\n): Effect.Effect<Scope.Scope.Closeable> => self.fork(strategy)\n\n// -----------------------------------------------------------------------------\n// Cause\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const causeSquash = <E>(self: Cause.Cause<E>): unknown => {\n  return causeSquashWith(identity)(self)\n}\n\n/** @internal */\nexport const causeSquashWith = dual<\n  <E>(f: (error: E) => unknown) => (self: Cause.Cause<E>) => unknown,\n  <E>(self: Cause.Cause<E>, f: (error: E) => unknown) => unknown\n>(2, (self, f) => {\n  const option = pipe(self, internalCause.failureOption, Option.map(f))\n  switch (option._tag) {\n    case \"None\": {\n      return pipe(\n        internalCause.defects(self),\n        Chunk.head,\n        Option.match({\n          onNone: () => {\n            const interrupts = Arr.fromIterable(internalCause.interruptors(self)).flatMap((fiberId) =>\n              Arr.fromIterable(FiberId.ids(fiberId)).map((id) => `#${id}`)\n            )\n            return new InterruptedException(interrupts ? `Interrupted by fibers: ${interrupts.join(\", \")}` : void 0)\n          },\n          onSome: identity\n        })\n      )\n    }\n    case \"Some\": {\n      return option.value\n    }\n  }\n})\n\n// -----------------------------------------------------------------------------\n// Errors\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const YieldableError: new(message?: string, options?: ErrorOptions) => Cause.YieldableError = (function() {\n  class YieldableError extends globalThis.Error {\n    commit() {\n      return fail(this)\n    }\n    toJSON() {\n      return { ...this }\n    }\n    [NodeInspectSymbol]() {\n      if (this.toString !== globalThis.Error.prototype.toString) {\n        return this.stack ? `${this.toString()}\\n${this.stack.split(\"\\n\").slice(1).join(\"\\n\")}` : this.toString()\n      } else if (\"Bun\" in globalThis) {\n        return internalCause.pretty(internalCause.fail(this), { renderErrorCause: true })\n      }\n      return this\n    }\n  }\n  Object.assign(YieldableError.prototype, StructuralCommitPrototype)\n  return YieldableError as any\n})()\n\nconst makeException = <T extends { _tag: string; message?: string }>(\n  proto: Omit<T, keyof Cause.YieldableError | \"_tag\">,\n  tag: T[\"_tag\"]\n): new(message?: string | undefined) => T => {\n  class Base extends YieldableError {\n    readonly _tag = tag\n  }\n  Object.assign(Base.prototype, proto)\n  ;(Base.prototype as any).name = tag\n  return Base as any\n}\n\n/** @internal */\nexport const RuntimeExceptionTypeId: Cause.RuntimeExceptionTypeId = Symbol.for(\n  \"effect/Cause/errors/RuntimeException\"\n) as Cause.RuntimeExceptionTypeId\n\n/** @internal */\nexport const RuntimeException = makeException<Cause.RuntimeException>({\n  [RuntimeExceptionTypeId]: RuntimeExceptionTypeId\n}, \"RuntimeException\")\n\n/** @internal */\nexport const isRuntimeException = (u: unknown): u is Cause.RuntimeException => hasProperty(u, RuntimeExceptionTypeId)\n\n/** @internal */\nexport const InterruptedExceptionTypeId: Cause.InterruptedExceptionTypeId = Symbol.for(\n  \"effect/Cause/errors/InterruptedException\"\n) as Cause.InterruptedExceptionTypeId\n\n/** @internal */\nexport const InterruptedException = makeException<Cause.InterruptedException>({\n  [InterruptedExceptionTypeId]: InterruptedExceptionTypeId\n}, \"InterruptedException\")\n\n/** @internal */\nexport const isInterruptedException = (u: unknown): u is Cause.InterruptedException =>\n  hasProperty(u, InterruptedExceptionTypeId)\n\n/** @internal */\nexport const IllegalArgumentExceptionTypeId: Cause.IllegalArgumentExceptionTypeId = Symbol.for(\n  \"effect/Cause/errors/IllegalArgument\"\n) as Cause.IllegalArgumentExceptionTypeId\n\n/** @internal */\nexport const IllegalArgumentException = makeException<Cause.IllegalArgumentException>({\n  [IllegalArgumentExceptionTypeId]: IllegalArgumentExceptionTypeId\n}, \"IllegalArgumentException\")\n\n/** @internal */\nexport const isIllegalArgumentException = (u: unknown): u is Cause.IllegalArgumentException =>\n  hasProperty(u, IllegalArgumentExceptionTypeId)\n\n/** @internal */\nexport const NoSuchElementExceptionTypeId: Cause.NoSuchElementExceptionTypeId = Symbol.for(\n  \"effect/Cause/errors/NoSuchElement\"\n) as Cause.NoSuchElementExceptionTypeId\n\n/** @internal */\nexport const NoSuchElementException = makeException<Cause.NoSuchElementException>({\n  [NoSuchElementExceptionTypeId]: NoSuchElementExceptionTypeId\n}, \"NoSuchElementException\")\n\n/** @internal */\nexport const isNoSuchElementException = (u: unknown): u is Cause.NoSuchElementException =>\n  hasProperty(u, NoSuchElementExceptionTypeId)\n\n/** @internal */\nexport const InvalidPubSubCapacityExceptionTypeId: Cause.InvalidPubSubCapacityExceptionTypeId = Symbol.for(\n  \"effect/Cause/errors/InvalidPubSubCapacityException\"\n) as Cause.InvalidPubSubCapacityExceptionTypeId\n\n/** @internal */\nexport const InvalidPubSubCapacityException = makeException<Cause.InvalidPubSubCapacityException>({\n  [InvalidPubSubCapacityExceptionTypeId]: InvalidPubSubCapacityExceptionTypeId\n}, \"InvalidPubSubCapacityException\")\n\n/** @internal */\nexport const ExceededCapacityExceptionTypeId: Cause.ExceededCapacityExceptionTypeId = Symbol.for(\n  \"effect/Cause/errors/ExceededCapacityException\"\n) as Cause.ExceededCapacityExceptionTypeId\n\n/** @internal */\nexport const ExceededCapacityException = makeException<Cause.ExceededCapacityException>({\n  [ExceededCapacityExceptionTypeId]: ExceededCapacityExceptionTypeId\n}, \"ExceededCapacityException\")\n\n/** @internal */\nexport const isExceededCapacityException = (u: unknown): u is Cause.ExceededCapacityException =>\n  hasProperty(u, ExceededCapacityExceptionTypeId)\n\n/** @internal */\nexport const isInvalidCapacityError = (u: unknown): u is Cause.InvalidPubSubCapacityException =>\n  hasProperty(u, InvalidPubSubCapacityExceptionTypeId)\n\n/** @internal */\nexport const TimeoutExceptionTypeId: Cause.TimeoutExceptionTypeId = Symbol.for(\n  \"effect/Cause/errors/Timeout\"\n) as Cause.TimeoutExceptionTypeId\n\n/** @internal */\nexport const TimeoutException = makeException<Cause.TimeoutException>({\n  [TimeoutExceptionTypeId]: TimeoutExceptionTypeId\n}, \"TimeoutException\")\n/** @internal */\nexport const timeoutExceptionFromDuration = (duration: Duration.DurationInput): Cause.TimeoutException =>\n  new TimeoutException(`Operation timed out before the specified duration of '${Duration.format(duration)}' elapsed`)\n\n/** @internal */\nexport const isTimeoutException = (u: unknown): u is Cause.TimeoutException => hasProperty(u, TimeoutExceptionTypeId)\n\n/** @internal */\nexport const UnknownExceptionTypeId: Cause.UnknownExceptionTypeId = Symbol.for(\n  \"effect/Cause/errors/UnknownException\"\n) as Cause.UnknownExceptionTypeId\n\n/** @internal */\nexport const UnknownException: new(cause: unknown, message?: string | undefined) => Cause.UnknownException =\n  (function() {\n    class UnknownException extends YieldableError {\n      readonly _tag = \"UnknownException\"\n      readonly error: unknown\n      constructor(readonly cause: unknown, message?: string) {\n        super(message ?? \"An unknown error occurred\", { cause })\n        this.error = cause\n      }\n    }\n    Object.assign(UnknownException.prototype, {\n      [UnknownExceptionTypeId]: UnknownExceptionTypeId,\n      name: \"UnknownException\"\n    })\n    return UnknownException as any\n  })()\n\n/** @internal */\nexport const isUnknownException = (u: unknown): u is Cause.UnknownException => hasProperty(u, UnknownExceptionTypeId)\n\n// -----------------------------------------------------------------------------\n// Exit\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const exitIsExit = (u: unknown): u is Exit.Exit<unknown, unknown> =>\n  isEffect(u) && \"_tag\" in u && (u._tag === \"Success\" || u._tag === \"Failure\")\n\n/** @internal */\nexport const exitIsFailure = <A, E>(self: Exit.Exit<A, E>): self is Exit.Failure<A, E> => self._tag === \"Failure\"\n\n/** @internal */\nexport const exitIsSuccess = <A, E>(self: Exit.Exit<A, E>): self is Exit.Success<A, E> => self._tag === \"Success\"\n\n/** @internal */\nexport const exitIsInterrupted = <A, E>(self: Exit.Exit<A, E>): boolean => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return internalCause.isInterrupted(self.effect_instruction_i0)\n    case OpCodes.OP_SUCCESS:\n      return false\n  }\n}\n\n/** @internal */\nexport const exitAs = dual<\n  <A2>(value: A2) => <A, E>(self: Exit.Exit<A, E>) => Exit.Exit<A2, E>,\n  <A, E, A2>(self: Exit.Exit<A, E>, value: A2) => Exit.Exit<A2, E>\n>(2, <A, E, A2>(self: Exit.Exit<A, E>, value: A2): Exit.Exit<A2, E> => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE: {\n      return exitFailCause(self.effect_instruction_i0)\n    }\n    case OpCodes.OP_SUCCESS: {\n      return exitSucceed(value) as Exit.Exit<A2, E>\n    }\n  }\n})\n\n/** @internal */\nexport const exitAsVoid = <A, E>(self: Exit.Exit<A, E>): Exit.Exit<void, E> => exitAs(self, void 0)\n\n/** @internal */\nexport const exitCauseOption = <A, E>(self: Exit.Exit<A, E>): Option.Option<Cause.Cause<E>> => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return Option.some(self.effect_instruction_i0)\n    case OpCodes.OP_SUCCESS:\n      return Option.none()\n  }\n}\n\n/** @internal */\nexport const exitCollectAll = <A, E>(\n  exits: Iterable<Exit.Exit<A, E>>,\n  options?: {\n    readonly parallel?: boolean | undefined\n  }\n): Option.Option<Exit.Exit<Array<A>, E>> =>\n  exitCollectAllInternal(exits, options?.parallel ? internalCause.parallel : internalCause.sequential)\n\n/** @internal */\nexport const exitDie = (defect: unknown): Exit.Exit<never> =>\n  exitFailCause(internalCause.die(defect)) as Exit.Exit<never>\n\n/** @internal */\nexport const exitExists: {\n  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E>(self: Exit.Exit<A, E>) => self is Exit.Exit<B>\n  <A>(predicate: Predicate<NoInfer<A>>): <E>(self: Exit.Exit<A, E>) => boolean\n  <A, E, B extends A>(self: Exit.Exit<A, E>, refinement: Refinement<A, B>): self is Exit.Exit<B>\n  <A, E>(self: Exit.Exit<A, E>, predicate: Predicate<A>): boolean\n} = dual(2, <A, E, B extends A>(self: Exit.Exit<A, E>, refinement: Refinement<A, B>): self is Exit.Exit<B> => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return false\n    case OpCodes.OP_SUCCESS:\n      return refinement(self.effect_instruction_i0)\n  }\n})\n\n/** @internal */\nexport const exitFail = <E>(error: E): Exit.Exit<never, E> =>\n  exitFailCause(internalCause.fail(error)) as Exit.Exit<never, E>\n\n/** @internal */\nexport const exitFailCause = <E>(cause: Cause.Cause<E>): Exit.Exit<never, E> => {\n  const effect = new EffectPrimitiveFailure(OpCodes.OP_FAILURE) as any\n  effect.effect_instruction_i0 = cause\n  return effect\n}\n\n/** @internal */\nexport const exitFlatMap = dual<\n  <A, A2, E2>(f: (a: A) => Exit.Exit<A2, E2>) => <E>(self: Exit.Exit<A, E>) => Exit.Exit<A2, E | E2>,\n  <A, E, E2, A2>(self: Exit.Exit<A, E>, f: (a: A) => Exit.Exit<A2, E2>) => Exit.Exit<A2, E | E2>\n>(2, <A, E, E2, A2>(self: Exit.Exit<A, E>, f: (a: A) => Exit.Exit<A2, E2>): Exit.Exit<A2, E | E2> => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE: {\n      return exitFailCause(self.effect_instruction_i0)\n    }\n    case OpCodes.OP_SUCCESS: {\n      return f(self.effect_instruction_i0)\n    }\n  }\n})\n\n/** @internal */\nexport const exitFlatMapEffect: {\n  <A, E, A2, E2, R>(\n    f: (a: A) => Effect.Effect<Exit.Exit<A2, E>, E2, R>\n  ): (self: Exit.Exit<A, E>) => Effect.Effect<Exit.Exit<A2, E>, E2, R>\n  <A, E, A2, E2, R>(\n    self: Exit.Exit<A, E>,\n    f: (a: A) => Effect.Effect<Exit.Exit<A2, E>, E2, R>\n  ): Effect.Effect<Exit.Exit<A2, E>, E2, R>\n} = dual(2, <A, E, A2, E2, R>(\n  self: Exit.Exit<A, E>,\n  f: (a: A) => Effect.Effect<Exit.Exit<A2, E>, E2, R>\n): Effect.Effect<Exit.Exit<A2, E>, E2, R> => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE: {\n      return succeed(exitFailCause(self.effect_instruction_i0))\n    }\n    case OpCodes.OP_SUCCESS: {\n      return f(self.effect_instruction_i0)\n    }\n  }\n})\n\n/** @internal */\nexport const exitFlatten = <A, E, E2>(\n  self: Exit.Exit<Exit.Exit<A, E>, E2>\n): Exit.Exit<A, E | E2> => pipe(self, exitFlatMap(identity))\n\n/** @internal */\nexport const exitForEachEffect: {\n  <A, B, E2, R>(\n    f: (a: A) => Effect.Effect<B, E2, R>\n  ): <E>(self: Exit.Exit<A, E>) => Effect.Effect<Exit.Exit<B, E | E2>, never, R>\n  <A, E, B, E2, R>(\n    self: Exit.Exit<A, E>,\n    f: (a: A) => Effect.Effect<B, E2, R>\n  ): Effect.Effect<Exit.Exit<B, E | E2>, never, R>\n} = dual(2, <A, E, B, E2, R>(\n  self: Exit.Exit<A, E>,\n  f: (a: A) => Effect.Effect<B, E2, R>\n): Effect.Effect<Exit.Exit<B, E | E2>, never, R> => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE: {\n      return succeed(exitFailCause(self.effect_instruction_i0))\n    }\n    case OpCodes.OP_SUCCESS: {\n      return exit(f(self.effect_instruction_i0))\n    }\n  }\n})\n\n/** @internal */\nexport const exitFromEither = <R, L>(either: Either.Either<R, L>): Exit.Exit<R, L> => {\n  switch (either._tag) {\n    case \"Left\":\n      return exitFail(either.left)\n    case \"Right\":\n      return exitSucceed(either.right)\n  }\n}\n\n/** @internal */\nexport const exitFromOption = <A>(option: Option.Option<A>): Exit.Exit<A, void> => {\n  switch (option._tag) {\n    case \"None\":\n      return exitFail(void 0)\n    case \"Some\":\n      return exitSucceed(option.value)\n  }\n}\n\n/** @internal */\nexport const exitGetOrElse = dual<\n  <E, A2>(orElse: (cause: Cause.Cause<E>) => A2) => <A>(self: Exit.Exit<A, E>) => A | A2,\n  <A, E, A2>(self: Exit.Exit<A, E>, orElse: (cause: Cause.Cause<E>) => A2) => A | A2\n>(2, (self, orElse) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return orElse(self.effect_instruction_i0)\n    case OpCodes.OP_SUCCESS:\n      return self.effect_instruction_i0\n  }\n})\n\n/** @internal */\nexport const exitInterrupt = (fiberId: FiberId.FiberId): Exit.Exit<never> =>\n  exitFailCause(internalCause.interrupt(fiberId))\n\n/** @internal */\nexport const exitMap = dual<\n  <A, B>(f: (a: A) => B) => <E>(self: Exit.Exit<A, E>) => Exit.Exit<B, E>,\n  <A, E, B>(self: Exit.Exit<A, E>, f: (a: A) => B) => Exit.Exit<B, E>\n>(2, (self, f) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return exitFailCause(self.effect_instruction_i0)\n    case OpCodes.OP_SUCCESS:\n      return exitSucceed(f(self.effect_instruction_i0))\n  }\n})\n\n/** @internal */\nexport const exitMapBoth = dual<\n  <E, A, E2, A2>(\n    options: {\n      readonly onFailure: (e: E) => E2\n      readonly onSuccess: (a: A) => A2\n    }\n  ) => (self: Exit.Exit<A, E>) => Exit.Exit<A2, E2>,\n  <A, E, E2, A2>(\n    self: Exit.Exit<A, E>,\n    options: {\n      readonly onFailure: (e: E) => E2\n      readonly onSuccess: (a: A) => A2\n    }\n  ) => Exit.Exit<A2, E2>\n>(2, (self, { onFailure, onSuccess }) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return exitFailCause(pipe(self.effect_instruction_i0, internalCause.map(onFailure)))\n    case OpCodes.OP_SUCCESS:\n      return exitSucceed(onSuccess(self.effect_instruction_i0))\n  }\n})\n\n/** @internal */\nexport const exitMapError = dual<\n  <E, E2>(f: (e: E) => E2) => <A>(self: Exit.Exit<A, E>) => Exit.Exit<A, E2>,\n  <A, E, E2>(self: Exit.Exit<A, E>, f: (e: E) => E2) => Exit.Exit<A, E2>\n>(2, (self, f) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return exitFailCause(pipe(self.effect_instruction_i0, internalCause.map(f)))\n    case OpCodes.OP_SUCCESS:\n      return exitSucceed(self.effect_instruction_i0)\n  }\n})\n\n/** @internal */\nexport const exitMapErrorCause = dual<\n  <E, E2>(f: (cause: Cause.Cause<E>) => Cause.Cause<E2>) => <A>(self: Exit.Exit<A, E>) => Exit.Exit<A, E2>,\n  <E, A, E2>(self: Exit.Exit<A, E>, f: (cause: Cause.Cause<E>) => Cause.Cause<E2>) => Exit.Exit<A, E2>\n>(2, (self, f) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return exitFailCause(f(self.effect_instruction_i0))\n    case OpCodes.OP_SUCCESS:\n      return exitSucceed(self.effect_instruction_i0)\n  }\n})\n\n/** @internal */\nexport const exitMatch = dual<\n  <E, A, Z1, Z2>(options: {\n    readonly onFailure: (cause: Cause.Cause<E>) => Z1\n    readonly onSuccess: (a: A) => Z2\n  }) => (self: Exit.Exit<A, E>) => Z1 | Z2,\n  <A, E, Z1, Z2>(self: Exit.Exit<A, E>, options: {\n    readonly onFailure: (cause: Cause.Cause<E>) => Z1\n    readonly onSuccess: (a: A) => Z2\n  }) => Z1 | Z2\n>(2, (self, { onFailure, onSuccess }) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return onFailure(self.effect_instruction_i0)\n    case OpCodes.OP_SUCCESS:\n      return onSuccess(self.effect_instruction_i0)\n  }\n})\n\n/** @internal */\nexport const exitMatchEffect = dual<\n  <E, A2, E2, R, A, A3, E3, R2>(\n    options: {\n      readonly onFailure: (cause: Cause.Cause<E>) => Effect.Effect<A2, E2, R>\n      readonly onSuccess: (a: A) => Effect.Effect<A3, E3, R2>\n    }\n  ) => (self: Exit.Exit<A, E>) => Effect.Effect<A2 | A3, E2 | E3, R | R2>,\n  <A, E, A2, E2, R, A3, E3, R2>(\n    self: Exit.Exit<A, E>,\n    options: {\n      readonly onFailure: (cause: Cause.Cause<E>) => Effect.Effect<A2, E2, R>\n      readonly onSuccess: (a: A) => Effect.Effect<A3, E3, R2>\n    }\n  ) => Effect.Effect<A2 | A3, E2 | E3, R | R2>\n>(2, (self, { onFailure, onSuccess }) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return onFailure(self.effect_instruction_i0)\n    case OpCodes.OP_SUCCESS:\n      return onSuccess(self.effect_instruction_i0)\n  }\n})\n\n/** @internal */\nexport const exitSucceed = <A>(value: A): Exit.Exit<A> => {\n  const effect = new EffectPrimitiveSuccess(OpCodes.OP_SUCCESS) as any\n  effect.effect_instruction_i0 = value\n  return effect\n}\n\n/** @internal */\nexport const exitVoid: Exit.Exit<void> = exitSucceed(void 0)\n\n/** @internal */\nexport const exitZip = dual<\n  <A2, E2>(that: Exit.Exit<A2, E2>) => <A, E>(self: Exit.Exit<A, E>) => Exit.Exit<[A, A2], E | E2>,\n  <A, E, A2, E2>(self: Exit.Exit<A, E>, that: Exit.Exit<A2, E2>) => Exit.Exit<[A, A2], E | E2>\n>(2, (self, that) =>\n  exitZipWith(self, that, {\n    onSuccess: (a, a2) => [a, a2],\n    onFailure: internalCause.sequential\n  }))\n\n/** @internal */\nexport const exitZipLeft = dual<\n  <A2, E2>(that: Exit.Exit<A2, E2>) => <A, E>(self: Exit.Exit<A, E>) => Exit.Exit<A, E | E2>,\n  <A, E, A2, E2>(self: Exit.Exit<A, E>, that: Exit.Exit<A2, E2>) => Exit.Exit<A, E | E2>\n>(2, (self, that) =>\n  exitZipWith(self, that, {\n    onSuccess: (a, _) => a,\n    onFailure: internalCause.sequential\n  }))\n\n/** @internal */\nexport const exitZipRight = dual<\n  <A2, E2>(that: Exit.Exit<A2, E2>) => <A, E>(self: Exit.Exit<A, E>) => Exit.Exit<A2, E | E2>,\n  <A, E, A2, E2>(self: Exit.Exit<A, E>, that: Exit.Exit<A2, E2>) => Exit.Exit<A2, E | E2>\n>(2, (self, that) =>\n  exitZipWith(self, that, {\n    onSuccess: (_, a2) => a2,\n    onFailure: internalCause.sequential\n  }))\n\n/** @internal */\nexport const exitZipPar = dual<\n  <A2, E2>(that: Exit.Exit<A2, E2>) => <A, E>(self: Exit.Exit<A, E>) => Exit.Exit<[A, A2], E | E2>,\n  <A, E, A2, E2>(self: Exit.Exit<A, E>, that: Exit.Exit<A2, E2>) => Exit.Exit<[A, A2], E | E2>\n>(2, (self, that) =>\n  exitZipWith(self, that, {\n    onSuccess: (a, a2) => [a, a2],\n    onFailure: internalCause.parallel\n  }))\n\n/** @internal */\nexport const exitZipParLeft = dual<\n  <A2, E2>(that: Exit.Exit<A2, E2>) => <A, E>(self: Exit.Exit<A, E>) => Exit.Exit<A, E | E2>,\n  <A, E, A2, E2>(self: Exit.Exit<A, E>, that: Exit.Exit<A2, E2>) => Exit.Exit<A, E | E2>\n>(2, (self, that) =>\n  exitZipWith(self, that, {\n    onSuccess: (a, _) => a,\n    onFailure: internalCause.parallel\n  }))\n\n/** @internal */\nexport const exitZipParRight = dual<\n  <A2, E2>(that: Exit.Exit<A2, E2>) => <A, E>(self: Exit.Exit<A, E>) => Exit.Exit<A2, E | E2>,\n  <A, E, A2, E2>(self: Exit.Exit<A, E>, that: Exit.Exit<A2, E2>) => Exit.Exit<A2, E | E2>\n>(2, (self, that) =>\n  exitZipWith(self, that, {\n    onSuccess: (_, a2) => a2,\n    onFailure: internalCause.parallel\n  }))\n\n/** @internal */\nexport const exitZipWith = dual<\n  <B, E2, A, C, E>(\n    that: Exit.Exit<B, E2>,\n    options: {\n      readonly onSuccess: (a: A, b: B) => C\n      readonly onFailure: (cause: Cause.Cause<E>, cause2: Cause.Cause<E2>) => Cause.Cause<E | E2>\n    }\n  ) => (self: Exit.Exit<A, E>) => Exit.Exit<C, E | E2>,\n  <A, E, B, E2, C>(\n    self: Exit.Exit<A, E>,\n    that: Exit.Exit<B, E2>,\n    options: {\n      readonly onSuccess: (a: A, b: B) => C\n      readonly onFailure: (cause: Cause.Cause<E>, cause2: Cause.Cause<E2>) => Cause.Cause<E | E2>\n    }\n  ) => Exit.Exit<C, E | E2>\n>(3, (\n  self,\n  that,\n  { onFailure, onSuccess }\n) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE: {\n      switch (that._tag) {\n        case OpCodes.OP_SUCCESS:\n          return exitFailCause(self.effect_instruction_i0)\n        case OpCodes.OP_FAILURE: {\n          return exitFailCause(onFailure(self.effect_instruction_i0, that.effect_instruction_i0))\n        }\n      }\n    }\n    case OpCodes.OP_SUCCESS: {\n      switch (that._tag) {\n        case OpCodes.OP_SUCCESS:\n          return exitSucceed(onSuccess(self.effect_instruction_i0, that.effect_instruction_i0))\n        case OpCodes.OP_FAILURE:\n          return exitFailCause(that.effect_instruction_i0)\n      }\n    }\n  }\n})\n\nconst exitCollectAllInternal = <A, E>(\n  exits: Iterable<Exit.Exit<A, E>>,\n  combineCauses: (causeA: Cause.Cause<E>, causeB: Cause.Cause<E>) => Cause.Cause<E>\n): Option.Option<Exit.Exit<Array<A>, E>> => {\n  const list = Chunk.fromIterable(exits)\n  if (!Chunk.isNonEmpty(list)) {\n    return Option.none()\n  }\n  return pipe(\n    Chunk.tailNonEmpty(list),\n    Arr.reduce(\n      pipe(Chunk.headNonEmpty(list), exitMap<A, Chunk.Chunk<A>>(Chunk.of)),\n      (accumulator, current) =>\n        pipe(\n          accumulator,\n          exitZipWith(current, {\n            onSuccess: (list, value) => pipe(list, Chunk.prepend(value)),\n            onFailure: combineCauses\n          })\n        )\n    ),\n    exitMap(Chunk.reverse),\n    exitMap((chunk) => Chunk.toReadonlyArray(chunk) as Array<A>),\n    Option.some\n  )\n}\n\n// -----------------------------------------------------------------------------\n// Deferred\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const deferredUnsafeMake = <A, E = never>(fiberId: FiberId.FiberId): Deferred.Deferred<A, E> => {\n  const _deferred = {\n    ...CommitPrototype,\n    [deferred.DeferredTypeId]: deferred.deferredVariance,\n    state: MutableRef.make(deferred.pending<A, E>([])),\n    commit() {\n      return deferredAwait(this)\n    },\n    blockingOn: fiberId\n  }\n  return _deferred\n}\n\n/* @internal */\nexport const deferredMake = <A, E = never>(): Effect.Effect<Deferred.Deferred<A, E>> =>\n  flatMap(fiberId, (id) => deferredMakeAs<A, E>(id))\n\n/* @internal */\nexport const deferredMakeAs = <A, E = never>(fiberId: FiberId.FiberId): Effect.Effect<Deferred.Deferred<A, E>> =>\n  sync(() => deferredUnsafeMake<A, E>(fiberId))\n\n/* @internal */\nexport const deferredAwait = <A, E>(self: Deferred.Deferred<A, E>): Effect.Effect<A, E> =>\n  asyncInterrupt<A, E>((resume) => {\n    const state = MutableRef.get(self.state)\n    switch (state._tag) {\n      case DeferredOpCodes.OP_STATE_DONE: {\n        return resume(state.effect)\n      }\n      case DeferredOpCodes.OP_STATE_PENDING: {\n        // we can push here as the internal state is mutable\n        state.joiners.push(resume)\n        return deferredInterruptJoiner(self, resume)\n      }\n    }\n  }, self.blockingOn)\n\n/* @internal */\nexport const deferredComplete: {\n  <A, E>(effect: Effect.Effect<A, E>): (self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>\n  <A, E>(self: Deferred.Deferred<A, E>, effect: Effect.Effect<A, E>): Effect.Effect<boolean>\n} = dual(\n  2,\n  <A, E>(self: Deferred.Deferred<A, E>, effect: Effect.Effect<A, E>): Effect.Effect<boolean> =>\n    intoDeferred(effect, self)\n)\n\n/* @internal */\nexport const deferredCompleteWith = dual<\n  <A, E>(effect: Effect.Effect<A, E>) => (self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, effect: Effect.Effect<A, E>) => Effect.Effect<boolean>\n>(2, (self, effect) =>\n  sync(() => {\n    const state = MutableRef.get(self.state)\n    switch (state._tag) {\n      case DeferredOpCodes.OP_STATE_DONE: {\n        return false\n      }\n      case DeferredOpCodes.OP_STATE_PENDING: {\n        MutableRef.set(self.state, deferred.done(effect))\n        for (let i = 0, len = state.joiners.length; i < len; i++) {\n          state.joiners[i](effect)\n        }\n        return true\n      }\n    }\n  }))\n\n/* @internal */\nexport const deferredDone = dual<\n  <A, E>(exit: Exit.Exit<A, E>) => (self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, exit: Exit.Exit<A, E>) => Effect.Effect<boolean>\n>(2, (self, exit) => deferredCompleteWith(self, exit))\n\n/* @internal */\nexport const deferredFail = dual<\n  <E>(error: E) => <A>(self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, error: E) => Effect.Effect<boolean>\n>(2, (self, error) => deferredCompleteWith(self, fail(error)))\n\n/* @internal */\nexport const deferredFailSync = dual<\n  <E>(evaluate: LazyArg<E>) => <A>(self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, evaluate: LazyArg<E>) => Effect.Effect<boolean>\n>(2, (self, evaluate) => deferredCompleteWith(self, failSync(evaluate)))\n\n/* @internal */\nexport const deferredFailCause = dual<\n  <E>(cause: Cause.Cause<E>) => <A>(self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, cause: Cause.Cause<E>) => Effect.Effect<boolean>\n>(2, (self, cause) => deferredCompleteWith(self, failCause(cause)))\n\n/* @internal */\nexport const deferredFailCauseSync = dual<\n  <E>(evaluate: LazyArg<Cause.Cause<E>>) => <A>(self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, evaluate: LazyArg<Cause.Cause<E>>) => Effect.Effect<boolean>\n>(2, (self, evaluate) => deferredCompleteWith(self, failCauseSync(evaluate)))\n\n/* @internal */\nexport const deferredDie = dual<\n  (defect: unknown) => <A, E>(self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, defect: unknown) => Effect.Effect<boolean>\n>(2, (self, defect) => deferredCompleteWith(self, die(defect)))\n\n/* @internal */\nexport const deferredDieSync = dual<\n  (evaluate: LazyArg<unknown>) => <A, E>(self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, evaluate: LazyArg<unknown>) => Effect.Effect<boolean>\n>(2, (self, evaluate) => deferredCompleteWith(self, dieSync(evaluate)))\n\n/* @internal */\nexport const deferredInterrupt = <A, E>(self: Deferred.Deferred<A, E>): Effect.Effect<boolean> =>\n  flatMap(fiberId, (fiberId) => deferredCompleteWith(self, interruptWith(fiberId)))\n\n/* @internal */\nexport const deferredInterruptWith = dual<\n  (fiberId: FiberId.FiberId) => <A, E>(self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, fiberId: FiberId.FiberId) => Effect.Effect<boolean>\n>(2, (self, fiberId) => deferredCompleteWith(self, interruptWith(fiberId)))\n\n/* @internal */\nexport const deferredIsDone = <A, E>(self: Deferred.Deferred<A, E>): Effect.Effect<boolean> =>\n  sync(() => MutableRef.get(self.state)._tag === DeferredOpCodes.OP_STATE_DONE)\n\n/* @internal */\nexport const deferredPoll = <A, E>(\n  self: Deferred.Deferred<A, E>\n): Effect.Effect<Option.Option<Effect.Effect<A, E>>> =>\n  sync(() => {\n    const state = MutableRef.get(self.state)\n    switch (state._tag) {\n      case DeferredOpCodes.OP_STATE_DONE: {\n        return Option.some(state.effect)\n      }\n      case DeferredOpCodes.OP_STATE_PENDING: {\n        return Option.none()\n      }\n    }\n  })\n\n/* @internal */\nexport const deferredSucceed = dual<\n  <A>(value: A) => <E>(self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, value: A) => Effect.Effect<boolean>\n>(2, (self, value) => deferredCompleteWith(self, succeed(value)))\n\n/* @internal */\nexport const deferredSync = dual<\n  <A>(evaluate: LazyArg<A>) => <E>(self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, evaluate: LazyArg<A>) => Effect.Effect<boolean>\n>(2, (self, evaluate) => deferredCompleteWith(self, sync(evaluate)))\n\n/** @internal */\nexport const deferredUnsafeDone = <A, E>(self: Deferred.Deferred<A, E>, effect: Effect.Effect<A, E>): void => {\n  const state = MutableRef.get(self.state)\n  if (state._tag === DeferredOpCodes.OP_STATE_PENDING) {\n    MutableRef.set(self.state, deferred.done(effect))\n    for (let i = 0, len = state.joiners.length; i < len; i++) {\n      state.joiners[i](effect)\n    }\n  }\n}\n\nconst deferredInterruptJoiner = <A, E>(\n  self: Deferred.Deferred<A, E>,\n  joiner: (effect: Effect.Effect<A, E>) => void\n): Effect.Effect<void> =>\n  sync(() => {\n    const state = MutableRef.get(self.state)\n    if (state._tag === DeferredOpCodes.OP_STATE_PENDING) {\n      const index = state.joiners.indexOf(joiner)\n      if (index >= 0) {\n        // we can splice here as the internal state is mutable\n        state.joiners.splice(index, 1)\n      }\n    }\n  })\n\n// -----------------------------------------------------------------------------\n// Context\n// -----------------------------------------------------------------------------\n\nconst constContext = withFiberRuntime((fiber) => exitSucceed(fiber.currentContext))\n\n/* @internal */\nexport const context = <R>(): Effect.Effect<Context.Context<R>, never, R> => constContext as any\n\n/* @internal */\nexport const contextWith = <R0, A>(\n  f: (context: Context.Context<R0>) => A\n): Effect.Effect<A, never, R0> => map(context<R0>(), f)\n\n/* @internal */\nexport const contextWithEffect = <R0, A, E, R>(\n  f: (context: Context.Context<R0>) => Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R | R0> => flatMap(context<R0>(), f)\n\n/* @internal */\nexport const provideContext = dual<\n  <R>(context: Context.Context<R>) => <A, E>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, context: Context.Context<R>) => Effect.Effect<A, E>\n>(2, <A, E, R>(self: Effect.Effect<A, E, R>, context: Context.Context<R>) =>\n  fiberRefLocally(\n    currentContext,\n    context\n  )(self as Effect.Effect<A, E>))\n\n/* @internal */\nexport const provideSomeContext = dual<\n  <R>(context: Context.Context<R>) => <A, E, R1>(self: Effect.Effect<A, E, R1>) => Effect.Effect<A, E, Exclude<R1, R>>,\n  <A, E, R1, R>(self: Effect.Effect<A, E, R1>, context: Context.Context<R>) => Effect.Effect<A, E, Exclude<R1, R>>\n>(2, <A, E, R1, R>(self: Effect.Effect<A, E, R1>, context: Context.Context<R>) =>\n  fiberRefLocallyWith(\n    currentContext,\n    (parent) => Context.merge(parent, context)\n  )(self as Effect.Effect<A, E>))\n\n/* @internal */\nexport const mapInputContext = dual<\n  <R0, R>(\n    f: (context: Context.Context<R0>) => Context.Context<R>\n  ) => <A, E>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R0>,\n  <A, E, R, R0>(\n    self: Effect.Effect<A, E, R>,\n    f: (context: Context.Context<R0>) => Context.Context<R>\n  ) => Effect.Effect<A, E, R0>\n>(2, <A, E, R, R0>(\n  self: Effect.Effect<A, E, R>,\n  f: (context: Context.Context<R0>) => Context.Context<R>\n) => contextWithEffect((context: Context.Context<R0>) => provideContext(self, f(context))))\n\n// -----------------------------------------------------------------------------\n// Tracing\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const currentSpanFromFiber = <A, E>(fiber: Fiber.RuntimeFiber<A, E>): Option.Option<Tracer.Span> => {\n  const span = fiber.currentSpan\n  return span !== undefined && span._tag === \"Span\" ? Option.some(span) : Option.none()\n}\n\nconst NoopSpanProto: Omit<Tracer.Span, \"parent\" | \"name\" | \"context\"> = {\n  _tag: \"Span\",\n  spanId: \"noop\",\n  traceId: \"noop\",\n  sampled: false,\n  status: {\n    _tag: \"Ended\",\n    startTime: BigInt(0),\n    endTime: BigInt(0),\n    exit: exitVoid\n  },\n  attributes: new Map(),\n  links: [],\n  kind: \"internal\",\n  attribute() {},\n  event() {},\n  end() {}\n}\n\n/** @internal */\nexport const noopSpan = (options: {\n  readonly name: string\n  readonly parent: Option.Option<Tracer.AnySpan>\n  readonly context: Context.Context<never>\n}): Tracer.Span => Object.assign(Object.create(NoopSpanProto), options)\n"],"names":["Arr","Chunk","Context","Duration","Either","Equal","FiberId","dual","identity","pipe","globalValue","Hash","HashMap","format","NodeInspectSymbol","toJSON","List","MutableRef","Option","pipeArguments","hasProperty","isObject","isPromiseLike","RuntimeFlagsPatch","internalCall","YieldWrap","_blockedRequests","internalCause","deferred","internalDiffer","CommitPrototype","effectVariance","StructuralCommitPrototype","getBugErrorMessage","DeferredOpCodes","OpCodes","_runtimeFlags","SingleShotGen","EffectErrorSymbolKey","EffectErrorTypeId","Symbol","for","isEffectError","u","makeEffectError","cause","_tag","blocked","blockedRequests","_continue","effect","EffectPrimitive","effect_instruction_i0","effect_instruction_i1","runRequestBlock","EffectTypeId","RevertFlags","patch","op","_op","OP_REVERT_FLAGS","constructor","undefined","effect_instruction_i2","trace","symbol","that","cached","random","arguments","_id","toString","iterator","EffectPrimitiveFailure","exitIsExit","equals","string","combine","hash","EffectPrimitiveSuccess","value","isEffect","withFiberRuntime","withRuntime","OP_WITH_RUNTIME","acquireUseRelease","acquire","use","release","uninterruptibleMask","restore","flatMap","a","exit","suspend","matchCauseEffect","onFailure","OP_FAILURE","failCause","sequential","OP_SUCCESS","onSuccess","as","self","succeed","asVoid","custom","wrapper","OP_COMMIT","length","commit","Error","unsafeAsync","register","blockingOn","none","OP_ASYNC","cancelerRef","resume","onInterrupt","_","void_","asyncInterrupt","async_","backingResume","pendingEffect","proxyResume","controllerRef","AbortController","signal","abort","async","catchAllCause","f","OP_ON_FAILURE","catchAll","matchEffect","catchIf","predicate","either","failureOrCause","left","right","catchSome","pf","getOrElse","checkInterruptible","status","interruption","runtimeFlags","spanSymbol","originalSymbol","originalInstance","obj","capture","span","isSome","Proxy","has","target","p","get","die","defect","fiber","currentSpanFromFiber","dieMessage","message","failCauseSync","RuntimeException","dieSync","evaluate","sync","e","matchCause","exitFailCause","exitSucceed","fail","error","failSync","fiberId","state","id","fiberIdWith","OP_ON_SUCCESS","andThen","b","then","UnknownException","step","flatten","flip","options","OP_ON_SUCCESS_AND_FAILURE","defects","electFailures","failures","unsafeHead","forEachSequential","arr","fromIterable","ret","allocate","i","whileLoop","while","body","forEachSequentialDiscard","if_","args","onTrue","onFalse","interrupt","interruptWith","interruptible","OP_UPDATE_RUNTIME_FLAGS","enable","Interruption","interruptibleMask","oldFlags","uninterruptible","intoDeferred","deferredDone","map","mapBoth","mapError","onError","cleanup","onExit","exitIsSuccess","cause1","result","cause2","success","zipRight","exitMatch","isInterruptedOnly","interruptors","orElse","attemptOrElse","orDie","orDieWith","partitionMap","thunk","OP_SYNC","tap","transplant","scopeOverride","getFiberRef","currentForkScopeOverride","scope","fiberRefLocally","some","getOrThrow","keepDefectsAndElectFailures","disable","void","updateRuntimeFlags","whenEffect","condition","OP_WHILE","fromIterator","OP_ITERATOR","gen","bind","withConcurrency","concurrency","currentConcurrency","withRequestBatching","requestBatching","currentRequestBatching","withRuntimeFlags","update","withTracerEnabled","enabled","currentTracerEnabled","withTracerTiming","currentTracerTimingEnabled","yieldNow","OP_YIELD","priority","withSchedulingPriority","zip","zipFlatten","zipLeft","zipWith","never","interval","setInterval","clearInterval","interruptFiber","interruptAsFiber","interruptAsFork","await","logLevelAll","syslog","label","ordinal","Number","MIN_SAFE_INTEGER","logLevelFatal","logLevelError","logLevelWarning","logLevelInfo","logLevelDebug","logLevelTrace","logLevelNone","MAX_SAFE_INTEGER","allLogLevels","FiberRefSymbolKey","FiberRefTypeId","fiberRefVariance","_A","fiberRefGet","fiberRefGetAndSet","fiberRefModify","v","fiberRefGetAndUpdate","fiberRefGetAndUpdateSome","fiberRefGetWith","fiberRefSet","fiberRefDelete","unsafeDeleteFiberRef","fiberRefReset","initial","setFiberRef","fiberRefModifySome","def","fiberRefUpdate","fiberRefUpdateSome","fiberRefUpdateAndGet","fiberRefUpdateSomeAndGet","RequestResolverSymbolKey","RequestResolverTypeId","requestResolverVariance","_R","RequestResolverImpl","runAll","isRequestResolver","identified","ids","resolverLocally","requests","make","requestBlockLocally","ref","reduce","LocallyReducer","emptyCase","empty","parCase","par","seqCase","seq","singleCase","dataSource","blockedRequest","single","oldValue","fiberRefLocallyWith","fiberRefUnsafeMake","fiberRefUnsafeMakePatch","differ","fork","join","fiberRefUnsafeMakeHashSet","hashSet","fiberRefUnsafeMakeReadonlyArray","readonlyArray","fiberRefUnsafeMakeContext","environment","_fiberRef","diff","newValue","first","second","n","fiberRefUnsafeMakeRuntimeFlags","currentContext","currentSchedulingPriority","currentMaxOpsBeforeYield","currentLogAnnotations","currentLogLevel","currentLogSpan","scheduler","withMaxOpsBeforeYield","currentUnhandledErrorLogLevel","withUnhandledErrorLogLevel","level","currentMetricLabels","metricLabels","parent","currentInterruptedCause","currentTracerSpanAnnotations","currentTracerSpanLinks","ScopeTypeId","CloseableScopeTypeId","scopeAddFinalizer","finalizer","addFinalizer","scopeAddFinalizerExit","scopeClose","close","scopeFork","strategy","causeSquash","causeSquashWith","option","failureOption","head","match","onNone","interrupts","InterruptedException","onSome","YieldableError","globalThis","prototype","stack","split","slice","pretty","renderErrorCause","Object","assign","makeException","proto","tag","Base","name","RuntimeExceptionTypeId","isRuntimeException","InterruptedExceptionTypeId","isInterruptedException","IllegalArgumentExceptionTypeId","IllegalArgumentException","isIllegalArgumentException","NoSuchElementExceptionTypeId","NoSuchElementException","isNoSuchElementException","InvalidPubSubCapacityExceptionTypeId","InvalidPubSubCapacityException","ExceededCapacityExceptionTypeId","ExceededCapacityException","isExceededCapacityException","isInvalidCapacityError","TimeoutExceptionTypeId","TimeoutException","timeoutExceptionFromDuration","duration","isTimeoutException","UnknownExceptionTypeId","isUnknownException","exitIsFailure","exitIsInterrupted","isInterrupted","exitAs","exitAsVoid","exitCauseOption","exitCollectAll","exits","exitCollectAllInternal","parallel","exitDie","exitExists","refinement","exitFail","exitFlatMap","exitFlatMapEffect","exitFlatten","exitForEachEffect","exitFromEither","exitFromOption","exitGetOrElse","exitInterrupt","exitMap","exitMapBoth","exitMapError","exitMapErrorCause","exitMatchEffect","exitVoid","exitZip","exitZipWith","a2","exitZipLeft","exitZipRight","exitZipPar","exitZipParLeft","exitZipParRight","combineCauses","list","isNonEmpty","tailNonEmpty","headNonEmpty","of","accumulator","current","prepend","reverse","chunk","toReadonlyArray","deferredUnsafeMake","_deferred","DeferredTypeId","deferredVariance","pending","deferredAwait","deferredMake","deferredMakeAs","OP_STATE_DONE","OP_STATE_PENDING","joiners","push","deferredInterruptJoiner","deferredComplete","deferredCompleteWith","set","done","len","deferredFail","deferredFailSync","deferredFailCause","deferredFailCauseSync","deferredDie","deferredDieSync","deferredInterrupt","deferredInterruptWith","deferredIsDone","deferredPoll","deferredSucceed","deferredSync","deferredUnsafeDone","joiner","index","indexOf","splice","constContext","context","contextWith","contextWithEffect","provideContext","provideSomeContext","merge","mapInputContext","currentSpan","NoopSpanProto","spanId","traceId","sampled","startTime","BigInt","endTime","attributes","Map","links","kind","attribute","event","end","noopSpan","create"],"mappings":"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","ignoreList":[0],"debugId":null}}]
}